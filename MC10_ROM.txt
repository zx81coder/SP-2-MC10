      |  ****************************************************************
      |  * Radio Shack MC-10
      |  * MICROCOLOR BASIC 1.0
      |  *
      |  *
      |
      |
      |  **
      |  **  Some equates
      |  **
      |  BS        equ       $08                 ; backspace
      |  CR        equ       $0D                 ; carriage return (ENTER)
      |  PAUSE     equ       $13                 ; PAUSE control code (hift-@)
      |  SPACE     equ       $20                 ; space
      |  LBUFMX    equ       128                 ; maximum number of chars in line input buffer
      |  STKBUF    equ       58                  ; minimum cushion size for the stack
      |  NMSTRS    equ       3                   ; maximum number of entries on the string stack
      |
      |
      |  **
      |  **  Error Numbers
      |  **
      |  NF_ERR    equ       0                   ; NEXT without FOR
      |  SN_ERR    equ       2                   ; Syntax error
      |  RG_ERR    equ       4                   ; RETURN without GOSUB
      |  OD_ERR    equ       6                   ; Out of DATA
      |  FC_ERR    equ       8                   ; Illegal Function Call
      |  OV_ERR    equ       10                  ; Overflow
      |  OM_ERR    equ       12                  ; Out of Memory
      |  UL_ERR    equ       14                  ; Undefined Line number
      |  BS_ERR    equ       16                  ; Bad Subscript
      |  DD_ERR    equ       18                  ; Doubly Dimensioned array
      |  D0_ERR    equ       20                  ; Division by Zero
      |  ID_ERR    equ       22                  ; Illegal in Direct mode
      |  TM_ERR    equ       24                  ; Type Mismatch
      |  OS_ERR    equ       26                  ; Out of String space
      |  LS_ERR    equ       28                  ; Length of String (too long)
      |  ST_ERR    equ       30                  ; String formula Too complex
      |  CN_ERR    equ       32                  ; Can't continue
      |  IO_ERR    equ       34                  ; Input/Output error
      |  FM_ERR    equ       36                  ; File Mode error
      |
      |
      |  ** 
      |  ** Opcodes used for skipping over instructions
      |  ** 
      |  SKP1      equ       $21                 ; Skip single byte instruction (BRN _)
      |  SKP2      equ       $8C                 ; Skip two-byte instruction (CPX #__)
      |  SKP1LDA   equ       $86                 ; Skip single byte instruction (LDA #_)
      |  SKP1LDB   equ       $C6                 ; Skip single byte instruction (LDB #_)
      |
      |
      |
      |  ****************************************************************
      |  **   MEMORY MAP
      |  ****************************************************************
      |            org       $0000
      |
      |  *---------------------------------------------------------------
      |  *  6803 Internals
      |  *
 0000 |  P1DDR     rmb       1                   ; Port 1 Data Direction Register
 0001 |  P2DDR     rmb       1                   ; Port 2 DDR (5 bits)
 0002 |  P1DATA    rmb       1                   ; Port 1 Data Register
 0003 |  P2DATA    rmb       1                   ; Port 2 Data (5 bits)
 0004 |            rmb       4                   ; not available
 0008 |  TCSR      rmb       1                   ; Timer Status and Control Register
 0009 |  TIMER     rmb       2                   ; Free running counter
 000B |  TOCR      rmb       2                   ; Timer Output Compare Register
 000D |  TICR      rmb       2                   ; Timer Input Capture Register
 000F |            rmb       1                   ; not available
 0010 |  SERMOD    rmb       1                   ; Serial port Rate and Mode Control Register
 0011 |  SERCSR    rmb       1                   ; Serial port Control and Status Registers
 0012 |  SERIN     rmb       1                   ; Serial port Receiver Data Register
 0013 |  SEROUT    rmb       1                   ; Serial port Transmit Data Register
 0014 |  RAMCR     rmb       1                   ; RAM Control Register
 0015 |            rmb       11                  ; not available
      |
      |  *---------------------------------------------------------------
      |  *  The address range of $0020 to $007F is not mapped
      |  *  to anything by the stock hardware.
      |  *
 0020 |            rmb       96                  ; not available
      |
      |  *---------------------------------------------------------------
      |  *  6803 On-Board RAM
      |  *
 0080 |  CHARAC    rmb       1                   ; termination character 1
 0081 |  ENDCHR    rmb       1                   ; termination character 2
 0082 |  TMPLOC    rmb       1                   ; scratch variable
 0083 |  DIMFLG    rmb       1                   ; dimensioning flag (non-zero while in a DIM statement)
 0084 |  VALTYP    rmb       1                   ; value type ($00 = numeric, $FF = string)
 0085 |  TMPFLG    rmb       1                   ; temporary flag variable (used during Crunch and String Allocation)
 0086 |  ARYMOD    rmb       1                   ; array mode flag to force ($01) or disable ($80) array lookups
 0087 |  INPFLG    rmb       1                   ; flag to differentiate INPUT from READ
 0088 |  RELFLG    rmb       1                   ; relational operator flags
 0089 |  TMPTR1    rmb       2                   ; temporary pointer 1
 008B |  TMPTR2    rmb       2                   ; temporary pointer 2
 008D |  FPA2      rmb       4                   ; floating point accumulator #2 (mantissa only)
 0091 |  STKSAV    rmb       2                   ; temporary storage for the stack pointer
      |
      |  **
      |  ** Basic Program and Variable allocation pointers
      |  **
 0093 |  TXTTAB    rmb       2                   ; start of Basic program
 0095 |  VARTAB    rmb       2                   ; start of simple variables
 0097 |  ARYTAB    rmb       2                   ; start of array variables
 0099 |  ARYEND    rmb       2                   ; end of array variables (first Free RAM address)
 009B |  FRETOP    rmb       2                   ; lower bounds of string space, upper bounds of stack
 009D |  STRTAB    rmb       2                   ; pointer to used string space (grows downward)
 009F |  FRESPC    rmb       2                   ; string space allocator returns a pointer here
 00A1 |  MEMSIZ    rmb       2                   ; highest RAM address used by Basic (adjustable with CLEAR)
      |
      |  **
      |  ** Basic Program execution info
      |  **
 00A3 |  BRKLIN    rmb       2                   ; line number where program execution stopped
 00A5 |  BINVAL    rmb       2                   ; binary integer value (often used to hold a parsed line number)
 00A7 |  OLDPTR    rmb       2                   ; address where program execution stopped (for use by CONT)
 00A9 |  TINPTR    rmb       2                   ; temporary storage of parser pointer
 00AB |  DATLIN    rmb       2                   ; line number where search for DATA statements is taking place
 00AD |  DATPTR    rmb       2                   ; pointer to where a READ statement will start searching for a DATA statement
 00AF |  DATTMP    rmb       2                   ; temp storage for INPUT/READ parse pointer
 00B1 |  VARNAM    rmb       2                   ; temp storage of variable name
 00B3 |  VARADR    rmb       2                   ; temp storage of pointer to variable descriptor
 00B5 |  VARDES    rmb       2                   ; pointer to variable's descriptor
 00B7 |  OPSAVE    rmb       2                   ; saved pointer to entry in the operator dispatch table
 00B9 |  RELOPS    rmb       1                   ; temporary relational operator flag
      |
      |  **
      |  **  Floating Point Accumulators 3, 4 and 5 are
      |  **  used mainly as scratch data storage.
      |  **
      |  FPA3      equ       *                   ; Packed Floating Point Accumulator #3 ($BA-$BE)
 00BA |  FP3EXP    rmb       1                   ; exponent of FPA3
 00BB |  DSTEND    rmb       2                   ; holds destination end address for upward block move
 00BD |  SRCEND    rmb       2                   ; holds source end address for upward block move
      |
      |  FPA4      equ       *                   ; Packed Floating Point Accumulator #4 ($BF-$C3)
      |  DSTPTR    equ       *                   ; destination address for block moves (word)
 00BF |  FRACNT    rmb       1                   ; number of digits found on the right side of the decimal point
 00C0 |  DECFLG    rmb       1                   ; decimal point flag during ASCII to binary number conversion
      |  SRCPTR    equ       *                   ; source address for block moves
 00C1 |  SCIEXP    rmb       1                   ; 8 bit exponent value when parsing scientific notation
 00C2 |  EXPSGN    rmb       1                   ; sign of exponent when parsing scientific notation
 00C3 |            rmb       1                   ; least significant byte of FPA4 mantissa
      |
      |  FPA5      equ       *                   ; Packed Floating Point Accumulator #5 ($C4-$C8)
 00C4 |  FP5EXP    rmb       1                   ; exponent and packed sign bit for FPA5
 00C5 |  HISTRD    rmb       2                   ; descriptor address for 'highest' string during compaction
 00C7 |  DESPTR    rmb       2
      |
      |  **
      |  **  Floating Point Accumulator 0
      |  **
 00C9 |  FP0EXP    rmb       1                   ; exponent
 00CA |  FPA0      rmb       4                   ; mantissa
 00CE |  FP0SGN    rmb       1                   ; sign
 00CF |  COEFCT    rmb       1                   ; polynomial coefficient counter
 00D0 |  STRDES    rmb       5                   ; temporary string descriptor
 00D5 |  SFTSGN    rmb       1                   ; sign data shifted in during de-normalization
      |
      |  **
      |  **  Floating Point Accumulator 1
      |  **
 00D6 |  FP1EXP    rmb       1                   ; exponent
 00D7 |  FPA1      rmb       4                   ; mantissa
 00DB |  FP1SGN    rmb       1                   ; sign
 00DC |  RESSGN    rmb       1                   ; resulting sign for operation
 00DD |  FPSBYT    rmb       1                   ; sub-precision (fifth mantissa byte)
 00DE |  OUTPTR    rmb       2                   ; multi-purpose pointer (LIST, string, arrays, polynomial)
      |
 00E0 |            rmb       2                   ; not used
 00E2 |  CURLIN    rmb       2                   ; current execution line number (-1 = not running)
      |
      |  **
      |  **  I/O Device Info
      |  **
 00E4 |  DEVCFW    rmb       1                   ; current output device's tab width
 00E5 |  DEVLCF    rmb       1                   ; current output device's last tab column
 00E6 |  DEVPOS    rmb       1                   ; current line position on current output device
 00E7 |  DEVWID    rmb       1                   ; current output device's line width
 00E8 |  DEVNUM    rmb       1                   ; current I/O device number:  0 = Screen, -2 = Printer
 00E9 |  EOFLAG    rmb       1                   ; EOF flag for use by CONSOLE IN hooks
      |
 00EA |  RSTFLG    rmb       1                   ; warm start reset flag  ($55 permits warm start) 
      |
      |
      |  *---------------------------------------------------------------
      |  *  The front-end of the character parser subroutine is copied here
      |  *  from ROM during initialization.  It needs to be in RAM because
      |  *  it utilizes self-modifying code.  When entered at CHRGET the
      |  *  routine advances the parse pointer and picks up the next character.
      |  *  When entered at CHRGOT the routine re-loads the character got
      |  *  by the most recent call to CHRGET.
      |  *
 00EB |  CHRGET    rmb       3         *  inc   CHRPTR+1     ; increment LSB of parse location
 00EE |            rmb       2         *  bne   GETCCH       ; branch if no carry
 00F0 |            rmb       3         *  inc   CHRPTR       ; increment MSB of parse location
 00F3 |  CHRGOT    rmb       1         *  lda   >nnnn        ; load char from parse location (Extended)
 00F4 |  CHRPTR    rmb       2         *                     ; current parse location
 00F6 |            rmb       3         *  jmp   LE1C8        ; goto back-end code in ROM
      |
      |
      |  **
      |  **  Unused Bytes in the Direct Page
      |  **
 00F9 |            rmb       7                   ; not used
      |
      |
      |  *---------------------------------------------------------------
      |  *  The address range of $0100 to $3FFF is not mapped
      |  *  to anything by the stock hardware.
      |  *
 0100 |            rmb       $3F00               ; not available
      |
      |
      |  *---------------------------------------------------------------
      |  *  The 4K built-in RAM begins here
      |  *
 4000 |  VIDRAM    rmb       512                 ; 512 bytes of video RAM
      |
      |
      |  ***
      |  ***  The system variables from SCIVEC to CLDRSZ ($4200 - $4230) are
      |  ***  initialized during a cold start with data from ROM ($F7DF - $F80F).
      |  ***
      |
      |  * Secondary Interrupt Vectors (all are initialized to RTI,$00,$00)
 4200 |  SCIVEC    rmb       3                   ; SCI
 4203 |  TOFVEC    rmb       3                   ; Timer Overflow
 4206 |  OCFVEC    rmb       3                   ; Output Compare
 4209 |  ICFVEC    rmb       3                   ; Input Capture
 420C |  IRQVEC    rmb       3                   ; IRQ1
 420F |  SWIVEC    rmb       3                   ; SWI
 4212 |  NMIVEC    rmb       3                   ; NMI
      |
 4215 |  USRVEC    rmb       3                   ; USR function vector (JMP ILLFNC)
 4218 |  RVSEED    rmb       4                   ; variable random number seed ($4FC75259)
 421C |  CAPLOK    rmb       1                   ; keyboard Caps-Lock state ($FF)
 421D |  DEBDLY    rmb       2                   ; keyboard debounce delay ($045E)
 421F |  EXECJP    rmb       2                   ; default EXEC address (ILLFNC)
 4221 |  WSTVEC    rmb       2                   ; warm start vector (WMSTRT)
 4223 |  LPTBTD    rmb       2                   ; printer baud rate delay (118)
 4225 |  LPTLND    rmb       2                   ; printer carriage return delay (1)
 4227 |  LPTCFW    rmb       1                   ; printer tab width (16)
 4228 |  LPTLCF    rmb       1                   ; printer's last tab column (112)
 4229 |  LPTWID    rmb       1                   ; printer line width (132)
 422A |  LPTPOS    rmb       1                   ; current printer line position (0)
 422B |  BLNKTM    rmb       1                   ; cursor blink timer (1)
      |
      |  * Cassette Timing
 422C |  CYCPAR    rmb       1                   ; cassette 1200/2400 Hz cycle partition (21)
 422D |  CMAXTR    rmb       1                   ; time limit for a valid cassette transition (26)
 422E |  TRNPAR    rmb       1                   ; cassette 1200/2400 Hz transition partition (11)
 422F |  CLDRSZ    rmb       2                   ; number of cassette leader bytes to write (128)
      |
      |  * Keyboard
 4231 |  KEYBUF    rmb       8                   ; keyboard tracking state
 4239 |  KEYCOL    rmb       1                   ; current keyboard column number (while polling)
 423A |  CTRLKY    rmb       1                   ; state of CONTROL key at last key-down
 423B |  BRKSTA    rmb       1                   ; tracking state for the BREAK key
      |
 423C |  PIXMSK    rmb       1                   ; pixel mask for SET, RESET and POINT
 423D |  SDSPTR    rmb       2                   ; string descriptor stack pointer
 423F |  TOPSTR    rmb       2                   ; pointer to top entry on the string stack
 4241 |  STRSTK    rmb       NMSTRS*5            ; space allocated for the string stack
 4250 |  TOPRAM    rmb       2                   ; highest RAM address -1 ($4FFE with 4K)
 4252 |  RNDVAL    rmb       4                   ; partial product from FP multiplication used as data for RND
      |
      |  * Cassette File Name Search String
 4256 |  CFNLEN    rmb       1                   ; length of cassette file name search string
 4257 |  CFNSTR    rmb       8                   ; cassette file name search string buffer
      |
      |  * Cassette File Name Block Buffer
 425F |  NAMBLK    rmb       8                   ; file name
 4267 |  CFTYPE    rmb       1                   ; file type ($00 = Basic; $02 = ML; $04 = Array Data)
 4268 |  ASCFLG    rmb       1                   ; ASCII file flag ($00 = Binary; $FF = ASCII)
 4269 |  GAPFLG    rmb       1                   ; file gaps flag ($00 = continuous; $FF = gaps)
 426A |  CFEXEC    rmb       2                   ; EXEC addrress for ML file
 426C |  LDSIZE    rmb       2                   ; LOAD address for ML file; SIZE of Basic/Array file
      |
      |  * Cassette I/O
 426E |  CLDFLG    rmb       1                   ; set to $FF inside CLOAD to force a NEW upon error
 426F |  CASBEG    rmb       2                   ; start address for cassette file output
 4271 |  CASEND    rmb       2                   ; end address for cassette file output
 4273 |  NOLOAD    rmb       1                   ; SKIPF flag (prevents loading cassette data into RAM)
 4274 |  MYSTRY    rmb       1                   ; mystery flag tested by cassette file scan routine 
 4275 |  BLKTYP    rmb       1                   ; cassette file block type
 4276 |  BLKLEN    rmb       1                   ; cassette file block length
 4277 |            rmb       1                   ; not used
 4278 |  BLKPTR    rmb       2                   ; cassette file block pointer
 427A |  BLKSUM    rmb       1                   ; cassette file block checksum
 427B |  CCTERR    rmb       1                   ; cassette byte counter and error flag
 427C |  CBITCT    rmb       1                   ; cassette input bit/phase counter
 427D |  CASTIM    rmb       1                   ; cassette signal transition/cylce time
 427E |  CASPOL    rmb       1                   ; cassette input polarity (+/-96)
      |
 427F |  IKYCOD    rmb       1                   ; key code discovered during BREAK check (for INKEY$)
 4280 |  CRSPTR    rmb       2                   ; cursor Position
 4282 |  CRSCLR    rmb       1                   ; cursor color
 4283 |  ENDFLG    rmb       1                   ; STOP / END flag:  negative = STOP, positive = END
 4284 |  UNCRFL    rmb       1                   ; flags byte used to UNCRUNCH a program line
      |
      |  * Extension Hooks
 4285 |  RVEC1     rmb       3                   ; extension hook for CONSOLE IN
 4288 |  RVEC2     rmb       3                   ; extension hook for CONSOLE OUT
 428B |  RVEC3     rmb       3                   ; extension hook to install Tab and Line settings for output device
 428E |  RVEC4     rmb       3                   ; extension hook for program initialization (NEW,RUN,CLEAR)
 4291 |  RVEC5     rmb       3                   ; extension hook for line input
 4294 |  RVEC6     rmb       3                   ; extension hook for expression terminal evaluator
 4297 |  RVEC7     rmb       3                   ; extension hook for implementing ON ERR GOTO
 429A |  RVEC8     rmb       3                   ; extension hook for additional error messages
 429D |  RVEC9     rmb       3                   ; extension hook for ASCII to FP number conversion
 42A0 |  RVEC10    rmb       3                   ; extension hook for command dispatcher
 42A3 |  RVEC11    rmb       3                   ; extension hook for crunching keywords
 42A6 |  RVEC12    rmb       3                   ; extension hook for uncrunching a token
 42A9 |  RVEC13    rmb       3                   ; extension hook for polling the keyboard
 42AC |  RVEC14    rmb       3                   ; extension hook for interpreting CONTROL key values
      |
 42AF |  LNKLSB    rmb       1                   ; $FF - ensures a non-zero link LSB during program line insertion
 42B0 |  LINUMB    rmb       2                   ; the program line number being inserted or deleted
 42B2 |  LINBUF    rmb       130                 ; line input buffer (128 characters plus two null terminators)
 4334 |  MOVSTR    rmb       1                   ; first byte of buffer for a small string to be moved into string space
 4335 |  STRBUF    rmb       17                  ; buffer for a small string (typically the output of Number-to-String)
      |
      |  PRGRAM    equ       *                   ; start of program space
      |
      |
      |  *---------------------------------------------------------------
      |  *  Keyboard / Video / Sound Port
      |  *
      |  *  Reading this port obtains the keyboard row data for the
      |  *  column being strobed.  Writing to this port configures
      |  *  the 6847 VDG (bits 2-6) and sets the output state of the
      |  *  single-bit sound channel (bit 7).
      |  *
      |  KVSPRT    equ       $BFFF
      |
      |
      |
      |                 ****************************************************************
      |                 **   8K ROM CODE
      |                 ****************************************************************
      |                           org       $E000
      | 
      |                 * Function Dispatch Table
 E000 | F2 BA           FNTABL    fdb       SGN
 E002 | F3 35                     fdb       INT
 E004 | F2 D5                     fdb       ABS
 E006 | 42 15                     fdb       USRVEC              ; USR
 E008 | F6 2A                     fdb       RND
 E00A | F5 4D                     fdb       SQR
 E00C | F0 B9                     fdb       LOG
 E00E | F5 C9                     fdb       EXPFN               ; EXP
 E010 | F6 8C                     fdb       SIN
 E012 | F6 86                     fdb       COS
 E014 | F6 D2                     fdb       TAN
 E016 | EF 5F                     fdb       PEEK
 E018 | EE 82                     fdb       LEN
 E01A | EC ED                     fdb       STRSTR              ; STR$
 E01C | EF 1C                     fdb       VAL
 E01E | EE A2                     fdb       ASC
 E020 | EE 8E                     fdb       CHRSTR              ; CHR$
 E022 | EE AD                     fdb       LFTSTR              ; LEFT$
 E024 | EE C8                     fdb       RGTSTR              ; RIGHT$
 E026 | EE CF                     fdb       MIDSTR              ; MID$
 E028 | FB 9C                     fdb       POINT
 E02A | FC 11                     fdb       VARPTR
 E02C | FB ED                     fdb       INKEY               ; INKEY$
 E02E | EC DB                     fdb       FRMEM               ; MEM
      | 
      |                 *
      |                 * Operator Precedence and Dispatch table.
      |                 *
      |                 * Unary operators are not contained in this table and are treated as
      |                 * special cases by the expression evaluation routine. The precedence
      |                 * values for the unary operators are:
      |                 *        Unary negation:  $7D
      |                 *             Unary NOT:  $5A
      |                 *
      |                 * The relational operators use a separate table at $E988
      |                 *
 E030 | 79              OPTABL    fcb       $79
 E031 | EF 80                     fdb       FPADD               ; +
 E033 | 79                        fcb       $79
 E034 | EF 75                     fdb       FPSUB               ; -
 E036 | 7B                        fcb       $7B
 E037 | F0 F1                     fdb       FPMULT              ; *
 E039 | 7B                        fcb       $7B
 E03A | F1 C8                     fdb       FPDIV               ; /
 E03C | 7F                        fcb       $7F
 E03D | F5 56                     fdb       FPPOWR              ; ^
 E03F | 50                        fcb       $50
 E040 | EA 8E                     fdb       BITAND              ; AND
 E042 | 46                        fcb       $46
 E043 | EA 8D                     fdb       BITOR               ; OR
      | 
      |                 * Keyword Dictionary
 E045 | 46 4F D2        DICNRY    fcs       'FOR'               ; $80
 E048 | 47 4F 54 CF               fcs       'GOTO'              ; $81
 E04C | 47 4F 53 55 C2            fcs       'GOSUB'             ; $82
 E051 | 52 45 CD                  fcs       'REM'               ; $83
 E054 | 49 C6                     fcs       'IF'                ; $84
 E056 | 44 41 54 C1               fcs       'DATA'              ; $85
 E05A | 50 52 49 4E D4            fcs       'PRINT'             ; $86
 E05F | 4F CE                     fcs       'ON'                ; $87
 E061 | 49 4E 50 55 D4            fcs       'INPUT'             ; $88
 E066 | 45 4E C4                  fcs       'END'               ; $89
 E069 | 4E 45 58 D4               fcs       'NEXT'              ; $8A
 E06D | 44 49 CD                  fcs       'DIM'               ; $8B
 E070 | 52 45 41 C4               fcs       'READ'              ; $8C
 E074 | 4C 45 D4                  fcs       'LET'               ; $8D
 E077 | 52 55 CE                  fcs       'RUN'               ; $8E
 E07A | 52 45 53 54 4F            fcs       'RESTORE'           ; $8F
 E07F | 52 C5 
 E081 | 52 45 54 55 52            fcs       'RETURN'            ; $90
 E086 | CE 
 E087 | 53 54 4F D0               fcs       'STOP'              ; $91
 E08B | 50 4F 4B C5               fcs       'POKE'              ; $92
 E08F | 43 4F 4E D4               fcs       'CONT'              ; $93
 E093 | 4C 49 53 D4               fcs       'LIST'              ; $94
 E097 | 43 4C 45 41 D2            fcs       'CLEAR'             ; $95
 E09C | 4E 45 D7                  fcs       'NEW'               ; $96
 E09F | 43 4C 4F 41 C4            fcs       'CLOAD'             ; $97
 E0A4 | 43 53 41 56 C5            fcs       'CSAVE'             ; $98
 E0A9 | 4C 4C 49 53 D4            fcs       'LLIST'             ; $99
 E0AE | 4C 50 52 49 4E            fcs       'LPRINT'            ; $9A
 E0B3 | D4 
 E0B4 | 53 45 D4                  fcs       'SET'               ; $9B
 E0B7 | 52 45 53 45 D4            fcs       'RESET'             ; $9C
 E0BC | 43 4C D3                  fcs       'CLS'               ; $9D
 E0BF | 53 4F 55 4E C4            fcs       'SOUND'             ; $9E
 E0C4 | 45 58 45 C3               fcs       'EXEC'              ; $9F
 E0C8 | 53 4B 49 50 C6            fcs       'SKIPF'             ; $A0
 E0CD | 54 41 42 A8               fcs       'TAB('              ; $A1
 E0D1 | 54 CF                     fcs       'TO'                ; $A2
 E0D3 | 54 48 45 CE               fcs       'THEN'              ; $A3
 E0D7 | 4E 4F D4                  fcs       'NOT'               ; $A4
 E0DA | 53 54 45 D0               fcs       'STEP'              ; $A5
 E0DE | 4F 46 C6                  fcs       'OFF'               ; $A6
 E0E1 | AB                        fcb       '+'+$80             ; $A7
 E0E2 | AD                        fcb       '-'+$80             ; $A8
 E0E3 | AA                        fcb       '*'+$80             ; $A9
 E0E4 | AF                        fcb       '/'+$80             ; $AA
 E0E5 | DE                        fcb       '^'+$80             ; $AB
 E0E6 | 41 4E C4                  fcs       'AND'               ; $AC
 E0E9 | 4F D2                     fcs       'OR'                ; $AD
 E0EB | BE                        fcb       '>'+$80             ; $AE
 E0EC | BD                        fcb       '='+$80             ; $AF
 E0ED | BC                        fcb       '<'+$80             ; $B0
 E0EE | 53 47 CE                  fcs       'SGN'               ; $B1
 E0F1 | 49 4E D4                  fcs       'INT'               ; $B2
 E0F4 | 41 42 D3                  fcs       'ABS'               ; $B3
 E0F7 | 55 53 D2                  fcs       'USR'               ; $B4
 E0FA | 52 4E C4                  fcs       'RND'               ; $B5
 E0FD | 53 51 D2                  fcs       'SQR'               ; $B6
 E100 | 4C 4F C7                  fcs       'LOG'               ; $B7
 E103 | 45 58 D0                  fcs       'EXP'               ; $B8
 E106 | 53 49 CE                  fcs       'SIN'               ; $B9
 E109 | 43 4F D3                  fcs       'COS'               ; $BA
 E10C | 54 41 CE                  fcs       'TAN'               ; $BB
 E10F | 50 45 45 CB               fcs       'PEEK'              ; $BC
 E113 | 4C 45 CE                  fcs       'LEN'               ; $BD
 E116 | 53 54 52 A4               fcs       'STR$'              ; $BE
 E11A | 56 41 CC                  fcs       'VAL'               ; $BF
 E11D | 41 53 C3                  fcs       'ASC'               ; $C0
 E120 | 43 48 52 A4               fcs       'CHR$'              ; $C1
 E124 | 4C 45 46 54 A4            fcs       'LEFT$'             ; $C2
 E129 | 52 49 47 48 54            fcs       'RIGHT$'            ; $C3
 E12E | A4 
 E12F | 4D 49 44 A4               fcs       'MID$'              ; $C4
 E133 | 50 4F 49 4E D4            fcs       'POINT'             ; $C5
 E138 | 56 41 52 50 54            fcs       'VARPTR'            ; $C6
 E13D | D2 
 E13E | 49 4E 4B 45 59            fcs       'INKEY$'            ; $C7
 E143 | A4 
 E144 | 4D 45 CD                  fcs       'MEM'               ; $C8
 E147 | 00                        fcb       $00
      | 
      |                 * Command Dispatch Table
 E148 | E4 C4           CMDTBL    fdb       FOR
 E14A | E6 1A                     fdb       GOTO
 E14C | E6 04                     fdb       GOSUB
 E14E | E6 85                     fdb       REM
 E150 | E6 72                     fdb       IFSTMT              ; IF
 E152 | E6 51                     fdb       DATAST              ; DATA
 E154 | E7 1F                     fdb       PRINT
 E156 | E6 92                     fdb       ONSTMT              ; ON
 E158 | E7 DE                     fdb       INPUT
 E15A | E5 7F                     fdb       ENDPRG              ; END
 E15C | E8 BB                     fdb       NEXT
 E15E | EB 12                     fdb       DIM
 E160 | E8 0E                     fdb       READ
 E162 | E6 D3                     fdb       LET
 E164 | E5 FA                     fdb       RUN
 E166 | E5 60                     fdb       RSTORE              ; RESTORE
 E168 | E6 31                     fdb       RETURN
 E16A | E5 7E                     fdb       STOPRG              ; STOP
 E16C | EF 66                     fdb       POKE
 E16E | E5 A6                     fdb       CONT
 E170 | E4 0D                     fdb       LIST
 E172 | E5 B8                     fdb       CLEAR
 E174 | E3 CD                     fdb       NEW
 E176 | FD 5C                     fdb       CLOAD
 E178 | FC 3B                     fdb       CSAVE
 E17A | E4 0B                     fdb       LLIST
 E17C | E7 1C                     fdb       LPRINT
 E17E | FB 25                     fdb       SETST               ; SET
 E180 | FB 55                     fdb       RESET
 E182 | FB BF                     fdb       CLS
 E184 | FF A5                     fdb       SOUND
 E186 | FC 04                     fdb       EXECST              ; EXEC
 E188 | FE 2F                     fdb       SKIPF
      | 
      |                 * Error Message Table
 E18A | 4E 46           ERRTBL    fcc       'NF'                ; ($00) NEXT without FOR
 E18C | 53 4E                     fcc       'SN'                ; ($02) Syntax Error
 E18E | 52 47                     fcc       'RG'                ; ($04) RETURN without GOSUB
 E190 | 4F 44                     fcc       'OD'                ; ($06) Out of DATA
 E192 | 46 43                     fcc       'FC'                ; ($08) Illegal Function Call
 E194 | 4F 56                     fcc       'OV'                ; ($0A) Overflow
 E196 | 4F 4D                     fcc       'OM'                ; ($0C) Out of Memory
 E198 | 55 4C                     fcc       'UL'                ; ($0E) Undefined Line
 E19A | 42 53                     fcc       'BS'                ; ($10) Bad Subscript
 E19C | 44 44                     fcc       'DD'                ; ($12) Double Dimensioned Array
 E19E | 2F 30                     fcc       '/0'                ; ($14) Division by 0
 E1A0 | 49 44                     fcc       'ID'                ; ($16) Input Direct
 E1A2 | 54 4D                     fcc       'TM'                ; ($18) Type Mismatch
 E1A4 | 4F 53                     fcc       'OS'                ; ($1A) Out of String Space
 E1A6 | 4C 53                     fcc       'LS'                ; ($1C) String too Long
 E1A8 | 53 54                     fcc       'ST'                ; ($1E) String Formula too Complex
 E1AA | 43 4E                     fcc       'CN'                ; ($20) Can't Continue
 E1AC | 49 4F                     fcc       'IO'                ; ($22) Input/Output Error
 E1AE | 46 4D                     fcc       'FM'                ; ($24) File Mode Error
      | 
      |                 * Notification and Prompt strings
 E1B0 | 20 45 52 52 4F  ERRMSG    fcc       ' ERROR'
 E1B5 | 52 
 E1B6 | 00                        fcb       $00
      | 
 E1B7 | 20 49 4E 20     IN_MSG    fcc       ' IN '
 E1BB | 00                        fcb       $00
      | 
 E1BC | 0D                        fcb       CR
 E1BD | 4F 4B           PROMPT    fcc       'OK'
 E1BF | 0D 00                     fcb       CR,$00
      | 
 E1C1 | 0D              BRKMSG    fcb       CR
 E1C2 | 42 52 45 41 4B            fcc       'BREAK'
 E1C7 | 00                        fcb       $00
      | 
      |                 * Back-end of the parser routine. Enters with the parsed character/token in ACCA.
      |                 * Returns with CC.Z=1 for ':' or end-of-line and CC.C=1 for a numeric character.
 E1C8 | 81 3A           BPARSE    cmpa      #':                 ; set Z flag if statement separator
 E1CA | 24 0B                     bcc       LE1D7               ; return if >= ':'
 E1CC | 81 20                     cmpa      #SPACE              ; is it a space character?
 E1CE | 26 03                     bne       LE1D3               ; branch if not a space
 E1D0 | 7E 00 EB                  jmp       CHRGET              ; ignore space and parse next character
 E1D3 | 80 30           LE1D3     suba      #'0                 ; subtract ASCII '0'
 E1D5 | 80 D0                     suba      #($100-'0')         ; restore byte (set carry if numeric)
 E1D7 | 39              LE1D7     rts                           ; return
      | 
      |                 *
      |                 * Scan the stack for a FOR-NEXT frame or a GOSUB-RETURN frame.
      |                 * VARDES points to the FOR-NEXT control variable being sought.
      |                 *
      |                 * GOSUB-RETURN frame:
      |                 *      0: $82  (GOSUB token)
      |                 *    1-2: line number of GOSUB statement
      |                 *    3-4: pointer to program code following GOSUB token
      |                 *
      |                 * FOR-NEXT frame:
      |                 *      0: $80  (FOR token)
      |                 *    1-2: pointer to the control variable
      |                 *    3-7: step value (unpacked FP)
      |                 *      8: sign of step (-1, 0 or +1)
      |                 *   9-13: final value (packed FP)
      |                 *  14-15: line number of FOR statement
      |                 *  16-17: pointer to program code following FOR statement

TRANSLATED
      | 
 E1D8 | 30              LE1D8     tsx                           ; point X to top of stack
 E1D9 | C6 04                     ldab      #4                  ; advance past the two return addresses..
 E1DB | 3A                        abx                           ; ..that are on top of the stack
 E1DC | C6 12           LE1DC     ldab      #18                 ; B = size of a FOR-NEXT stack frame
 E1DE | DF 89                     stx       TMPTR1              ; save frame ptr in temp storage
 E1E0 | A6 00                     ldaa      ,X                  ; get token associated with the stack frame
 E1E2 | 80 80                     suba      #$80                ; subtract FOR value
 E1E4 | 26 14                     bne       LE1FA               ; branch if not a FOR-NEXT frame
 E1E6 | EE 01                     ldx       1,X                 ; point X to the corresponding control variable
 E1E8 | DF 8B                     stx       TMPTR2              ; save ptr in temp storage
 E1EA | DE B5                     ldx       VARDES              ; point X to descriptor of NEXT variable
 E1EC | 27 08                     beq       LE1F6               ; branch if no variable specified
 E1EE | 9C 8B                     cpx       TMPTR2              ; is this the one we want?
 E1F0 | 27 08                     beq       LE1FA               ; branch if target frame found
 E1F2 | 8D 3B                     bsr       LE22F               ; advance to next stack frame (X = TMPTR1 + ACCD)
 E1F4 | 20 E6                     bra       LE1DC               ; keep searching
 E1F6 | DE 8B           LE1F6     ldx       TMPTR2              ; set VARDES to point to the..
 E1F8 | DF B5                     stx       VARDES              ; ..frame's control variable
 E1FA | DE 89           LE1FA     ldx       TMPTR1              ; return with X pointing to stack frame
 E1FC | 4D                        tsta                          ; set CC.Z flag if FOR-NEXT frame
 E1FD | 39                        rts
      | 
      |                 *
      |                 * Move a block of memory upwards to a higher address within the current free space.
      |                 * Enter with pointer to start of source block in SRCPTR and end of source block in SRCEND.
      |                 * Enter with pointer to end of destination block in DSTEND and ACCD.
      |                 * Exits with pointer to source block in X and pointer to destination block in DSTPTR.

 TRANSLATED 

 E1FE | 8D 1E           LE1FE     bsr       LE21E               ; issue an ?OM ERROR if not within free space
 E200 | 07              LE200     tpa                           ; copy CC to ACCA
 E201 | 36                        psha                          ; save IRQ mask on stack
 E202 | 9F 91                     sts       STKSAV              ; temporary storage of stack ptr
 E204 | 0F                        sei                           ; mask IRQs
 E205 | 9E BB                     lds       DSTEND              ; point S to end of destination block
 E207 | DE BD                     ldx       SRCEND              ; point X to end of source block
 E209 | 08                        inx                           ; adjust X for pre-decrementing
 E20A | 09              LE20A     dex                           ; pre-decrement X
 E20B | A6 00                     ldaa      ,X                  ; get byte from source
 E20D | 36                        psha                          ; store byte in destination
 E20E | 9C C1                     cpx       SRCPTR              ; reached final source address?
 E210 | 26 F8                     bne       LE20A               ; loop if more to do
 E212 | 31                        ins                           ; point S to final destination address
 E213 | 9F BF                     sts       DSTPTR              ; save final destination address
 E215 | 9E 91                     lds       STKSAV              ; restore stack pointer
 E217 | 32                        pula                          ; pull saved CC from stack
 E218 | 06                        tap                           ; restore CC (IRQ mask)
 E219 | 39                        rts                           ; return
      | 
      |                 *
      |                 * Determine if there is enough free memory to allocate 2 * ACCB bytes
 E21A | 4F              LE21A     clra                          ; unsigned extension of ACCB to ACCD
 E21B | 58                        aslb                          ; multiply by 2 (ACCB must be less than 128)
 E21C | D3 99                     addd      ARYEND              ; add to start address of free memory
      | 
      |                 * Determine if the address specified in ACCD is currently within the free memory space.
      |                 * It is assumed that ACCD is greater than ARYEND.
      |                 * Returns with ACCD+STKBUF in ACCD if good otherwise issues an ?OM ERROR.
 E21E | C3 00 3A        LE21E     addd      #STKBUF             ; add stack cushion size to address
 E221 | 25 13                     bcs       LE236               ; ?OM ERROR if > $FFFF
 E223 | 9F 91                     sts       STKSAV              ; check to see if address will collide..
 E225 | 93 91                     subd      STKSAV              ; ..with the space reserved for the stack
 E227 | 24 0D                     bcc       LE236               ; ?OM ERROR if stack collision
 E229 | D3 91                     addd      STKSAV              ; return with address + STKBUF in ACCD
 E22B | 39                        rts
      | 
      |                 *
      |                 * Add unsigned 8 bit value in ACCB to the pointer contained in X.
      |                 * Return with old ptr in TMPTR1 and new pointer in X, ACCD and TMPTR2.
 E22C | 4F              LE22C     clra                          ; promote unsigned ACCB to ACCD
      | 
      |                 * Add 16 bit value in ACCD to the pointer contained in X.
      |                 * Return with old ptr in TMPTR1 and new pointer in X, ACCD and TMPTR2.
 E22D | DF 89           LE22D     stx       TMPTR1              ; store old pointer in TMPTR1
      | 
      |                 * Add 16 bit value in ACCD to the pointer stored at TMPTR1.
      |                 * Return with old ptr in TMPTR1 and new pointer in X, ACCD and TMPTR2.
 E22F | D3 89           LE22F     addd      TMPTR1              ; ACCD = new pointer
 E231 | DD 8B                     std       TMPTR2              ; store new pointer in TMPTR2
 E233 | DE 8B                     ldx       TMPTR2              ; return with new pointer in X
 E235 | 39                        rts
      | 
      |                 *
      |                 * Issue an ?OM ERROR
 E236 | C6 0C           LE236     ldab      #OM_ERR             ; error number
      | 
      |                 * Issue an Error.  Enter with error number in ACCB.
 E238 | BD 42 97        ERRGEN    jsr       RVEC7               ; call extension hook for ON ERR GOTO 
 E23B | BD 42 9A                  jsr       RVEC8               ; call error message extension hook
 E23E | BD FC 86                  jsr       LFC86               ; set serial port output to MARK
 E241 | B6 42 6E                  ldaa      CLDFLG              ; did error occur during CLOAD?
 E244 | 27 03                     beq       LE249               ; branch if not a CLOAD error
 E246 | BD E3 CF                  jsr       LE3CF               ; do a 'NEW'
 E249 | BD E3 EE        LE249     jsr       LE3EE               ; reset the stack and disable 'CONT'
 E24C | 7F 00 E8                  clr       DEVNUM              ; set screen/keyboard as current I/O device
 E24F | BD E7 6A                  jsr       LE76A               ; output a Carriage Return to the screen if needed
 E252 | BD E7 BC                  jsr       LE7BC               ; output a '?' character
 E255 | CE E1 8A                  ldx       #ERRTBL             ; point X to the error messages table
 E258 | 3A                        abx                           ; offset X by the error number (multiple of 2)
 E259 | A6 00                     ldaa      ,X                  ; get first character of error message..
 E25B | BD E7 BE                  jsr       LE7BE               ; ..and output to screen
 E25E | A6 01                     ldaa      1,X                 ; get second character of error message..
 E260 | BD E7 BE                  jsr       LE7BE               ; ..and  output to screen
 E263 | CE E1 AF                  ldx       #ERRMSG-1           ; point X to 'ERROR' string -1
 E266 | BD E7 A8        LE266     jsr       STROUT              ; output string to screen
 E269 | DE E2                     ldx       CURLIN              ; check the current line number..
 E26B | 08                        inx                           ; ..to see if a program is running..
 E26C | 27 03                     beq       LE271               ; ..and branch if in Direct mode
 E26E | BD F4 12                  jsr       LF412               ; output 'IN line#' to screen
      | 
      |                 * Output a Carriage Return (if needed) and display the OK prompt
 E271 | BD E7 6A        LE271     jsr       LE76A               ; output a Carriage Return if needed
 E274 | CE E1 BC                  ldx       #PROMPT-1           ; point X to "OK" prompt string (-1)
 E277 | BD E7 A8                  jsr       STROUT              ; output string to screen
      | 
      |                 * Initiate Immediate Mode
 E27A | CE FF FF        LE27A     ldx       #-1                 ; set current line number..
 E27D | DF E2                     stx       CURLIN              ; ..to -1 while in Immediate mode
 E27F | BD FA A4                  jsr       LFAA4               ; read a line from the Console
 E282 | 25 F6                     bcs       LE27A               ; start again if BREAK key pressed
 E284 | DF F4                     stx       CHRPTR              ; set parser position to line input buffer
 E286 | BD 00 EB                  jsr       >CHRGET             ; parse first character/token
 E289 | 27 EF                     beq       LE27A               ; start again if empty line
 E28B | 25 06                     bcs       LE293               ; branch if numeric character (line number)
 E28D | BD E3 11                  jsr       CRUNCH              ; crunch the command line
 E290 | 7E E5 3D                  jmp       LE53D               ; execute command(s) immediately
      | 
      |                 * Entry (or deletion) of a program line
 E293 | BD E6 B2        LE293     jsr       LE6B2               ; parse line number into BINVAL
 E296 | DE A5                     ldx       BINVAL              ; get line number
 E298 | FF 42 B0                  stx       LINUMB              ; store line number for program insertion 
>E29B | BD E3 11                  jsr       CRUNCH              ; crunch the program line
 E29E | D7 82                     stab      TMPLOC              ; save line size for insertion (includes line number and link)
 E2A0 | BD E3 B9                  jsr       LE3B9               ; get pointer to existing line or insertion location
 E2A3 | 25 1C                     bcs       LE2C1               ; branch if line doesn't already exist
      | 
      |                 * Delete old program line. Move all subsequent lines down.
 E2A5 | DC C1                     ldd       SRCPTR              ; ACCD = address of existing line
 E2A7 | A3 00                     subd      ,X                  ; subtract address of next line (ACCD = negative line size)
 E2A9 | D3 95                     addd      VARTAB              ; subtract line length from end-of-program
 E2AB | DD 95                     std       VARTAB              ; set new end-of-program
 E2AD | 07                        tpa                           ; copy IRQ mask to ACCA
 E2AE | 36                        psha                          ; save IRQ mask on stack
 E2AF | 9F 91                     sts       STKSAV              ; temporary storage of stack pointer
 E2B1 | 0F                        sei                           ; mask IRQs
 E2B2 | AE 00                     lds       ,X                  ; point S to next program line
 E2B4 | 34                        des                           ; compensate for pre-incrementing stack pulls
 E2B5 | 32              LE2B5     pula                          ; get one byte to be moved
 E2B6 | A7 00                     staa      ,X                  ; move it to new location
 E2B8 | 08                        inx                           ; bump destination ptr
 E2B9 | 9C 95                     cpx       VARTAB              ; have all bytes been moved?
 E2BB | 26 F8                     bne       LE2B5               ; loop if more to do
 E2BD | 9E 91                     lds       STKSAV              ; restore stack pointer
 E2BF | 32                        pula                          ; pull saved IRQ mask
 E2C0 | 06                        tap                           ; restore IRQ mask
      | 
      |                 * Insert program line. Move all subsequent lines up to make room.
 E2C1 | B6 42 B2        LE2C1     ldaa      LINBUF              ; was anything crunched?
 E2C4 | 27 25                     beq       LE2EB               ; branch if nothing to insert
 E2C6 | DC 95                     ldd       VARTAB              ; get current end-of-program
 E2C8 | DD BD                     std       SRCEND              ; set source end address for Upward Block Move
 E2CA | DB 82                     addb      TMPLOC              ; add total size needed..
 E2CC | 89 00                     adca      #0                  ; ..for line insertion
 E2CE | DD BB                     std       DSTEND              ; set destination end address for Upward Block Move
 E2D0 | BD E1 FE                  jsr       LE1FE               ; move subsequent lines up to make room
 E2D3 | 07                        tpa                           ; copy IRQ mask to ACCA
 E2D4 | 36                        psha                          ; save IRQ mask on stack
 E2D5 | 9F 91                     sts       STKSAV              ; temporary storage of stack pointer
 E2D7 | 0F                        sei                           ; mask IRQs
 E2D8 | 8E 42 AD                  lds       #LNKLSB-2           ; point S to temporary (non-zero) line link
 E2DB | 32              LE2DB     pula                          ; get one byte to insert
>E2DC | A7 00                     staa      ,X                  ; insert byte into program
 E2DE | 08                        inx                           ; bump insertion pointer
 E2DF | 9C BF                     cpx       DSTPTR              ; have all bytes been inserted?
 E2E1 | 26 F8                     bne       LE2DB               ; loop if more to do
      | 
 E2E3 | 9E 91                     lds       STKSAV              ; restore stack pointer
 E2E5 | 32                        pula                          ; pull saved IRQ mask
 E2E6 | 06                        tap                           ; restore IRQ mask
 E2E7 | DE BB                     ldx       DSTEND              ; get new end-of-program
 E2E9 | DF 95                     stx       VARTAB              ; set new end-of-program
 E2EB | BD E3 D9        LE2EB     jsr       LE3D9               ; erase all variables
 E2EE | 8D 03                     bsr       LE2F3               ; rebuild program line links
 E2F0 | 7E E2 7A                  jmp       LE27A               ; get next command line
      | 
      |                 * Rebuild all program line links
 E2F3 | DE 93           LE2F3     ldx       TXTTAB              ; point X to first line
 E2F5 | EC 00           LE2F5     ldd       ,X                  ; test link to next line
 E2F7 | 26 01                     bne       LE2FA               ; branch if not the last line
 E2F9 | 39                        rts                           ; return
      | 
 E2FA | 3C              LE2FA     pshx                          ; save pointer to the link
 E2FB | C6 04                     ldab      #4                  ; point X to the first..
 E2FD | 3A                        abx                           ; ..character/token of the line
 E2FE | 08              LE2FE     inx                           ; advance to next character/token
 E2FF | A6 00                     ldaa      ,X                  ; get next character/token
 E301 | 26 FB                     bne       LE2FE               ; loop if not the end of the line
 E303 | 08                        inx                           ; point X to next link
 E304 | 3C                        pshx                          ; push pointer to next link
 E305 | 30                        tsx                           ; point X to link addresses on the stack
 E306 | EC 00                     ldd       ,X                  ; ACCD = address of next link
 E308 | EE 02                     ldx       2,X                 ; point X to current link
 E30A | ED 00                     std       ,X                  ; set current link to point to the next link
 E30C | 38                        pulx                          ; pull address of next link into X
 E30D | 31                        ins                           ; pop address of..
 E30E | 31                        ins                           ; ..the current link
 E30F | 20 E4                     bra       LE2F5               ; go update the next link
      | 
      | 
      |                 *
      |                 * CRUNCH
      |                 *
      |                 * Convert raw characters into tokenized Basic code.
      |                 * Enter with CHRPTR pointing to first character of raw input.
      |                 * Tokenized output is stored in LINBUF.
      |                 *
 E311 | 7F 00 85        CRUNCH    clr       TMPFLG              ; clear DATA statement flag
 E314 | DE F4                     ldx       CHRPTR              ; get input position and
 E316 | 09                        dex                           ; ..decrement by one to compensate..
 E317 | DF F4                     stx       CHRPTR              ; ..for pre-incrementing stack pulls
 E319 | CE 42 B1                  ldx       #LINBUF-1           ; point X to output buffer -1
 E31C | DF DE                     stx       OUTPTR              ; store output pointer
 E31E | 9F 91                     sts       STKSAV              ; temporary storage of stack pointer
 E320 | 07                        tpa                           ; copy IRQ mask to ACCA
 E321 | 97 87                     staa      INPFLG              ; save IRQ mask in INPFLG
 E323 | 01              LE323     nop                           ; no obvious reason for this
 E324 | 0F                        sei                           ; mask IRQs
 E325 | 9E F4                     lds       CHRPTR              ; use stack pointer for reading raw input
 E327 | 33                        pulb                          ; get raw input character
 E328 | C1 20                     cmpb      #SPACE              ; is it a space?
 E32A | 27 38                     beq       LE364               ; branch if a space
 E32C | D7 81                     stab      ENDCHR              ; save as ending char for raw-copy sequence
 E32E | C1 22                     cmpb      #'"                 ; is it a string delimiter?
 E330 | 27 5B                     beq       LE38D               ; branch if starting a string literal
 E332 | 96 85                     ldaa      TMPFLG              ; are we inside a DATA statement?
 E334 | 26 2E                     bne       LE364               ; branch if this is DATA data
 E336 | C1 3F                     cmpb      #'?                 ; is it the shorthand for PRINT?
 E338 | 26 04                     bne       LE33E               ; branch if not a '?'
 E33A | C6 86                     ldab      #$86                ; token for PRINT
 E33C | 20 26                     bra       LE364               ; go add PRINT token to output
      | 
 E33E | C1 30           LE33E     cmpb      #'0                 ; if character is less than..
 E340 | 25 04                     blo       LE346               ; ..ASCII digit then branch
 E342 | C1 3C                     cmpb      #'<                 ; if character is a digit, ':' or ';' ..
 E344 | 25 1E                     blo       LE364               ; ..then branch
 E346 | 5D              LE346     tstb                          ; if character code is greater than..
 E347 | 2B 19                     bmi       LE362               ; ..largest ASCII code then branch
 E349 | CE E0 44                  ldx       #DICNRY-1           ; point X to keyword dictionary -1
 E34C | 9E F4                     lds       CHRPTR              ; point S to input character -1
 E34E | 5F                        clrb                          ; initialize token index
 E34F | 08              LE34F     inx                           ; pre-increment dictionary pointer
 E350 | 32              LE350     pula                          ; get raw input character
 E351 | 81 20                     cmpa      #SPACE              ; is it a space?
 E353 | 27 FB                     beq       LE350               ; ignore spaces in keywords
 E355 | A0 00                     suba      ,X                  ; compare with dictionary character
 E357 | 27 F6                     beq       LE34F               ; continue comparing if chars match
 E359 | 81 80                     cmpa      #$80                ; could be keyword terminator (bit 7 set)
 E35B | 26 35                     bne       LE392               ; branch if not a match
 E35D | CA 80                     orab      #$80                ; keyword match, finalize token value
 E35F | DE DE           LE35F     ldx       OUTPTR              ; get output pointer
 E361 | 8C                        fcb       SKP2                ; skip next instruction
 E362 | C6 21           LE362     ldab      #'!                 ; exclamation point for non-printing chars
 E364 | 9F F4           LE364     sts       CHRPTR              ; store input pointer
 E366 | 9E 91                     lds       STKSAV              ; restore stack
 E368 | 96 87                     ldaa      INPFLG              ; get saved IRQ mask
 E36A | 06                        tap                           ; restore saved IRQ mask
 E36B | 08                        inx                           ; pre-increment the output pointer
 E36C | DF DE                     stx       OUTPTR              ; store output pointer
 E36E | E7 00                     stab      ,X                  ; add character/token to output
 E370 | 27 38                     beq       LE3AA               ; branch if end-of-line
 E372 | C0 3A                     subb      #':                 ; is it a statement separator?
 E374 | 27 04                     beq       LE37A               ; branch if separator
 E376 | C1 4B                     cmpb      #$85-':             ; is it the token for DATA (less ':')?
 E378 | 26 02                     bne       LE37C               ; branch if not DATA
 E37A | D7 85           LE37A     stab      TMPFLG              ; clear DATA statement flag if ':', set if 'DATA'
 E37C | C0 49           LE37C     subb      #$83-':             ; is it the token for REM (less ':')
 E37E | 26 A3                     bne       LE323               ; loop if not REM
      | 
 E380 | D7 81                     stab      ENDCHR              ; clear ENDCHR to copy remainder of line
 E382 | 0F                        sei                           ; mask IRQs
 E383 | 9E F4                     lds       CHRPTR              ; use stack pointer for input parser
      | 
      |                 * Copy raw input characters to the output until end-of-line or the value of ENDCHR is encountered
 E385 | 33              LE385     pulb                          ; get raw input character
 E386 | 5D                        tstb                          ; is it a null terminator?
 E387 | 27 DB                     beq       LE364               ; exit if end-of-line
 E389 | D1 81                     cmpb      ENDCHR              ; end of the raw-copy sequence?
 E38B | 27 D7                     beq       LE364               ; exit if end of sequence (string literal)
 E38D | 08              LE38D     inx                           ; bump output pointer
 E38E | E7 00                     stab      ,X                  ; add raw character to output
 E390 | 20 F3                     bra       LE385               ; continue
      | 
      |                 * Keyword comparison failed. Advance dictionary pointer to next keyword and start again
 E392 | 9E F4           LE392     lds       CHRPTR              ; backup the raw input pointer 
 E394 | 5C                        incb                          ; bump token index
 E395 | A6 00           LE395     ldaa      ,X                  ; get dictionary character
 E397 | 08                        inx                           ; bump dictionary pointer
 E398 | 2A FB                     bpl       LE395               ; keep scanning until end of dictionary keyword
 E39A | A6 00                     ldaa      ,X                  ; end of dictionary?
 E39C | 26 B2                     bne       LE350               ; compare again if more dictionary entries
      | 
      |                 * There is no dictionary match for the current input character(s)
 E39E | 9F F4                     sts       CHRPTR              ; store input pointer
 E3A0 | 9E 91                     lds       STKSAV              ; restore stack pointer
 E3A2 | BD 42 A3                  jsr       RVEC11              ; call extension hook for custom keywords
 E3A5 | 9E F4                     lds       CHRPTR              ; get raw input pointer
 E3A7 | 33                        pulb                          ; copy raw character..
 E3A8 | 20 B5                     bra       LE35F               ; ..to output as-is
      | 
      |                 * End of raw input.  Add line terminators and prepare for possible execution.
 E3AA | E7 01           LE3AA     stab      1,X                 ; add two null terminators..
 E3AC | E7 02                     stab      2,X                 ; ..to the output
 E3AE | DC DE                     ldd       OUTPTR              ; ACCD = address of final output character/token
 E3B0 | 83 42 AD                  subd      #LINBUF-5           ; ACCD = total size for program insertion
 E3B3 | CE 42 B1                  ldx       #LINBUF-1           ; point X to crunched output -1
 E3B6 | DF F4                     stx       CHRPTR              ; set parser position to execute
 E3B8 | 39                        rts                           ; return
      | 
      |                 *
      |                 * Search program from beginning for the line whose line number is contained in BINVAL
 E3B9 | DE 93           LE3B9     ldx       TXTTAB
      | 
      |                 * Search program starting from X for the line whose line number is contained in BINVAL.
      |                 * Returns with X and SRCPTR pointing to existing line or insertion location.
      |                 * Returns with Carry set if line does not exist.
 E3BB | EC 00           LE3BB     ldd       ,X                  ; check link to the next line
 E3BD | 27 0A                     beq       LE3C9               ; return with carry set if end of program
 E3BF | DC A5                     ldd       BINVAL              ; D = target line number
 E3C1 | A3 02                     subd      2,X                 ; subtract line number being looked at
 E3C3 | 23 05                     bls       LE3CA               ; branch if found (carry clear) or surpassed (carry set)
 E3C5 | EE 00                     ldx       ,X                  ; point X to next line
 E3C7 | 20 F2                     bra       LE3BB               ; keep searching
 E3C9 | 0D              LE3C9     sec                           ; set carry to indicate 'Not Found'
 E3CA | DF C1           LE3CA     stx       SRCPTR              ; save address of last line checked
 E3CC | 39                        rts                           ; return
      | 
      |                 ***
      |                 *** NEW
      |                 ***
 E3CD | 26 FB           NEW       bne       LE3CA               ; return if any parameters follow the keyword
 E3CF | DE 93           LE3CF     ldx       TXTTAB              ; point X to start of program storage
 E3D1 | 6F 00                     clr       ,X                  ; clear both bytes of..
 E3D3 | 08                        inx                           ; ..the 'next line' link..
 E3D4 | 6F 00                     clr       ,X                  ; ..to indicate end-of-program
 E3D6 | 08                        inx                           ; increment X past the last program byte
 E3D7 | DF 95                     stx       VARTAB              ; set Program End/Variables Start location 
      | 
      |                 * Erase all variables and set parser position to beginning of program
 E3D9 | DE 93           LE3D9     ldx       TXTTAB              ; point X to start of program storage
 E3DB | 09                        dex                           ; subtract one (point to fake line terminator)
 E3DC | DF F4                     stx       CHRPTR              ; set parser position to beginning of program
      | 
      |                 * Erase all variables, initialize pointers and reset the stack.
 E3DE | BD 42 8E        LE3DE     jsr       RVEC4               ; call extension hook
 E3E1 | DE A1                     ldx       MEMSIZ              ; get top of RAM available to Basic
 E3E3 | DF 9D                     stx       STRTAB              ; reset string space allocator
 E3E5 | BD E5 60                  jsr       RSTORE              ; reset position for READ statements
 E3E8 | DE 95                     ldx       VARTAB              ; point X to end of Basic program code
 E3EA | DF 97                     stx       ARYTAB              ; set start of array table (erase simple variables)
 E3EC | DF 99                     stx       ARYEND              ; set end of array table (erase array variables)
 E3EE | CE 42 41        LE3EE     ldx       #STRSTK             ; point X to start of string descriptor stack
 E3F1 | FF 42 3D                  stx       SDSPTR              ; reset string stack pointer
 E3F4 | 38                        pulx                          ; pull return address into X
 E3F5 | 9E 9B                     lds       FRETOP              ; reset stack to begin below the string space
 E3F7 | 4F                        clra                          ; store a zero byte on the stack to mark the..
 E3F8 | 36                        psha                          ; ..end of the FOR-NEXT and GOSUB-RETURN frames
 E3F9 | 97 A7                     staa      OLDPTR              ; clear the CONT location so that..
 E3FB | 97 A8                     staa      OLDPTR+1            ; ..a ?CN ERROR will occur if used
 E3FD | 97 86                     staa      ARYMOD              ; clear the Array Mode flag
 E3FF | B7 42 6E                  staa      CLDFLG              ; clear the CLOAD Error flag (disable automatic NEW)
 E402 | 6E 00                     jmp       ,X                  ; return
      | 
      |                 *
      |                 * Change the current I/O device to the serial port for printer output
 E404 | C6 FE           LE404     ldab      #-2                 ; device number for the serial port
 E406 | D7 E8                     stab      DEVNUM              ; set serial port as the current I/O device
 E408 | 7E 00 F3        LE408     jmp       CHRGOT              ; get current parse character and return
      | 
      | 
      |                 ***
      |                 *** LLIST  [startLine] [-] [endLine]
      |                 ***
 E40B | 8D F7           LLIST     bsr       LE404               ; redirect I/O to the serial port
      | 
      | 
      |                 ***
      |                 *** LIST  [startLine] [-] [endLine]
      |                 ***
 E40D | 07              LIST      tpa                           ; save the CC register..
 E40E | 36                        psha                          ; ..on the stack
 E40F | 8D F7                     bsr       LE408               ; get current parse character
 E411 | BD E6 B2                  jsr       LE6B2               ; parse line number into BINVAL (0 if not specified)
 E414 | 8D A3                     bsr       LE3B9               ; get pointer to the first line to List
 E416 | 32                        pula                          ; pull saved CC value from stack..
 E417 | 06                        tap                           ; ..and restore CC register
 E418 | 3C                        pshx                          ; save starting line address on stack
 E419 | 27 16                     beq       LE431               ; branch if no parameters were specified
 E41B | BD 00 F3                  jsr       >CHRGOT             ; get current parse character
 E41E | 27 16                     beq       LE436               ; branch if end of statement
 E420 | 81 A8                     cmpa      #$A8                ; is it a MINUS token (-) ?
 E422 | 26 0A                     bne       LE42E               ; issue an ?SN ERROR if not
 E424 | BD 00 EB                  jsr       >CHRGET             ; advance parser to next character
 E427 | 27 08                     beq       LE431               ; branch if end of statement
 E429 | BD E6 B2                  jsr       LE6B2               ; parse ending line number into BINVAL
 E42C | 27 08                     beq       LE436               ; branch if legal line number
 E42E | 7E EA 3C        LE42E     jmp       SYNERR              ; issue an ?SN ERROR
 E431 | CE FF FF        LE431     ldx       #65535              ; store default ending line number..
 E434 | DF A5                     stx       BINVAL              ; ..into BINVAL
 E436 | 38              LE436     pulx                          ; pull starting line pointer into X
 E437 | 31                        ins                           ; pop return address..
 E438 | 31                        ins                           ; ..off the stack
 E439 | BD E7 6A        LE439     jsr       LE76A               ; output a Carriage Return if needed
 E43C | BD E5 66                  jsr       LE566               ; check for BREAK or PAUSE keys
 E43F | EC 00                     ldd       ,X                  ; test link pointer to next program line
 E441 | 26 06                     bne       LE449               ; branch if not at end of program
 E443 | 7F 00 E8        LE443     clr       DEVNUM              ; redirect I/O to the screen
 E446 | 7E E2 71                  jmp       LE271               ; print OK prompt and return to direct mode
      | 
 E449 | EC 02           LE449     ldd       2,X                 ; get the current line number
 E44B | 93 A5                     subd      BINVAL              ; compare with Last Line parameter
 E44D | 22 F4                     bhi       LE443               ; branch if outside requested range
 E44F | EC 02                     ldd       2,X                 ; ACCD = current line number
 E451 | 3C                        pshx                          ; save line pointer on stack
 E452 | BD F4 19                  jsr       LF419               ; output line number as ASCII characters
 E455 | 38                        pulx                          ; restore line pointer to X
 E456 | 08                        inx                           ; advance the..
 E457 | 08                        inx                           ; ..line pointer..
 E458 | 08                        inx                           ; ..past the link pointer..
 E459 | 08                        inx                           ; ..and line number
 E45A | DF 89                     stx       TMPTR1              ; temp storage of line pointer
 E45C | 7F 42 84                  clr       UNCRFL              ; clear flags
 E45F | 86 20                     ldaa      #SPACE              ; ASCII code for a space
 E461 | 8C                        fcb       SKP2                ; skip next instruction
 E462 | 86 21           LE462     ldaa      #'!                 ; exclamation point (!)
 E464 | DE 89           LE464     ldx       TMPTR1              ; point X to next program character/token
 E466 | 84 7F                     anda      #$7F                ; mask out character's high order bit
 E468 | BD E7 BE        LE468     jsr       LE7BE               ; send character to output device
 E46B | A6 00                     ldaa      ,X                  ; load next character/token into ACCA
 E46D | 08                        inx                           ; advance the line pointer
 E46E | 4D                        tsta                          ; check for end-of-line
 E46F | 27 C8                     beq       LE439               ; branch if end-of-line
 E471 | F6 42 84                  ldab      UNCRFL              ; load flags byte
 E474 | 81 22                     cmpa      #'"                 ; check for string delimiter
 E476 | 26 05                     bne       LE47D               ; branch if not a string delimiter
 E478 | C8 01                     eorb      #$01                ; toggle the Literal String flag
 E47A | F7 42 84                  stab      UNCRFL              ; store flags byte
 E47D | 81 3A           LE47D     cmpa      #':                 ; statement separator ?
 E47F | 26 09                     bne       LE48A               ; branch if not a separator
 E481 | C5 01                     bitb      #$01                ; test Literal String flag
 E483 | 26 05                     bne       LE48A               ; branch if inside a string literal
 E485 | C4 FD                     andb      #$FD                ; clear DATA statement flag
 E487 | F7 42 84                  stab      UNCRFL              ; store flags byte
 E48A | 4D              LE48A     tsta                          ; character or keyword token?
 E48B | 2A DB                     bpl       LE468               ; branch if character
 E48D | 5D                        tstb                          ; test the flags byte and print token..
 E48E | 26 D8                     bne       LE468               ; ..as character if in a string, DATA or REM
 E490 | 81 85                     cmpa      #$85                ; DATA token ?
 E492 | 26 02                     bne       LE496               ; branch if not DATA
 E494 | CA 02                     orab      #$02                ; set the DATA statement flag
 E496 | 81 83           LE496     cmpa      #$83                ; REM token ?
 E498 | 26 02                     bne       LE49C               ; branch if not REM
 E49A | CA 04                     orab      #$04                ; set the REM statement flag
 E49C | F7 42 84        LE49C     stab      UNCRFL              ; store flags byte
 E49F | BD 42 A6                  jsr       RVEC12              ; call UNCRUNCH extension hook
 E4A2 | 81 C8                     cmpa      #$C8                ; compare with highest token value (MEM)
 E4A4 | 22 BC                     bhi       LE462               ; output exclamation point (!) for invalid tokens
      | 
      |                 * Convert token to string and send to output device
 E4A6 | 8D 0A                     bsr       LE4B2               ; get pointer to token's string in X
 E4A8 | A6 00           LE4A8     ldaa      ,X                  ; get next character from token string
 E4AA | 2B B8                     bmi       LE464               ; branch if high order bit set (final character)
 E4AC | 08                        inx                           ; increment string pointer
 E4AD | BD E7 BE                  jsr       LE7BE               ; send character to output device
 E4B0 | 20 F6                     bra       LE4A8               ; loop back for next character
      | 
      |                 * Lookup the string representation of the Basic keyword token in ACCA.  Return pointer to string in X.
      |                 * Old value of X is saved in TMPTR1.
 E4B2 | 80 7F           LE4B2     suba      #$7F                ; convert token to index
 E4B4 | DF 89                     stx       TMPTR1              ; save address of next character/token
 E4B6 | CE E0 45                  ldx       #DICNRY             ; point X to the keyword dictionary
 E4B9 | 4A              LE4B9     deca                          ; decrement token index
 E4BA | 26 01                     bne       LE4BD               ; branch if not the target token
 E4BC | 39                        rts                           ; return
      | 
      |                 * Skip over one token string in the dictionary
 E4BD | 6D 00           LE4BD     tst       ,X                  ; test token string character
 E4BF | 08                        inx                           ; advance the string pointer
 E4C0 | 2A FB                     bpl       LE4BD               ; keep scanning if not the final character
 E4C2 | 20 F5                     bra       LE4B9               ; found start of next token string
      | 
      |                 ***
      |                 *** FOR variable = first TO last [STEP n]
      |                 ***
 E4C4 | 86 80           FOR       ldaa      #$80                ; Set array mode flag to prevent an array..
 E4C6 | 97 86                     staa      ARYMOD              ; ..from being used as the control variable
 E4C8 | BD E6 D3                  jsr       LET                 ; assign starting value to control variable
 E4CB | BD E1 D8                  jsr       LE1D8               ; scan the stack for existing FOR-NEXT frame
 E4CE | 38                        pulx                          ; pop return address
 E4CF | 26 04                     bne       LE4D5               ; branch if no frame exists for the control variable
 E4D1 | DE 89                     ldx       TMPTR1              ; point X to exsiting stack frame
 E4D3 | 3A                        abx                           ; point X to the following stack frame
 E4D4 | 35                        txs                           ; pop existing frame and all frames below it
      | 
      |                 * Allocate a FOR-NEXT frame on the stack:
      |                 *      0: $80  (FOR token)
      |                 *    1-2: pointer to the control variable
      |                 *    3-7: step value (unpacked FP)
      |                 *      8: sign of step (-1, 0 or +1)
      |                 *   9-13: final value (packed FP)
      |                 *  14-15: line number of the FOR statement
      |                 *  16-17: pointer to end of FOR statement
      |                 *
 E4D5 | C6 09           LE4D5     ldab      #9                  ; check if 9 words (18 bytes) can be allocated..
 E4D7 | BD E2 1A                  jsr       LE21A               ; ..on the stack else issue an ?OM ERROR
 E4DA | BD E6 56                  jsr       LE656               ; scan to find end of the FOR statement
 E4DD | 3C                        pshx                          ; push pointer to end of the statement
 E4DE | DE E2                     ldx       CURLIN              ; get line number of FOR statement
 E4E0 | 3C                        pshx                          ; push line number onto the stack
 E4E1 | C6 A2                     ldab      #$A2                ; token for 'TO'
 E4E3 | BD EA 31                  jsr       LEA31               ; issue ?SN ERROR if next token is not 'TO'
 E4E6 | BD E9 0E                  jsr       LE90E               ; issue ?TM ERROR if control variable is a string
 E4E9 | BD E9 0C                  jsr       LE90C               ; evaluate final value expression into FPA0
 E4EC | D6 CE                     ldab      FP0SGN              ; get sign byte from final value
 E4EE | CA 7F                     orab      #$7F                ; pack the sign into..
 E4F0 | D4 CA                     andb      FPA0                ; the high-order bit of..
 E4F2 | D7 CA                     stab      FPA0                ; ..the mantissa
 E4F4 | CE E4 FA                  ldx       #LE4FA              ; call to LE9A4 requires return address in X
 E4F7 | 7E E9 A4                  jmp       LE9A4               ; push final value (exponent and mantissa) onto stack
 E4FA | CE F0 8B        LE4FA     ldx       #FPONE              ; point X to packed FP value 1.0 (default STEP)
 E4FD | BD F2 51                  jsr       LDFPA0              ; load 1.0 into FPA0
 E500 | BD 00 F3                  jsr       >CHRGOT             ; get current parse token
 E503 | 81 A5                     cmpa      #$A5                ; is it 'STEP' ?
 E505 | 26 06                     bne       LE50D               ; branch if STEP not specified
 E507 | BD 00 EB                  jsr       >CHRGET             ; advance the parser
 E50A | BD E9 0C                  jsr       LE90C               ; evaluate STEP expression into FPA0
 E50D | BD F2 AD        LE50D     jsr       FPTEST              ; ACCB = sign of STEP value (-1, 0, +1)
 E510 | BD E9 A2                  jsr       LE9A2               ; push sign indicator and unpacked STEP value
 E513 | DE B5                     ldx       VARDES              ; get pointer to the control variable..
 E515 | 3C                        pshx                          ; ..and push it onto the stack
 E516 | 86 80                     ldaa      #$80                ; push the token for 'FOR'..
 E518 | 36                        psha                          ; ..onto the stack
      | 
      |                 * ALREADY TRANSLATED
      |                 * Main interpreter loop
 E519 | 8D 4B           LE519     bsr       LE566               ; check for BREAK or PAUSE keys
 E51B | DE F4                     ldx       CHRPTR              ; get parser position
 E51D | DF A9                     stx       TINPTR              ; save in temp storage
 E51F | A6 00                     ldaa      ,X                  ; get current parser character
 E521 | 27 07                     beq       LE52A               ; branch if end-of line
 E523 | 81 3A                     cmpa      #':                 ; is it a statement separator?
 E525 | 27 16                     beq       LE53D               ; branch if separator
 E527 | 7E EA 3C        LE527     jmp       SYNERR              ; issue an ?SN ERROR
      | 
      |                 * End of command or program line
 E52A | 08              LE52A     inx                           ; advance past the end-of-line terminator
 E52B | A6 00                     ldaa      ,X                  ; get MSB of 'next line' link
 E52D | 08                        inx                           ; advacne to LSB
 E52E | AA 00                     oraa      ,X                  ; OR in the LSB of the 'next line' link
 E530 | B7 42 83                  staa      ENDFLG              ; clear ENDFLG if end of program
 E533 | 27 54                     beq       LE589               ; goto END if no more program lines
      | 
      |                 * Start next program line
 E535 | 08                        inx                           ; point X to new line number
 E536 | EC 00                     ldd       ,X                  ; get new line number..
 E538 | DD E2                     std       CURLIN              ; ..and store in CURLIN
 E53A | 08                        inx                           ; advance to LSB of line number
 E53B | DF F4                     stx       CHRPTR              ; set parser position to start of line -1
 E53D | BD 00 EB        LE53D     jsr       >CHRGET             ; parse next token
 E540 | 8D 02                     bsr       LE544               ; dispatch to command handler
 E542 | 20 D5                     bra       LE519               ; continue with next statement or line
      | 
      |                 * Dispatch current command token to its associated handler routine
 E544 | 27 71           LE544     beq       LE5B7               ; return if end-of-line
 E546 | BD 42 A0        LE546     jsr       RVEC10              ; call extension hook
 E549 | 4D                        tsta                          ; set N flag if keyword token
 E54A | 2B 03                     bmi       LE54F               ; branch if token is a keyword
 E54C | 7E E6 D3                  jmp       LET                 ; dispatch to LET handler if not a keyword
 E54F | 81 A0           LE54F     cmpa      #$A0                ; compare to highest valid command token (SKIPF)
 E551 | 22 D4                     bhi       LE527               ; issue an ?SN ERROR if invalid command token
 E553 | 48                        asla                          ; multiply token by 2 (dropping the high bit)
 E554 | 16                        tab                           ; B = dispatch table offset
 E555 | CE E1 48                  ldx       #CMDTBL             ; point X to the dispatch table
 E558 | 3A                        abx                           ; add token offset
 E559 | EE 00                     ldx       ,X                  ; point X to command handler routine
 E55B | BD 00 EB                  jsr       >CHRGET             ; parse next character into ACCA
 E55E | 6E 00                     jmp       ,X                  ; exeute command handler
      | 
      | 
      |                 ***
      |                 *** RESTORE
      |                 ***
 E560 | DE 93           RSTORE    ldx       TXTTAB              ; get pointer to first program line
 E562 | 09                        dex                           ; subtract one
 E563 | DF AD           LE563     stx       DATPTR              ; save search location for next READ
 E565 | 39                        rts                           ; return
      | 
      | 
      |                 *
      |                 * Check for a BREAK or PAUSE key.  Any other key press is saved for use by INKEY$.
 E566 | BD F8 79        LE566     jsr       LF879               ; quick check for any key press
 E569 | 27 0B                     beq       LE576               ; return if no key
 E56B | 81 03           LE56B     cmpa      #3                  ; is it the BREAK key?
 E56D | 27 0F                     beq       STOPRG              ; goto STOP if BREAK key pressed
 E56F | 81 13                     cmpa      #PAUSE              ; is it SHIFT-@ ?
 E571 | 27 04                     beq       LE577               ; go wait for another key if paused
 E573 | B7 42 7F                  staa      IKYCOD              ; save key code for INKEY$
 E576 | 39              LE576     rts
      | 
      |                 * Pause loop.  Wait for a key press to resume.
 E577 | BD F8 83        LE577     jsr       KEYIN               ; read the keyboard
 E57A | 27 FB                     beq       LE577               ; loop if no key pressed (remain paused)
 E57C | 20 ED                     bra       LE56B               ; go check for BREAK or PAUSE
      | 
      | 
      |                 ***
      |                 *** STOP
      |                 ***
 E57E | 0D              STOPRG    sec                           ; set Carry to indicate STOP rather than END
      | 
      |                 ***
      |                 *** END
      |                 ***
 E57F | 26 36           ENDPRG    bne       LE5B7               ; return if any parameters follow the keyword
 E581 | DE F4                     ldx       CHRPTR              ; get iterpreter pointer
 E583 | DF A9                     stx       TINPTR              ; save in temp storage
 E585 | 76 42 83        LE585     ror       ENDFLG              ; move STOP flag into bit 7 of ENDFLG
 E588 | 38                        pulx                          ; pop return address off the stack
 E589 | DE E2           LE589     ldx       CURLIN              ; get execution line number
 E58B | 08                        inx                           ; are we in Direct mode?
 E58C | 27 07                     beq       LE595               ; branch if Direct mode
 E58E | 09                        dex                           ; line number again
 E58F | DF A3                     stx       BRKLIN              ; save line number for use by CONT
 E591 | DE A9                     ldx       TINPTR              ; get iterpreter pointer
 E593 | DF A7                     stx       OLDPTR              ; save pointer for use by CONT
 E595 | 7F 00 E8        LE595     clr       DEVNUM              ; reset device to screen
 E598 | CE E1 C0                  ldx       #BRKMSG-1           ; point X to 'BREAK' string
 E59B | 7D 42 83                  tst       ENDFLG              ; STOP or END ?
 E59E | 2A 03                     bpl       LE5A3               ; branch if END
 E5A0 | 7E E2 66                  jmp       LE266               ; print BREAK message and end 
 E5A3 | 7E E2 71        LE5A3     jmp       LE271               ; print OK prompt and end
      | 
      | 
      |                 ***
      |                 *** CONT
      |                 ***
 E5A6 | 26 0F           CONT      bne       LE5B7               ; return if any parameters follow the keyword
 E5A8 | C6 20                     ldab      #CN_ERR             ; code for ?CN ERROR
 E5AA | DE A7                     ldx       OLDPTR              ; get parser location at time of STOP/END
 E5AC | 26 03                     bne       LE5B1               ; branch if able to continue
 E5AE | 7E E2 38                  jmp       ERRGEN              ; issue the ?CN ERROR
 E5B1 | DF F4           LE5B1     stx       CHRPTR              ; set parser location to continuation point
 E5B3 | DE A3                     ldx       BRKLIN              ; get line number of continuation point
 E5B5 | DF E2                     stx       CURLIN              ; set current line number
 E5B7 | 39              LE5B7     rts                           ; continue program execution
      | 
      | 
      |                 ***
      |                 *** CLEAR [string space [, reserved RAM]]
      |                 ***
 E5B8 | 27 3A           CLEAR     beq       LE5F4               ; branch if no parameters given
 E5BA | BD EB BD                  jsr       LEBBD               ; evaluate integer expression into D
 E5BD | 37                        pshb                          ; save the string space..
 E5BE | 36                        psha                          ; ..parameter on the stack
 E5BF | DE A1                     ldx       MEMSIZ              ; get top of RAM available to Basic
 E5C1 | DF CC                     stx       FPA0+2              ; save in FPA0
 E5C3 | BD 00 F3                  jsr       >CHRGOT             ; get current parse character
 E5C6 | 27 12                     beq       LE5DA               ; branch if end of statement
 E5C8 | BD EA 2F                  jsr       SYNCOM              ; syntax check for comma
 E5CB | BD EF 4C                  jsr       LEF4C               ; evaluate integer expression into X
 E5CE | DE CC                     ldx       FPA0+2              ; unnecessary instruction, value already in X
 E5D0 | 09                        dex                           ; subtract one from parameter value
 E5D1 | DF CC                     stx       FPA0+2              ; save in FPA0
 E5D3 | FC 42 50                  ldd       TOPRAM              ; get highest RAM address - 1
 E5D6 | 93 CC                     subd      FPA0+2              ; subtract new Top-of-Ram value
 E5D8 | 25 1D                     bcs       LE5F7               ; issue an ?OM ERROR if out of range
 E5DA | DC CC           LE5DA     ldd       FPA0+2              ; get new Top-of-Ram value
 E5DC | 37                        pshb                          ; save it..
 E5DD | 36                        psha                          ; ..on the stack
 E5DE | 30                        tsx                           ; point X to parameters on stack
 E5DF | A3 02                     subd      2,X                 ; subtract string space from new Top-of-Ram
 E5E1 | 25 14                     bcs       LE5F7               ; issue ?OM ERROR if not enough memory
 E5E3 | ED 02                     std       2,X                 ; save potential new lower bounds of string space
 E5E5 | 83 00 3A                  subd      #STKBUF             ; subtract minimum stack size requirement
 E5E8 | 25 0D                     bcs       LE5F7               ; issue ?OM ERROR if not enough memory
 E5EA | 93 95                     subd      VARTAB              ; subtract end of the current Basic program
 E5EC | 25 09                     bcs       LE5F7               ; issue ?OM ERROR if not enough memory
 E5EE | 38                        pulx                          ; pull new Top-of-Ram value from stack
 E5EF | DF A1                     stx       MEMSIZ              ; set Top-of-Ram available to Basic
 E5F1 | 38                        pulx                          ; pull new lower bounds of string space
 E5F2 | DF 9B                     stx       FRETOP              ; set new string space / stack boundary
 E5F4 | 7E E3 DE        LE5F4     jmp       LE3DE               ; erase variables, reset stack and return
      | 
      | 
 E5F7 | 7E E2 36        LE5F7     jmp       LE236               ; branch island to issue an ?OM ERROR
      | 
      | 
      |                 ***
      |                 *** RUN [lineNumber]
      |                 ***
 E5FA | 26 03           RUN       bne       LE5FF               ; branch if line number parameter provided
 E5FC | 7E E3 D9                  jmp       LE3D9               ; erase variables, point parser to start and run
 E5FF | BD E3 DE        LE5FF     jsr       LE3DE               ; erase variables
 E602 | 20 0E                     bra       LE612               ; execute a GOTO for the line number parameter 
      | 
      | 
      |                 ***
      |                 *** GOSUB lineNumber
      |                 ***
 E604 | C6 03           GOSUB     ldab      #3                  ; check for 3 words (6 bytes) of available memory
 E606 | BD E2 1A                  jsr       LE21A               ; issue an ?OM ERROR if insufficient space
 E609 | DE F4                     ldx       CHRPTR              ; put the parser position..
 E60B | 3C                        pshx                          ; ..and the current line number..
 E60C | DE E2                     ldx       CURLIN              ; ..onto the stack so that a RETURN
 E60E | 3C                        pshx                          ; ..statement can come back
 E60F | 86 82                     ldaa      #$82                ; token for GOSUB
 E611 | 36                        psha                          ; save token on stack to identify a GOSUB frame
 E612 | BD 00 F3        LE612     jsr       >CHRGOT             ; reload last character parsed
 E615 | 8D 03                     bsr       GOTO                ; call GOTO to jump to the given line number
 E617 | 7E E5 19                  jmp       LE519               ; return to main interpreter loop
      | 
      |                 ***
      |                 *** GOTO lineNumber
      |                 ***
 E61A | BD E6 B2        GOTO      jsr       LE6B2               ; parse line number into BINVAL
 E61D | 8D 3A                     bsr       LE659               ; find end of current line
 E61F | 08                        inx                           ; point X to next line
 E620 | DC A5                     ldd       BINVAL              ; D = target line number
 E622 | 93 E2                     subd      CURLIN              ; subtract current line number
 E624 | 22 02                     bhi       LE628               ; branch if target > current
 E626 | DE 93                     ldx       TXTTAB              ; point X to beginning of program
 E628 | BD E3 BB        LE628     jsr       LE3BB               ; search for the numbered line
 E62B | 25 15                     bcs       LE642               ; issue a ?UL ERROR if not found
 E62D | 09                        dex                           ; point X to previous line's terminator
 E62E | DF F4                     stx       CHRPTR              ; set new parser position
 E630 | 39              LE630     rts                           ; resume at the target line
      | 
      | 
      |                 ***
      |                 *** RETURN
      |                 ***
 E631 | 26 FD           RETURN    bne       LE630               ; return if any parameters follow the keyword
 E633 | 86 FF                     ldaa      #$FF                ; set VARDES to a non-zero value that does not point..
 E635 | 97 B5                     staa      VARDES              ; ..to a variable. This indicates RETURN instead of NEXT
 E637 | BD E1 D8                  jsr       LE1D8               ; scan the stack for a GOSUB-RETURN frame
 E63A | 35                        txs                           ; point S to the GOSUB-RETURN frame
 E63B | 81 02                     cmpa      #$02                ; was a frame found?
 E63D | 27 0B                     beq       LE64A               ; branch if frame found
 E63F | C6 04                     ldab      #RG_ERR             ; B = code for ?RG ERROR
 E641 | 8C                        fcb       SKP2                ; skip next instruction
 E642 | C6 0E           LE642     ldab      #UL_ERR             ; B = code for ?UL ERROR
 E644 | 7E E2 38                  jmp       ERRGEN              ; issue the error
 E647 | 7E EA 3C        LE647     jmp       SYNERR              ; go issue an ?SN ERROR
 E64A | 32              LE64A     pula                          ; pop GOSUB token from stack frame
 E64B | 38                        pulx                          ; pull line number from stack frame
 E64C | DF E2                     stx       CURLIN              ; set current line number
 E64E | 38                        pulx                          ; pull RETURN address from stack (points to GOSUB)
 E64F | DF F4                     stx       CHRPTR              ; set new parser position
      |                                                         ; fall through to DATA statement (skip past the GOSUB)
      | 
      |                 ***
      |                 *** DATA
      |                 ***
 E651 | 8D 03           DATAST    bsr       LE656               ; scan to find end of the current statement
 E653 | DF F4                     stx       CHRPTR              ; advance parser location to next statement
 E655 | 39              LE655     rts
      | 
      | 
      |                 *
      |                 * Find the end of the current program statement (or line) and return that address in X
 E656 | C6 3A           LE656     ldab      #':                 ; use ':' as the primary termination character
 E658 | 86                        fcb       SKP1LDA             ; skip next instruction (LDA #$5F)
      | 
      |                 * Find the end of the current program line and return that address in X
 E659 | 5F              LE659     clrb                          ; use NULL as primary termination character
 E65A | D7 80                     stab      CHARAC              ; set primary termination character
 E65C | 5F                        clrb                          ; use NULL as termination character in strings
 E65D | DE F4                     ldx       CHRPTR              ; X = parser position
 E65F | 17              LE65F     tba                           ; swap current..
 E660 | D6 80                     ldab      CHARAC              ; ..termination..
 E662 | 97 80                     staa      CHARAC              ; ..character
 E664 | A6 00           LE664     ldaa      ,X                  ; read a program byte
 E666 | 27 ED                     beq       LE655               ; return if end-of-line
 E668 | 11                        cba                           ; compare against termination char
 E669 | 27 EA                     beq       LE655               ; return if it's a match
 E66B | 08                        inx                           ; advance to next character
 E66C | 81 22                     cmpa      #'"                 ; if it's a string delimiter then swap..
 E66E | 27 EF                     beq       LE65F               ; ..termination characters and continue
 E670 | 20 F2                     bra       LE664               ; keep searching
      | 
      | 
      |                 ***
      |                 *** IF expression THEN|GOTO ...
      |                 ***
 E672 | BD E9 0C        IFSTMT    jsr       LE90C               ; evaluate numeric expression into FPA0
 E675 | BD 00 F3                  jsr       >CHRGOT             ; get current token
 E678 | 81 81                     cmpa      #$81                ; is it a GOTO token?
 E67A | 27 05                     beq       LE681               ; branch if GOTO
 E67C | C6 A3                     ldab      #$A3                ; get token for THEN
 E67E | BD EA 31                  jsr       LEA31               ; issue an ?SN ERROR if not THEN
 E681 | 96 C9           LE681     ldaa      FP0EXP              ; was expression TRUE or FALSE ?
 E683 | 26 05                     bne       LE68A               ; branch if non-zero (TRUE)
      | 
      | 
      |                 ***
      |                 *** REM
      |                 ***
 E685 | 8D D2           REM       bsr       LE659               ; find end of current program line
 E687 | DF F4                     stx       CHRPTR              ; set parser position for next line
 E689 | 39                        rts
      | 
      |                 *
      |                 * An IF statement branches here when the expression evaluates to TRUE
 E68A | BD 00 F3        LE68A     jsr       >CHRGOT             ; get current parse character
 E68D | 25 8B                     bcs       GOTO                ; if numeric then GOTO numbered line
 E68F | 7E E5 44                  jmp       LE544               ; go process command token
      | 
      | 
      |                 ***
      |                 *** ON expression GOTO|GOSUB
      |                 ***
 E692 | BD EF 0D        ONSTMT    jsr       LEF0D               ; evaulate expression (0..255) into ACCB
 E695 | 36                        psha                          ; save current parser token on the stack
 E696 | 81 82                     cmpa      #$82                ; is it 'GOSUB' ?
 E698 | 27 04                     beq       LE69E               ; branch if GOSUB
 E69A | 81 81                     cmpa      #$81                ; is it 'GOTO' ?
 E69C | 26 A9           LE69C     bne       LE647               ; issue an ?SN ERROR if not GOTO
 E69E | 7A 00 CD        LE69E     dec       FPA0+3              ; decrement the expression value
 E6A1 | 26 04                     bne       LE6A7               ; branch if not at target line number
 E6A3 | 32                        pula                          ; restore parser token (GOTO or GOSUB) to ACCA
 E6A4 | 7E E5 46                  jmp       LE546               ; go dispacth the GOTO or GOSUB
 E6A7 | BD 00 EB        LE6A7     jsr       >CHRGET             ; advance parser to next char
 E6AA | 8D 06                     bsr       LE6B2               ; parse line number into BINVAL
 E6AC | 81 2C                     cmpa      #',                 ; is there a comma following the line number?
 E6AE | 27 EE                     beq       LE69E               ; loop if more line numbers to process
 E6B0 | 31                        ins                           ; pop saved token off the stack
 E6B1 | 39              LE6B1     rts                           ; continue with next statement
      | 
      | 
      |                 *
      |                 * Parse an integer value between 0 and 63999 and store result in BINVAL
 E6B2 | CE 00 00        LE6B2     ldx       #0                  ; initialize BINVAL..
 E6B5 | DF A5                     stx       BINVAL              ; ..to zero
 E6B7 | 24 F8           LE6B7     bcc       LE6B1               ; return if current parse character is not a digit
 E6B9 | 80 30                     suba      #'0                 ; convert ASCII digit to binary
 E6BB | 97 80                     staa      CHARAC              ; store the digit's value in CHARAC
 E6BD | DC A5                     ldd       BINVAL              ; check if multiplication by 10 will..
 E6BF | 81 18                     cmpa      #$18                ; ..cause accumulated value to overflow
 E6C1 | 22 D9                     bhi       LE69C               ; issue an ?SN ERROR if number > 6399
 E6C3 | 05                        asld                          ; multiply accumulated value by 2
 E6C4 | 05                        asld                          ; now multiplied by 4
 E6C5 | D3 A5                     addd      BINVAL              ; now multiplied by 5
 E6C7 | 05                        asld                          ; and finally multiplied by 10
 E6C8 | DB 80                     addb      CHARAC              ; add digit's value to LSB
 E6CA | 89 00                     adca      #0                  ; add any carry to MSB
 E6CC | DD A5                     std       BINVAL              ; store accumulated value
 E6CE | BD 00 EB                  jsr       >CHRGET             ; parse next character
 E6D1 | 20 E4                     bra       LE6B7               ; loop
      | 
      | 
      |                 ***
      |                 *** [LET] var = expression
      |                 ***
 E6D3 | BD EB 1B        LET       jsr       LEB1B               ; parse variable name and find/create it
 E6D6 | DF B5                     stx       VARDES              ; save pointer to the variable
 E6D8 | C6 AF                     ldab      #$AF                ; token for '='
 E6DA | BD EA 31                  jsr       LEA31               ; issue ?SN ERROR if next token is not '='
 E6DD | 96 84                     ldaa      VALTYP              ; get variable type
 E6DF | 36                        psha                          ; save type on stack
 E6E0 | BD E9 1A                  jsr       LE91A               ; parse and evaluate an expression
 E6E3 | 32                        pula                          ; pull variable's type into ACCA
 E6E4 | 46                        rora                          ; shift variable's type into Carry
 E6E5 | BD E9 10                  jsr       LE910               ; ?TM ERROR if variable type <> expression type
 E6E8 | 27 2F                     beq       LE719               ; branch if numeric assignment
      | 
      |                 * String variable assignment
 E6EA | DE CC           LE6EA     ldx       FPA0+2              ; get ptr to string expression descriptor from FPA0
 E6EC | DC 9B                     ldd       FRETOP              ; ACCD = lower bounds of string space
 E6EE | A3 02                     subd      2,X                 ; subtract address of the string data
 E6F0 | 24 13                     bcc       LE705               ; branch if string data not in string space
 E6F2 | DC 95                     ldd       VARTAB              ; ACCD = start of variables
 E6F4 | 93 CC                     subd      FPA0+2              ; subtract address of string descriptor
 E6F6 | 22 0D                     bhi       LE705               ; branch if descriptor is not from a variable
 E6F8 | E6 00                     ldab      ,X                  ; load string length into ACCB
 E6FA | BD EC FC                  jsr       LECFC               ; allocate string space (put descriptor in STRDES)
 E6FD | DE C7                     ldx       DESPTR              ; get ptr to string expression descriptor
 E6FF | BD EE 38                  jsr       LEE38               ; copy string data into the allocated string space
 E702 | CE 00 D0                  ldx       #STRDES             ; point X to new string descriptor
 E705 | DF C7           LE705     stx       DESPTR              ; save pointer to string descriptor
 E707 | BD EE 70                  jsr       LEE70               ; pop string stack if descriptor is currently on top
 E70A | DE C7                     ldx       DESPTR              ; get pointer to string descriptor
 E70C | A6 00                     ldaa      ,X                  ; get string length
 E70E | 36                        psha                          ; save string length on stack
 E70F | EC 02                     ldd       2,X                 ; ACCD = address of string data
 E711 | DE B5                     ldx       VARDES              ; point X to the assignment variable's descriptor
 E713 | ED 02                     std       2,X                 ; store string data address in variable's descriptor
 E715 | 32                        pula                          ; pull string length into ACCA
 E716 | A7 00                     staa      ,X                  ; store string length in variable's descriptor
 E718 | 39                        rts                           ; return
      | 
 E719 | 7E F2 70        LE719     jmp       LF270               ; copy value from FPA0 into the numeric variable
      | 
      | 
      |                 ***
      |                 *** LPRINT
      |                 ***
 E71C | BD E4 04        LPRINT    jsr       LE404               ; redirect I/O to the serial port
      | 
      | 
      |                 ***
      |                 *** PRINT command
      |                 ***
 E71F | 8D 04           PRINT     bsr       LE725               ; call core PRINT routine
 E721 | 7F 00 E8                  clr       DEVNUM              ; redirect I/O to the screen
 E724 | 39                        rts                           ; return
      | 
 E725 | 27 3F           LE725     beq       LE766               ; branch if no items to print
 E727 | 81 40                     cmpa      #'@                 ; check for '@' character
 E729 | 26 0B                     bne       LE736               ; branch if not PRINT@
 E72B | BD FC 29                  jsr       LFC29               ; evaluate screen position expression
 E72E | BD 00 F3                  jsr       >CHRGOT             ; get current parse character
 E731 | 27 33                     beq       LE766               ; branch if no items to print
 E733 | BD EA 2F                  jsr       SYNCOM              ; syntax check for comma ','
      | 
 E736 | 27 3B           LE736     beq       LE773               ; RTS if no more items to print
 E738 | 81 A1           LE738     cmpa      #$A1                ; is it a 'TAB(' token?
 E73A | 27 50                     beq       LE78C               ; branch if explicit tab function
 E73C | 81 2C                     cmpa      #',                 ; is it a comma ',' ?
 E73E | 27 34                     beq       LE774               ; branch if tabbing to next tab stop
 E740 | 81 3B                     cmpa      #';                 ; is it a semicolon ';' ?
 E742 | 27 5E                     beq       LE7A2               ; go skip ';' and check for another item
 E744 | BD E9 1A                  jsr       LE91A               ; evaluate an expression
 E747 | 96 84                     ldaa      VALTYP              ; get the expression type
 E749 | 36                        psha                          ; save expression type on stack
 E74A | 26 06                     bne       LE752               ; branch if it is a string expression
 E74C | BD F4 26                  jsr       LF426               ; convert number to string in STRBUF
 E74F | BD ED 05                  jsr       LED05               ; build string descriptor and put on string stack
 E752 | 8D 57           LE752     bsr       LE7AB               ; output string to current device
 E754 | 33                        pulb                          ; pull expression type into ACCB
 E755 | 5D                        tstb                          ; what type?
 E756 | 26 09                     bne       LE761               ; branch if string
 E758 | BD 00 F3                  jsr       >CHRGOT             ; get current parse character
 E75B | 81 2C                     cmpa      #',                 ; is it a comma ',' ?
 E75D | 27 15                     beq       LE774               ; branch if ',' follows numeric value
 E75F | 8D 58                     bsr       OUTSPC              ; output a Space following a numeric value
 E761 | BD 00 F3        LE761     jsr       >CHRGOT             ; get curent parse character
 E764 | 26 D2                     bne       LE738               ; loop if more items to print
      | 
 E766 | 86 0D           LE766     ldaa      #CR                 ; output a Carriage Return to..
 E768 | 20 54                     bra       LE7BE               ; ..the current device then return
      | 
      | 
      |                 *
      |                 * Output a Carriage Return to the current device if not already at beginning of a line 
 E76A | BD FA 7B        LE76A     jsr       LFA7B               ; setup Tab and Line settings for current device
 E76D | 27 F7                     beq       LE766               ; branch if device line width is zero
 E76F | 96 E6                     ldaa      DEVPOS              ; get current line position
 E771 | 26 F3                     bne       LE766               ; branch if not at beginning of line
 E773 | 39              LE773     rts                           ; return
      | 
      | 
      |                 * Output enough Spaces to get to the next Tab stop
 E774 | BD FA 7B        LE774     jsr       LFA7B               ; get tab info/line position for current device
 E777 | 27 0A                     beq       LE783               ; branch if not a line-based device
 E779 | D6 E6                     ldab      DEVPOS              ; get position in line
 E77B | D1 E5                     cmpb      DEVLCF              ; compare with 'last tab' position
 E77D | 25 06                     blo       LE785               ; branch if more tab stops on the line
 E77F | 8D E5                     bsr       LE766               ; output a carriage return instead of tabbing
 E781 | 20 1F                     bra       LE7A2               ; check for more items to print
      | 
 E783 | D6 E6           LE783     ldab      DEVPOS              ; get position in line
 E785 | D0 E4           LE785     subb      DEVCFW              ; subtract tab width
 E787 | 24 FC                     bcc       LE785               ; loop until ACCB goes negative
 E789 | 50                        negb                          ; ACCB = number of spaces to next tab stop
 E78A | 20 11                     bra       LE79D               ; go output ACCB spaces
      | 
      |                 * Evaluate TAB() function
 E78C | BD EF 0A        LE78C     jsr       LEF0A               ; evaluate integer expression into ACCB
 E78F | 81 29                     cmpa      #')                 ; check for closing parenthesis ')'
 E791 | 27 03                     beq       LE796               ; branch if ')'
 E793 | 7E EA 3C                  jmp       SYNERR              ; issue an ?SN ERROR
 E796 | BD FA 7B        LE796     jsr       LFA7B               ; get tab info/line position for current device
 E799 | D0 E6                     subb      DEVPOS              ; calculate number of spaces to the tab position
 E79B | 23 05                     bls       LE7A2               ; branch if current position > tab position
      | 
      |                 * Output the number of spaces specified in ACCB
 E79D | 8D 1A           LE79D     bsr       OUTSPC              ; output one space
 E79F | 5A                        decb                          ; decrement counter
 E7A0 | 26 FB                     bne       LE79D               ; loop until done
 E7A2 | BD 00 EB        LE7A2     jsr       >CHRGET             ; parse next character
>E7A5 | 7E E7 36                  jmp       LE736               ; go check for more items to PRINT
      | 
      | 
      |                 *
      |                 * Output string at X+1 to the current device.
      |                 * String must be terminated by a quote (") or a null byte.
      |                 * 
 E7A8 | BD ED 06        STROUT    jsr       LED06               ; put descriptor for string on the string stack
 E7AB | BD EE 56        LE7AB     jsr       LEE56               ; pop descriptor, get string ptr in X, length in ACCB
 E7AE | 5C                        incb                          ; increment length for pre-decrementing loop
 E7AF | 5A              LE7AF     decb                          ; decrement character counter
 E7B0 | 27 C1                     beq       LE773               ; RTS if end of string
 E7B2 | A6 00                     ldaa      ,X                  ; ACCA = string character
 E7B4 | 08                        inx                           ; bump the string pointer
 E7B5 | 8D 07                     bsr       LE7BE               ; send character to current output device
 E7B7 | 20 F6                     bra       LE7AF               ; loop for another character
      | 
      |                 * Output a Space to the current device
 E7B9 | 86 20           OUTSPC    ldaa      #SPACE              ; ASCII code for Space
 E7BB | 8C                        fcb       SKP2                ; skip next instruction
      | 
      |                 * Output a '?' to the current device
 E7BC | 86 3F           LE7BC     ldaa      #'?                 ; ASCII code for '?'
 E7BE | 7E F9 C6        LE7BE     jmp       PUTCHR              ; send character to output device and return
      | 
      | 
      |                 * '?REDO' message string which may be presented during INPUT
 E7C1 | 3F 52 45 44 4F  RDOMSG    fcc       '?REDO'
 E7C6 | 0D 00                     fcb       CR,$00
      | 
      | 
      |                 * Report a bad DATA statement or illegal user INPUT
 E7C8 | 96 87           LE7C8     ldaa      INPFLG              ; INPUT or READ statement?
 E7CA | 27 07                     beq       LE7D3               ; branch if INPUT statement
 E7CC | DE AB                     ldx       DATLIN              ; get line number of the DATA statement..
 E7CE | DF E2                     stx       CURLIN              ; ..and set it as the current line number
 E7D0 | 7E EA 3C                  jmp       SYNERR              ; go issue an ?SN ERROR for the DATA line
 E7D3 | CE E7 C0        LE7D3     ldx       #RDOMSG-1           ; point X to '?REDO' message (-1)
>E7D6 | BD E7 A8                  jsr       STROUT              ; output message to screen
 E7D9 | DE A9                     ldx       TINPTR              ; point X to beginning of INPUT statement
 E7DB | DF F4                     stx       CHRPTR              ; set parser position to re-execute the statement
 E7DD | 39              LE7DD     rts                           ; return and execute INPUT again
      | 
      | 
      |                 ***
      |                 *** INPUT ["prompt";] var [,var]...
      |                 ***
 E7DE | C6 16           INPUT     ldab      #ID_ERR             ; code for ?ID ERROR
 E7E0 | DE E2                     ldx       CURLIN              ; get current line number
 E7E2 | 08                        inx                           ; check for immediate mode
 E7E3 | 26 03                     bne       LE7E8               ; branch if not in immediate mode
 E7E5 | 7E E2 38                  jmp       ERRGEN              ; issue an ?ID ERROR
      | 
 E7E8 | 81 22           LE7E8     cmpa      #'"                 ; is there a prompt string?
 E7EA | 26 0B                     bne       LE7F7               ; branch if no prompt specified
 E7EC | BD EA 07                  jsr       LEA07               ; parse literal string onto the string stack
 E7EF | C6 3B                     ldab      #';                 ; issue an ?SN ERROR if next character..
 E7F1 | BD EA 31                  jsr       LEA31               ; ..is not a semicolon (;)
>E7F4 | BD E7 AB                  jsr       LE7AB               ; print prompt string on the screen
 E7F7 | 8D 06           LE7F7     bsr       LE7FF               ; output a '?' and read a line from console
 E7F9 | C6 2C                     ldab      #',                 ; put a comma in the leader byte..
 E7FB | E7 00                     stab      ,X                  ; ..of the line input buffer
 E7FD | 20 12                     bra       LE811               ; go scan the input data for a value
      | 
      |                 * Request INPUT
>E7FF | BD E7 BC        LE7FF     jsr       LE7BC               ; output a '?' to the console
>E802 | BD E7 B9                  jsr       OUTSPC              ; output a SPACE to the console
 E805 | BD FA A4                  jsr       LFAA4               ; read a line from the console
 E808 | 24 D3                     bcc       LE7DD               ; RTS if line input terminated by ENTER key
 E80A | 38                        pulx                          ; pop return address off the stack
 E80B | 7E E5 85                  jmp       LE585               ; go display 'STOP' and end program (BREAK pressed)
      | 
      | 
      |                 ***
      |                 *** READ  var [,var]...
      |                 ***
 E80E | DE AD           READ      ldx       DATPTR              ; get current postion for READ
 E810 | 86                        fcb       SKP1LDA             ; flag value for READ   (LDA #$4F)
 E811 | 4F              LE811     clra                          ; flag value for INPUT  (A=0)
 E812 | 97 87                     staa      INPFLG              ; store INPUT/READ flag
 E814 | DF AF                     stx       DATTMP              ; store pointer for scanning DATA or user INPUT
 E816 | BD EB 1B        LE816     jsr       LEB1B               ; parse variable identifier in program
 E819 | DF B5                     stx       VARDES              ; save pointer to the variable in VARDES
 E81B | DE F4                     ldx       CHRPTR              ; save program parser position in..
 E81D | DF A5                     stx       BINVAL              ; ..BINVAL while parsing DATA or user INPUT
 E81F | DE AF                     ldx       DATTMP              ; get last INPUT/DATA scan location
      |
      |                 * BUG: If a DATA statement ends at a ':' rather than at the end of a line,
      |                 * the next READ will not search ahead for another DATA statement.
      |
 E821 | A6 00                     ldaa      ,X                  ; end of user INPUT or DATA?
 E823 | 26 09                     bne       LE82E               ; branch if more items to scan
 E825 | 96 87                     ldaa      INPFLG              ; READ or INPUT statement?
 E827 | 26 4E                     bne       LE877               ; branch if READ
      | 
      |                 * The INPUT buffer is empty so ask user for more
>E829 | BD E7 BC                  jsr       LE7BC               ; output a '?' to the screen
 E82C | 8D D1                     bsr       LE7FF               ; read a line from CONSOLE IN
 E82E | DF F4           LE82E     stx       CHRPTR              ; set parser position to the INPUT/READ data
 E830 | BD 00 EB                  jsr       >CHRGET             ; parse first non-space character of input data
 E833 | D6 84                     ldab      VALTYP              ; check current input variable type
 E835 | 27 1C                     beq       LE853               ; branch if numeric variable
      | 
      |                 * Parse string variable data
 E837 | DE F4                     ldx       CHRPTR              ; get parser position
 E839 | 97 80                     staa      CHARAC              ; use first input chracter for terminator 1
 E83B | 81 22                     cmpa      #'"'                ; if first character is a string delimiter (")..
 E83D | 27 07                     beq       LE846               ; ..then consume delimiter and branch
 E83F | 09                        dex                           ; don't consume the first character
 E840 | 86 3A                     ldaa      #':                 ; use ':' for..
 E842 | 97 80                     staa      CHARAC              ; ..terminator 1
 E844 | 86 2C                     ldaa      #',                 ; use ',' for..
 E846 | 97 81           LE846     staa      ENDCHR              ; ..terminator 2
 E848 | BD ED 0C                  jsr       LED0C               ; parse string data onto the string stack
 E84B | BD EF 3E                  jsr       LEF3E               ; set parse location to end of string data
 E84E | BD E6 EA                  jsr       LE6EA               ; assign string value to the variable
 E851 | 20 06                     bra       LE859               ; go check if more data is available
      | 
      |                 * Parse numeric variable data
 E853 | BD F3 59        LE853     jsr       LF359               ; parse FP number into FPA0
 E856 | BD F2 70                  jsr       LF270               ; copy value from FPA0 into the numeric variable
      | 
      |                 * Check DATA or user INPUT to see if another value is available
 E859 | BD 00 F3        LE859     jsr       >CHRGOT             ; get current parse character
 E85C | 27 07                     beq       LE865               ; branch if no more data to scan
 E85E | 81 2C                     cmpa      #',                 ; check for a comma ','
 E860 | 27 03                     beq       LE865               ; branch if it is a valid item separator
 E862 | 7E E7 C8                  jmp       LE7C8               ; go report bad DATA or user INPUT
      | 
 E865 | DE F4           LE865     ldx       CHRPTR              ; get pointer to last scan location
 E867 | DF AF                     stx       DATTMP              ; save it for scanning the next item
 E869 | DE A5                     ldx       BINVAL              ; get the saved program parse location
 E86B | DF F4                     stx       CHRPTR              ; set parser position to program code
 E86D | BD 00 F3                  jsr       >CHRGOT             ; get program character/token
 E870 | 27 25                     beq       LE897               ; branch if end of INPUT/READ statement
 E872 | BD EA 2F                  jsr       SYNCOM              ; syntax check for comma ','
 E875 | 20 9F                     bra       LE816               ; go get next INPUT/READ variable
      | 
      |                 * Search program for a 'DATA' statement starting from address in X
 E877 | DF F4           LE877     stx       CHRPTR              ; set parser position
 E879 | BD E6 56                  jsr       LE656               ; scan to the end of the current statement
 E87C | 08                        inx                           ; point X to start of next statement or line link
 E87D | 4D                        tsta                          ; end of statement (:) or end of line (0) ?
 E87E | 26 0F                     bne       LE88F               ; branch if ':'
 E880 | C6 06                     ldab      #OD_ERR             ; code for ?OD ERROR
 E882 | A6 00                     ldaa      ,X                  ; get MSB of next line link
 E884 | AA 01                     oraa      1,X                 ; OR in the LSB
 E886 | 27 46                     beq       LE8CE               ; branch if end of program
 E888 | EC 02                     ldd       2,X                 ; get the next line number
 E88A | DD AB                     std       DATLIN              ; set current DATA statement line number
 E88C | C6 04                     ldab      #4                  ; advance X by 4 bytes (size of..
 E88E | 3A                        abx                           ; ..line link and line number)
      |                 *
      |                 * BUG: Any white space between a ':' and a DATA keyword will
      |                 * cause the interpreter to miss the DATA statement.
      |                 *
 E88F | A6 00           LE88F     ldaa      ,X                  ; read first byte of the statement
 E891 | 81 85                     cmpa      #$85                ; is it a DATA token?
 E893 | 26 E2                     bne       LE877               ; if not then search for next DATA statement
 E895 | 20 97                     bra       LE82E               ; go read from this DATA statement
      | 
      |                 * Completion of an INPUT/READ statement
 E897 | DE AF           LE897     ldx       DATTMP              ; get pointer to remaining DATA or user INPUT 
 E899 | D6 87                     ldab      INPFLG              ; READ or INPUT statement?
 E89B | 27 03                     beq       LE8A0               ; branch if INPUT
 E89D | 7E E5 63                  jmp       LE563               ; go save pointer for next READ and return
      | 
      |                 * Check for extraneous data provided by user during INPUT
 E8A0 | A6 00           LE8A0     ldaa      ,X                  ; any more data in the input buffer?
 E8A2 | 27 06                     beq       LE8AA               ; RTS if no more data
 E8A4 | CE E8 AA                  ldx       #IGNMSG-1           ; point X to '?EXTRA IGNORED' message (-1)
 E8A7 | 7E E7 A8                  jmp       STROUT              ; output message to screen and return
      | 
      |                 * This RTS is only used via a branch
 E8AA | 39              LE8AA     rts                           ; return  
      | 
      | 
      |                 * The "?EXTRA IGNORED" message may be displayed during an INPUT statement
 E8AB | 3F 45 58 54 52  IGNMSG    fcc       '?EXTRA IGNORED'
 E8B0 | 41 20 49 47 4E 
 E8B5 | 4F 52 45 44 
 E8B9 | 0D 00                     fcb       CR,$00
      | 
      |                 ***
      |                 *** NEXT [var [,var]]...
      |                 ***
 E8BB | 26 05           NEXT      bne       LE8C2               ; branch if specific variable(s) specified
 E8BD | CE 00 00                  ldx       #0                  ; NIL pointer indicates "any variable"
 E8C0 | 20 03                     bra       LE8C5               ; skip next instruction
 E8C2 | BD EB 1B        LE8C2     jsr       LEB1B               ; parse variable name and find its address
 E8C5 | DF B5           LE8C5     stx       VARDES              ; store ptr to variable being sought (or NIL)
 E8C7 | BD E1 D8                  jsr       LE1D8               ; scan the stack for the FOR-NEXT frame
 E8CA | 27 04                     beq       LE8D0               ; branch if frame was found
 E8CC | C6 00                     ldab      #NF_ERR             ; code for ?NF ERROR  (could be CLRB)
 E8CE | 20 47           LE8CE     bra       LE917               ; go issue the error
      | 
      |                 * FOR-NEXT frame:
      |                 *      0: $80  (FOR token)
      |                 *    1-2: pointer to the control variable
      |                 *    3-7: step value (unpacked FP)
      |                 *      8: sign of step (-1, 0 or +1)
      |                 *   9-13: final value (unpacked FP)
      |                 *  14-15: line number of FOR statement
      |                 *  16-17: pointer to end of FOR statement
      |                 *
 E8D0 | 35              LE8D0     txs                           ; purge stack up to the FOR-NEXT frame
 E8D1 | 08                        inx                           ; point X to the..
 E8D2 | 08                        inx                           ; ..STEP value in
 E8D3 | 08                        inx                           ; ..the FOR-NEXT frame
 E8D4 | BD F2 51                  jsr       LDFPA0              ; load absolute step value into FPA0
 E8D7 | 30                        tsx                           ; point X to the FOR-NEXT frame
 E8D8 | A6 08                     ldaa      8,X                 ; get sign of the STEP value
 E8DA | 97 CE                     staa      FP0SGN              ; set sign of FPA0
 E8DC | DE B5                     ldx       VARDES              ; point X to the variable
 E8DE | BD EF 7D                  jsr       LEF7D               ; add variable's value to FPA0
 E8E1 | BD F2 70                  jsr       LF270               ; store FPA0 into the variable
 E8E4 | 30                        tsx                           ; point X to the FOR-NEXT frame
 E8E5 | C6 09                     ldab      #9                  ; point X to the 'final'..
 E8E7 | 3A                        abx                           ; ..value in the frame
 E8E8 | BD F2 D9                  jsr       LF2D9               ; compare FPA0 to the 'final' value
 E8EB | 30                        tsx                           ; point X to the FOR-NEXT frame
 E8EC | E0 08                     subb      8,X                 ; if comparison result in ACCB is equal to..
 E8EE | 27 0C                     beq       LE8FC               ; ..the STEP direction then go exit FOR-NEXT loop
 E8F0 | EE 0E                     ldx       14,X                ; get line number of the FOR statement and..
 E8F2 | DF E2                     stx       CURLIN              ; ..store as the new current line number
 E8F4 | 30                        tsx                           ; point X to FOR-NEXT frame (could remove and use LDD,STD above)
 E8F5 | EE 10                     ldx       16,X                ; get pointer to end of FOR statement and..
 E8F7 | DF F4                     stx       CHRPTR              ; ..store as the new parser position
 E8F9 | 7E E5 19        LE8F9     jmp       LE519               ; resume execution of program
      | 
      |                 * Termination of a FOR-NEXT loop.  Pop the frame off the stack.
 E8FC | C6 12           LE8FC     ldab      #18                 ; size of FOR-NEXT frame
 E8FE | 3A                        abx                           ; advance X past end of frame
 E8FF | 35                        txs                           ; set new stack pointer (popping frame)
 E900 | BD 00 F3                  jsr       >CHRGOT             ; get current parse character
 E903 | 81 2C                     cmpa      #',                 ; is it a comma ',' ?
 E905 | 26 F2                     bne       LE8F9               ; branch if no more arguments
 E907 | BD 00 EB                  jsr       >CHRGET             ; consume the ','
 E90A | 8D B6                     bsr       LE8C2               ; call NEXT again (this call will not return)
      |                                                         ; BSR is used instead of BRA because the subroutine..
      |                                                         ; ..which scans the stack purges two return addresses
      |                 *
      |                 * Evaluate an expression and type check for Numeric
 E90C | 8D 0C           LE90C     bsr       LE91A               ; evaluate expression
      | 
      |                 * Issue a ?TM ERROR if VALTYP is the wrong type.
      |                 *   Enter at LE90E to check for a Numeric type
      |                 *   Enter at LE90F to check for a String type
      |                 *   Enter at LE910 to check for the type indicated by Carry flag (0=Numeric, 1=String)
 E90E | 6D              LE90E     fcb       $6D                 ; TST $0D,X  clears carry and skips next instruction
 E90F | 0D              LE90F     sec                           ; set carry to check for string type
 E910 | 76 00 84        LE910     ror       VALTYP              ; set overflow if wrong type (C->N, VALTYP->C, (C xor N)->V)
 E913 | 28 95                     bvc       LE8AA               ; branch to an RTS if type is correct
 E915 | C6 18                     ldab      #TM_ERR             ; code for ?TM ERROR
 E917 | 7E E2 38        LE917     jmp       ERRGEN              ; issue the error
      | 
      |                 *
      |                 * Evaluate an expression
      |                 *
 E91A | DE F4           LE91A     ldx       CHRPTR              ; get parser position
 E91C | 09                        dex                           ; backup by one
 E91D | DF F4                     stx       CHRPTR              ; set parser position
 E91F | 4F                        clra                          ; set end-of-expression precedence
 E920 | C6                        fcb       SKP1LDB             ; skip next instruction (LDB #$37)
      | 
      |                 * Parse next expression term (which could also be a complete sub-expression within parenthesis)
 E921 | 37              LE921     pshb                          ; push relational operator flags
 E922 | 36                        psha                          ; push operator precedence
 E923 | C6 01                     ldab      #1                  ; check if there is room to allocate..
 E925 | BD E2 1A                  jsr       LE21A               ; ..1 word (2 bytes) of free memory
 E928 | BD E9 E5                  jsr       LE9E5               ; evaluate expression term into FPA0
      | 
      |                 * Parse an expression operator.
      |                 *
      |                 * First scan for relational operator tokens and set
      |                 * the bits in RELOPS for each token encountered:
      |                 *   bit 0:  '>'
      |                 *   bit 1:  '='
      |                 *   bit 2:  '<'
      |                 *
 E92B | 7F 00 B9                  clr       RELOPS              ; initialize relational operator flags
 E92E | BD 00 F3        LE92E     jsr       >CHRGOT             ; get current parse character/token
 E931 | 80 AE           LE931     suba      #$AE                ; subtract token for '>'
 E933 | 25 14                     blo       LE949               ; branch if not a relational operator token 
 E935 | 81 03                     cmpa      #3                  ; one of the three relational tokens?
 E937 | 24 10                     bcc       LE949               ; branch if not a relational operator token
 E939 | 81 01                     cmpa      #1                  ; set carry if ACCA = 0
 E93B | 49                        rola                          ; ACCA: ($01 = '>') ($02 = '=') ($04 = '<')
 E93C | 98 B9                     eora      RELOPS              ; clear token bit if previously encountered
 E93E | 91 B9                     cmpa      RELOPS              ; set carry if token previously encountered
 E940 | 25 59                     bcs       LE99B               ; issue ?SN ERROR if token appears twice
 E942 | 97 B9                     staa      RELOPS              ; store relational operator flags
 E944 | BD 00 EB                  jsr       >CHRGET             ; parse next character
 E947 | 20 E8                     bra       LE931               ; check for another relational token
      | 
 E949 | D6 B9           LE949     ldab      RELOPS              ; any relational tokens encountered?
 E94B | 26 2B                     bne       LE978               ; branch if relational operation
      | 
      |                 * Not a relational operator.  Check for arithmetic or bitwise operator
 E94D | 24 66                     bcc       LE9B5               ; branch if not an operator token
 E94F | 8B 07                     adda      #7                  ; one of seven operator tokens (+ - * / ^ AND OR)?
 E951 | 24 62                     bcc       LE9B5               ; branch if not an operator token
 E953 | 99 84                     adca      VALTYP              ; ACCA = VALTYP + operator index + 1
 E955 | 26 03                     bne       LE95A               ; branch if not string catenation
 E957 | 7E EE 06                  jmp       LEE06               ; go do string catenation
 E95A | 89 FF           LE95A     adca      #-1                 ; ACCA = operator index (0-6)
 E95C | 16                        tab                           ; ACCB = operator index * 3
 E95D | 48                        asla                          ; ..
 E95E | 1B                        aba                           ; ..
 E95F | 16                        tab                           ; ..
 E960 | CE E0 30                  ldx       #OPTABL             ; point X to the corresponding entry in..
 E963 | 3A                        abx                           ; ..the operator prcedence/dispatch table
 E964 | 32              LE964     pula                          ; get stacked operation precedence
 E965 | A1 00                     cmpa      ,X                  ; compare with current operator precedence
 E967 | 24 53                     bcc       LE9BC               ; branch if stacked operation has higher precedence
 E969 | 8D A3                     bsr       LE90E               ; issue a ?TM ERROR if operand is a string
      | 
      |                 * Current operation has higher precedence than previous
 E96B | 36              LE96B     psha                          ; push precedence flag onto stack
 E96C | 8D 23                     bsr       LE991               ; stack left operand and evaluate right
 E96E | DE B7                     ldx       OPSAVE              ; point X to entry in operator dispatch table
 E970 | 32                        pula                          ; get precedence flag from stack
 E971 | 26 18                     bne       LE98B               ; branch if not end of expression (X <> NIL)
 E973 | 4D                        tsta                          ; test precedence flag
 E974 | 27 6C                     beq       LE9E2               ; branch if end of expression
 E976 | 20 4D                     bra       LE9C5               ; go perform operation
      | 
      |                 * Relational operator. Update flags to include value type:
      |                 *   bit 0:  Type (0 = numeric, 1 = string)
      |                 *   bit 1:  '>'
      |                 *   bit 2:  '='
      |                 *   bit 3:  '<'
      |                 *
 E978 | 78 00 84        LE978     asl       VALTYP              ; set carry if string comparison
 E97B | 59                        rolb                          ; shift relational flags left, set bit 0 if string
 E97C | DE F4                     ldx       CHRPTR              ; backup the parser..
 E97E | 09                        dex                           ; ..location to the..
 E97F | DF F4                     stx       CHRPTR              ; ..previous character
 E981 | CE E9 88                  ldx       #RELPRC             ; point X to relational operator prcedence/dispatch
 E984 | D7 B9                     stab      RELOPS              ; store relational operator flags
 E986 | 20 DC                     bra       LE964               ; go perform or stack the operation
      | 
      |                 * Precedence and dispatch address for relational operations
 E988 | 64              RELPRC    fcb       $64                 ; precedence for relational operations
 E989 | EA AE                     fdb       COMPAR              ; relational operation routine address
      | 
      |                 * Check precedence to see if operation should be stacked or evaluated
 E98B | A1 00           LE98B     cmpa      ,X                  ; compare precedence flags of top two operations
 E98D | 24 36                     bcc       LE9C5               ; go evaluate operation if it has higher precedence
 E98F | 20 DA                     bra       LE96B               ; stack the operation and continue
      | 
      |                 * Stack the current operator info and left operand then evaluate right operand
 E991 | EC 01           LE991     ldd       1,X                 ; ACCD = operation dispatch address
 E993 | 37                        pshb                          ; put operation address..
 E994 | 36                        psha                          ; ..onto the stack
 E995 | 8D 07                     bsr       LE99E               ; push left operand (FPA0) onto the stack
 E997 | D6 B9                     ldab      RELOPS              ; ACCB = relational operation flags
 E999 | 20 86                     bra       LE921               ; go evaluate next expression term
      | 
 E99B | 7E EA 3C        LE99B     jmp       SYNERR              ; ?SN ERROR
      | 
      |                 * Push expression value (sign byte, mantissa and exponent of FPA0) onto the stack.
      |                 * Returns with exponent in ACCB and operation precedence in ACCA.
 E99E | D6 CE           LE99E     ldab      FP0SGN              ; load sign byte into ACCB
 E9A0 | A6 00                     ldaa      ,X                  ; ACCA = operation precedence flag
      | 
      |                 * Push the sign byte in ACCB along with the mantissa and exponent of FPA0 onto the stack.
      |                 * Returns with exponent of FPA0 in ACCB.  ACCA is preserved.
 E9A2 | 38              LE9A2     pulx                          ; pull return address into X
 E9A3 | 37                        pshb                          ; push sign byte
      | 
      |                 * Push mantissa and exponent of FPA0 onto the stack.
      |                 * Must enter with a return address in X.
      |                 * Returns with exponent of FPA0 in ACCB.  ACCA is preserved.
 E9A4 | D6 CD           LE9A4     ldab      FPA0+3              ; push mantissa byte 0
 E9A6 | 37                        pshb
 E9A7 | D6 CC                     ldab      FPA0+2              ; push mantissa byte 1
 E9A9 | 37                        pshb
 E9AA | D6 CB                     ldab      FPA0+1              ; push mantissa byte 2
 E9AC | 37                        pshb
 E9AD | D6 CA                     ldab      FPA0                ; push mantissa byte 3
 E9AF | 37                        pshb
 E9B0 | D6 C9                     ldab      FP0EXP              ; push exponent (and return in ACCB)
 E9B2 | 37                        pshb
 E9B3 | 6E 00                     jmp       ,X                  ; return to address passed in X
      | 
      |                 * Expected an operator but got something else (end of expression)
 E9B5 | CE 00 00        LE9B5     ldx       #0                  ; use NIL for operation dispatch pointer
 E9B8 | 32                        pula                          ; ACCA = top operation precedence
 E9B9 | 4D                        tsta                          ; test top operation precedence
 E9BA | 27 26                     beq       LE9E2               ; branch if no operations on the stack
      | 
      |                 * Perform top operation on the stack.
      |                 * At this point, the right operand is in FPA0 and the stack contains:
      |                 *   Relational operation flags
      |                 *   Left operand (6 bytes)
      |                 *   Address of operation handler routine
      |                 *
 E9BC | 81 64           LE9BC     cmpa      #$64                ; relational precedence?
 E9BE | 27 03                     beq       LE9C3               ; branch if relational operation
 E9C0 | BD E9 0E                  jsr       LE90E               ; issue a ?TM ERROR if value is not numeric
 E9C3 | DF B7           LE9C3     stx       OPSAVE              ; save pointer to parsed operator entry
 E9C5 | 33              LE9C5     pulb                          ; pop relational operation flags
 E9C6 | 81 5A                     cmpa      #$5A                ; unary NOT precedence?
 E9C8 | 27 1A                     beq       LE9E4               ; branch if unary NOT operation
 E9CA | 81 7D                     cmpa      #$7D                ; unary minus precedence?
 E9CC | 27 16                     beq       LE9E4               ; branch if unary minus operation
 E9CE | 54                        lsrb                          ; set carry if string compare operation
 E9CF | D7 88                     stab      RELFLG              ; store relational operation flags
 E9D1 | 32                        pula                          ; pull the..
 E9D2 | 33                        pulb                          ; ..left..
 E9D3 | DD D6                     std       FP1EXP              ; ..operand.
 E9D5 | 38                        pulx                          ; ..off of..
 E9D6 | DF D8                     stx       FPA1+1              ; ..the stack..
 E9D8 | 33                        pulb                          ; ..and into..
 E9D9 | D7 DA                     stab      FPA1+3              ; ..FPA1
 E9DB | 33                        pulb                          ; pull sign byte into ACCB
 E9DC | D7 DB                     stab      FP1SGN              ; store in FPA1
 E9DE | D8 CE                     eorb      FP0SGN              ; compare signs of FPA1 and FPA0
 E9E0 | D7 DC                     stab      RESSGN              ; save potential sign of result
 E9E2 | D6 C9           LE9E2     ldab      FP0EXP              ; ACCB = right operand exponent
 E9E4 | 39              LE9E4     rts                           ; jump to operation handler
      | 
      |                 * Evaluate an expression term (or sub-expression)
 E9E5 | BD 42 94        LE9E5     jsr       RVEC6               ; call extension hook
 E9E8 | 7F 00 84                  clr       VALTYP              ; set type to numeric
 E9EB | 8D 4C                     bsr       LEA39               ; parse next character
 E9ED | 24 03                     bcc       LE9F2               ; branch if not a number
 E9EF | 7E F3 59        LE9EF     jmp       LF359               ; go parse FP number into FPA0 and return
      | 
 E9F2 | BD EB 76        LE9F2     jsr       LEB76               ; is it an alpha character?
 E9F5 | 24 52                     bcc       LEA49               ; branch if alpha
 E9F7 | 81 2E                     cmpa      #'.                 ; '.' ?
 E9F9 | 27 F4                     beq       LE9EF               ; branch if decimal point
 E9FB | 81 A8                     cmpa      #$A8                ; token for '-' ?
 E9FD | 27 42                     beq       LEA41               ; branch if unary negation
 E9FF | 81 A7                     cmpa      #$A7                ; token for '+' ?
 EA01 | 27 E2                     beq       LE9E5               ; ignore if identity
 EA03 | 81 22                     cmpa      #'"                 ; string delimiter?
 EA05 | 26 08                     bne       LEA0F               ; branch if not a string literal
 EA07 | DE F4           LEA07     ldx       CHRPTR              ; get parser position
 EA09 | BD ED 06                  jsr       LED06               ; parse string literal onto string stack
 EA0C | 7E EF 3E                  jmp       LEF3E               ; go update parser position and return
      | 
 EA0F | 81 A4           LEA0F     cmpa      #$A4                ; is it a NOT token?
 EA11 | 26 0D                     bne       LEA20               ; branch if something else
      | 
      |                 * Unary NOT operation
 EA13 | 86 5A                     ldaa      #$5A                ; precedence value for unary NOT
 EA15 | BD E9 21                  jsr       LE921               ; evaluate unary operand expression
 EA18 | BD EB C7                  jsr       INTCNV              ; convert FP result to an integer in ACCD
 EA1B | 43                        coma                          ; perform a bitwise..
 EA1C | 53                        comb                          ; ..NOT on the result
 EA1D | 7E EC E3                  jmp       GIVABF              ; convert to floating point value in FPA0
      | 
      |                 * Function or sub-expression within paranthesis
 EA20 | 80 B1           LEA20     suba      #$B1                ; subtract token value of first function (SGN)
 EA22 | 24 31                     bcc       LEA55               ; branch if it is a function token
 EA24 | 8D 06           LEA24     bsr       LEA2C               ; issue an ?SN ERROR if not '('
 EA26 | BD E9 1A                  jsr       LE91A               ; evaluate expression within the parentheses
      | 
      |                 * Issue an ?SN ERROR if current parse character/token is not what was expected.
 EA29 | C6 29           LEA29     ldab      #')                 ; check for ')'
 EA2B | 8C                        fcb       SKP2                ; skip next instruction
 EA2C | C6 28           LEA2C     ldab      #'(                 ; check for '('
 EA2E | 8C                        fcb       SKP2                ; skip next instruction
 EA2F | C6 2C           SYNCOM    ldab      #',                 ; check for ','
 EA31 | 3C              LEA31     pshx                          ; save X on the stack
 EA32 | DE F4                     ldx       CHRPTR              ; point X to current parse character/token
 EA34 | E1 00                     cmpb      ,X                  ; is it the expected character/token?
 EA36 | 38                        pulx                          ; restore X
 EA37 | 26 03                     bne       SYNERR              ; go issue ?SN ERROR if unexpected character
 EA39 | 7E 00 EB        LEA39     jmp       CHRGET              ; consume the character and return
      | 
 EA3C | C6 02           SYNERR    ldab      #SN_ERR             ; code for ?SN ERROR
 EA3E | 7E E2 38                  jmp       ERRGEN              ; go issue the error
      | 
      |                 * Unary Minus operation
 EA41 | 86 7D           LEA41     ldaa      #$7D                ; precedence value
 EA43 | BD E9 21                  jsr       LE921               ; evaluate the unary operand expression
 EA46 | 7E F5 93                  jmp       LF593               ; go invert the sign of FPA0 and return
      | 
      |                 * Variable term
 EA49 | BD EB 1B        LEA49     jsr       LEB1B               ; lookup variable in table
 EA4C | DF CC           LEA4C     stx       FPA0+2              ; save descriptor pointer in FPA0
 EA4E | 96 84                     ldaa      VALTYP              ; check the variable type
 EA50 | 26 92                     bne       LE9E4               ; branch if string variable
 EA52 | 7E F2 51                  jmp       LDFPA0              ; load variable's value into FPA0 and return
      | 
      |                 * Function term
 EA55 | 16              LEA55     tab                           ; copy function index to ACCB
 EA56 | 58                        aslb                          ; multiplied by 2 = dispatch table offset
 EA57 | 8D E0                     bsr       LEA39               ; parse next character
 EA59 | 37                        pshb                          ; save dispatch table offset on stack
 EA5A | C1 22                     cmpb      #$22                ; if function takes a single numeric or..
 EA5C | 25 21                     blo       LEA7F               ; ..string argument (< LEFT$) then branch
 EA5E | C1 2C                     cmpb      #$2C                ; if function does not take any..
 EA60 | 24 1F                     bcc       LEA81               ; ..arguments (INKEY$ or MEM) then branch
 EA62 | 8D C8                     bsr       LEA2C               ; syntax check for '('
 EA64 | 33                        pulb                          ; pull dispatch table offset into ACCB
 EA65 | C1 28                     cmpb      #$28                ; if function evaluates the first argument..
 EA67 | 24 19                     bcc       LEA82               ; ..on its own (POINT or VARPTR) then branch
      | 
      |                 * At this point, the function is either LEFT$, RIGHT$ or MID$
 EA69 | 37                        pshb                          ; save dispatch table offset on stack
 EA6A | BD E9 1A                  jsr       LE91A               ; evaluate first argument (string)
 EA6D | 8D C0                     bsr       SYNCOM              ; syntax check for comma ','
 EA6F | BD E9 0F                  jsr       LE90F               ; issue ?TM ERROR if first argument not a string
 EA72 | 32                        pula                          ; pull dispatch table offset into ACCA
 EA73 | DE CC                     ldx       FPA0+2              ; point X to the string descriptor
 EA75 | 3C                        pshx                          ; push string descriptor address onto stack
 EA76 | 36                        psha                          ; save dispatch table offset on stack
 EA77 | BD EF 0D                  jsr       LEF0D               ; Evaulate 2nd argument into ACCB (0..255) 
 EA7A | 32                        pula                          ; pull dispatch table offset into ACCA
 EA7B | 37                        pshb                          ; push 2nd argument value onto stack
 EA7C | 16                        tab                           ; ACCB = dispatch table offset
 EA7D | 20 03                     bra       LEA82               ; go dispatch to the function handler
      | 
      |                 * Evaluate a function's only argument
 EA7F | 8D A3           LEA7F     bsr       LEA24               ; evaluate an expression enclosed in paranthesis
      | 
      |                 * Dispatch to function handler
 EA81 | 33              LEA81     pulb                          ; pull dispatch table offset into ACCB
 EA82 | CE E0 00        LEA82     ldx       #FNTABL             ; point X to the function dispatch table
 EA85 | 3A                        abx                           ; add function offset
 EA86 | EE 00                     ldx       ,X                  ; point X to the function handler
 EA88 | AD 00                     jsr       ,X                  ; call the function handler
 EA8A | 7E E9 0E                  jmp       LE90E               ; type check for numeric function result and return
      |                                                         ; NOTE: functions returning a string do not return here
      | 
      |                 * Bitwise operations (AND, OR)
 EA8D | 86              BITOR     fcb       SKP1LDA             ; LDA #$4F and skip next intruction
 EA8E | 4F              BITAND    clra                          ; clear ACCA to indicate AND rather than OR
 EA8F | 97 82                     staa      TMPLOC              ; temp storage of AND/OR flag
 EA91 | BD EB C7                  jsr       INTCNV              ; convert FPA0 to 16 bit integer in ACCD
 EA94 | DD 80                     std       CHARAC              ; temp storage of right operand
 EA96 | BD F2 8B                  jsr       MOVFP0              ; move left operand (FPA1) to FPA0
 EA99 | BD EB C7                  jsr       INTCNV              ; convert FPA0 to 16 bit integer in ACCD
 EA9C | 7D 00 82                  tst       TMPLOC              ; AND / OR ?
 EA9F | 26 06                     bne       LEAA7               ; branch if OR
 EAA1 | 94 80                     anda      CHARAC              ; perform bitwise AND..
 EAA3 | D4 81                     andb      CHARAC+1            ; ..of the two operands
 EAA5 | 20 04                     bra       LEAAB               ; go return result
 EAA7 | 9A 80           LEAA7     oraa      CHARAC              ; perform bitwise OR..
 EAA9 | DA 81                     orab      CHARAC+1            ; ..of the two operands
 EAAB | 7E EC E3        LEAAB     jmp       GIVABF              ; convert to FP result in FPA0 and return
      | 
      | 
      |                 * Relational operation handler
      |                 * Entered with Carry set if left operand is a string
 EAAE | BD E9 10        COMPAR    jsr       LE910               ; issue ?TM ERROR if operands are different types
 EAB1 | 26 10                     bne       LEAC3               ; branch if string compare operation
 EAB3 | 96 DB                     ldaa      FP1SGN              ; get the sign byte of..
 EAB5 | 8A 7F                     oraa      #$7F                ; ..FPA1 and pack the..
 EAB7 | 94 D7                     anda      FPA1                ; ..sign into the hi-order..
 EAB9 | 97 D7                     staa      FPA1                ; ..bit of the mantissa
 EABB | CE 00 D6                  ldx       #FP1EXP             ; point X to FPA1
 EABE | BD F2 D9                  jsr       LF2D9               ; compare FPA0 with [X] (FPA1)
 EAC1 | 20 40                     bra       LEB03               ; go convert difference to TRUE or FALSE
      | 
 EAC3 | 7F 00 84        LEAC3     clr       VALTYP              ; change set value type to numeric
 EAC6 | 7A 00 B9                  dec       RELOPS              ; clear the string type bit in RELOPS
 EAC9 | BD EE 56                  jsr       LEE56               ; point X to right string data, length in ACCB
 EACC | D7 D0                     stab      STRDES              ; setup the temporary string descriptor..
 EACE | DF D2                     stx       STRDES+2            ; ..for the right operand string
 EAD0 | DE D9                     ldx       FPA1+2              ; point X to descriptor for left string
 EAD2 | BD EE 58                  jsr       LEE58               ; point X to left string data, length in ACCB
      | 
      |                 * Compare string lengths
 EAD5 | 96 D0                     ldaa      STRDES              ; get length of right string
 EAD7 | 10                        sba                           ; subtract length of left string
 EAD8 | 27 07                     beq       LEAE1               ; branch if strings have equal length
 EADA | 86 01                     ldaa      #1                  ; relational value = +1
 EADC | 24 03                     bcc       LEAE1               ; branch if right > left
 EADE | D6 D0                     ldab      STRDES              ; ACCB = length of right (shorter) string
 EAE0 | 40                        nega                          ; relational value = -1 (right < left)
 EAE1 | 97 CE           LEAE1     staa      FP0SGN              ; store result of length comparison
      | 
      |                 * Compare string characters
 EAE3 | 07                        tpa                           ; copy CC to ACCA
 EAE4 | 36                        psha                          ; save IRQ mask on stack
 EAE5 | 9F 91                     sts       STKSAV              ; save stack pointer
 EAE7 | 0F                        sei                           ; mask IRQs
 EAE8 | 35                        txs                           ; point S to left string data
 EAE9 | DE D2                     ldx       STRDES+2            ; point X to right string data
 EAEB | 5C                        incb                          ; adjust ACCB for pre-decrementing in loop
 EAEC | 09                        dex                           ; adjust X for pre-incrementing in loop
      | 
 EAED | 5A              LEAED     decb                          ; decrement character count
 EAEE | 26 04                     bne       LEAF4               ; branch if more characters to compare
 EAF0 | D6 CE                     ldab      FP0SGN              ; all chars match, use length comparison result
 EAF2 | 20 0B                     bra       LEAFF               ; break out of the loop
 EAF4 | 32              LEAF4     pula                          ; ACCA = next character from left string
 EAF5 | 08                        inx                           ; point X to next character in right string
 EAF6 | A1 00                     cmpa      ,X                  ; compare characters
 EAF8 | 27 F3                     beq       LEAED               ; loop if they are the same
      | 
 EAFA | C6 FF                     ldab      #-1                 ; relational value = -1
 EAFC | 24 01                     bcc       LEAFF               ; branch if left > right
 EAFE | 50                        negb                          ; relational value = +1 (left < right)
 EAFF | 9E 91           LEAFF     lds       STKSAV              ; restore stack pointer
 EB01 | 32                        pula                          ; pull saved IRQ mask from stack
 EB02 | 06                        tap                           ; restore IRQ mask
      | 
      |                 * Convert relational difference to TRUE or FALSE according to the operator
 EB03 | CB 01           LEB03     addb      #1                  ; convert relational value (-1,0,+1)..
 EB05 | 59                        rolb                          ; ..to an operator flag (1,2,4)
 EB06 | D4 88                     andb      RELFLG              ; AND with flags for the operation
 EB08 | 27 02                     beq       LEB0C               ; branch if relational result is FALSE
 EB0A | C6 FF                     ldab      #-1                 ; set relational result to TRUE
 EB0C | 7E F2 BC        LEB0C     jmp       LF2BC               ; return result as FP value (0,-1) in FPA0
      | 
      | 
      |                 *
      |                 * Check for subsequent array declarations in a DIM statement
 EB0F | BD EA 2F        LEB0F     jsr       SYNCOM              ; syntax check for comma ','
      | 
      | 
      |                 ***
      |                 *** DIM var(expr[,expr]...) [,var(expr[,expr]...)] ...
      |                 ***
 EB12 | 16              DIM       tab                           ; pass value for DIMFLG in ACCB (first char of name)
 EB13 | 8D 0A                     bsr       LEB1F               ; go allocate the array
 EB15 | BD 00 F3                  jsr       >CHRGOT             ; get current parse character
 EB18 | 26 F5                     bne       LEB0F               ; branch if not end of statement
 EB1A | 39                        rts                           ; return
      | 
      |                 *
      |                 * Parse an array or variable name and search the tables to locate its address.
      |                 * If the variable does not exist then it will be created (unless called from the expression evaluator).
      |                 * Returns a pointer to the variable (or ZERO) in both X and VARADR.
      |                 *
 EB1B | 5F              LEB1B     clrb                          ; clear DIM flag (this is not a DIM statement)
 EB1C | BD 00 F3                  jsr       >CHRGOT             ; get current parse character
 EB1F | D7 83           LEB1F     stab      DIMFLG              ; store DIM flag
 EB21 | 97 B1                     staa      VARNAM              ; save first character of variable name
 EB23 | BD 00 F3                  jsr       >CHRGOT             ; get current parse character (seems unnecessary)
 EB26 | 8D 4E                     bsr       LEB76               ; clear carry if character is alpha
 EB28 | 24 03                     bcc       LEB2D               ; branch if alpha
 EB2A | 7E EA 3C                  jmp       SYNERR              ; issue ?SN ERROR
      | 
 EB2D | 5F              LEB2D     clrb                          ; second character of name = none
 EB2E | D7 84                     stab      VALTYP              ; set value type to numeric
 EB30 | BD 00 EB                  jsr       >CHRGET             ; parse next character into ACCA
 EB33 | 25 04                     bcs       LEB39               ; branch if second character of name is numeric
 EB35 | 8D 3F                     bsr       LEB76               ; clear carry if second character is alpha
 EB37 | 25 0A                     bcs       LEB43               ; branch if not apha
 EB39 | 16              LEB39     tab                           ; move second character of name into ACCB
      | 
      |                 * Ignore any additional alpha or numeric characters in the variable name
 EB3A | BD 00 EB        LEB3A     jsr       >CHRGET             ; parse next character
 EB3D | 25 FB                     bcs       LEB3A               ; loop if numeric
 EB3F | 8D 35                     bsr       LEB76               ; clear carry if alpha
 EB41 | 24 F7                     bcc       LEB3A               ; loop if alpha
      | 
 EB43 | 81 24           LEB43     cmpa      #'$                 ; check for string designator
 EB45 | 26 08                     bne       LEB4F               ; branch if not a string variable
 EB47 | 73 00 84                  com       VALTYP              ; change value type to string ($FF)
 EB4A | CB 80                     addb      #$80                ; set bit 7 of second character to indicate string
 EB4C | BD 00 EB                  jsr       >CHRGET             ; get next character following '$'
      | 
 EB4F | D7 B2           LEB4F     stab      VARNAM+1            ; store second character of variable name
 EB51 | D6 86                     ldab      ARYMOD              ; get array mode flag
 EB53 | 5A                        decb                          ; if called from CLOAD* or CSAVE* then..
 EB54 | 26 03                     bne       LEB59               ; ..variable must be an existing array so..
 EB56 | 7E EC 07                  jmp       LEC07               ; ..go search the array table
      | 
 EB59 | 9B 86           LEB59     adda      ARYMOD              ; alter character value if arrays are disabled
 EB5B | 80 28                     suba      #'(                 ; if no array subscript..
 EB5D | 26 03                     bne       LEB62               ; ..specified then branch
>EB5F | 7E EB DE                  jmp       LEBDE               ; go do an array lookup
      | 
 EB62 | 7F 00 86        LEB62     clr       ARYMOD              ; clear array mode flag
 EB65 | DE 95                     ldx       VARTAB              ; point X to the variables table
 EB67 | 9C 97           LEB67     cpx       ARYTAB              ; does X point to end of variables table?
 EB69 | 27 14                     beq       LEB7F               ; branch if variable not found in table
 EB6B | DC B1                     ldd       VARNAM              ; get the two variable name characters..
 EB6D | A3 00                     subd      ,X                  ; ..and compare with name from table
 EB6F | 27 3F                     beq       LEBB0               ; branch if variable found
 EB71 | C6 07                     ldab      #7                  ; advance X to point to the..
 EB73 | 3A                        abx                           ; ..next variable in the table
 EB74 | 20 F1                     bra       LEB67               ; keep searching
      | 
      |                 * Test for an alpha character in ACCA.  Returns with Carry clear if character is alpha.
 EB76 | 81 41           LEB76     cmpa      #'A                 ; set carry if < 'A'
 EB78 | 25 04                     bcs       LEB7E               ; return if not alpha
 EB7A | 80 5B                     suba      #'Z'+1              ; set carry if..
 EB7C | 80 A5                     suba      #-('Z'+1)           ; ..char > 'Z'
 EB7E | 39              LEB7E     rts                           ; return
      | 
      |                 * Variable not found. Add it to the table unless it is only being evaluated
 EB7F | 38              LEB7F     pulx                          ; get return address in X..
 EB80 | 3C                        pshx                          ; ..but keep it on the stack
 EB81 | 8C EA 4C                  cpx       #LEA4C              ; called from expression evaluator?
 EB84 | 26 04                     bne       LEB8A               ; branch if not just evaluating
 EB86 | CE EB B7                  ldx       #ZERO               ; X = 0
 EB89 | 39                        rts                           ; return
      | 
      |                 * Insert a new variable between end of variable table and start of array table
 EB8A | DC 99           LEB8A     ldd       ARYEND              ; point ACCD to end of array table
 EB8C | DD BD                     std       SRCEND              ; set source end address for Upward Block Move
 EB8E | C3 00 07                  addd      #7                  ; add size needed for a new variable
 EB91 | DD BB                     std       DSTEND              ; set destination end address for Upward Block Move
 EB93 | DE 97                     ldx       ARYTAB              ; point X to start of array table
 EB95 | DF C1                     stx       SRCPTR              ; set source start address for Upward Block Move
 EB97 | BD E1 FE                  jsr       LE1FE               ; move arrays up to make room for the new variable
 EB9A | DE BB                     ldx       DSTEND              ; get end address of destination block
 EB9C | DF 99                     stx       ARYEND              ; set new end of array table
 EB9E | DE BF                     ldx       DSTPTR              ; get start address of destination block
 EBA0 | DF 97                     stx       ARYTAB              ; set new start of array table
 EBA2 | DE C1                     ldx       SRCPTR              ; get address for the new variable
 EBA4 | DC B1                     ldd       VARNAM              ; get the variable name..
 EBA6 | ED 00                     std       ,X                  ; ..and store it in the table
 EBA8 | 4F                        clra                          ; clear..
 EBA9 | 5F                        clrb                          ; ..accumulator D
 EBAA | ED 02                     std       2,X                 ; fill the new..
 EBAC | ED 04                     std       4,X                 ; ..variable descriptor..
 EBAE | A7 06                     staa      6,X                 ; ..with zeros
 EBB0 | 08              LEBB0     inx                           ; advance X past the variable name..
 EBB1 | 08                        inx                           ; ..so that it points to the descriptor
 EBB2 | DF B3                     stx       VARADR              ; return descriptor pointer in VARADR
 EBB4 | 39                        rts
      | 
      |                 * A packed, floating point constant containing minimum integer value (-32768)
 EBB5 | 90              MININT    fcb       $90                 ; exponent
 EBB6 | 80                        fcb       $80                 ; hi-order byte of packed mantissa
 EBB7 | 00 00           ZERO      fdb       $0000               ; middle word of mantissa (also used for ZERO constant)
 EBB9 | 00                        fcb       $00                 ; lo-order byte of mantissa
      | 
      |                 *
      |                 * Evaluate numeric expression between 0 and 32767 and return in ACCD and FPA0+2
 EBBA | BD 00 EB        LEBBA     jsr       >CHRGET             ; parse next character
 EBBD | BD E9 0C        LEBBD     jsr       LE90C               ; evaluate numeric expression into FPA0
 EBC0 | BD E9 0E        LEBC0     jsr       LE90E               ; type check for numeric value
 EBC3 | 96 CE                     ldaa      FP0SGN              ; test sign
 EBC5 | 2B 67                     bmi       ILLFNC              ; issue an ?FC ERROR if negative
      | 
      |                 * Convert FPA0 to a signed 16-bit integer at FPA0+2 and also return in ACCD
 EBC7 | BD E9 0E        INTCNV    jsr       LE90E               ; type check for numeric value
 EBCA | 96 C9                     ldaa      FP0EXP              ; get exponent
 EBCC | 81 90                     cmpa      #$90                ; test against exponent of largest integer (32768)
 EBCE | 25 08                     blo       LEBD8               ; branch if < 32768
 EBD0 | CE EB B5                  ldx       #MININT             ; point X to packed FP constant of -32768.0
 EBD3 | BD F2 D9                  jsr       LF2D9               ; compare FPA0 with [X]
 EBD6 | 26 56                     bne       ILLFNC              ; issue an ?FC ERROR if not equal
 EBD8 | BD F3 0B        LEBD8     jsr       LF30B               ; integerize the value in FPA0
 EBDB | DC CC                     ldd       FPA0+2              ; return integer value in D
 EBDD | 39              LEBDD     rts
      | 
      |                 * Process array name and subscript/dimesnioning values
 EBDE | DE 83           LEBDE     ldx       DIMFLG              ; push DIMFLG and VALTYP..
 EBE0 | 3C                        pshx                          ; ..onto the stack
 EBE1 | 5F                        clrb                          ; initialize dimension count to zero
 EBE2 | 37              LEBE2     pshb                          ; push dimension count..
 EBE3 | DE B1                     ldx       VARNAM              ; ..and the array name..
 EBE5 | 3C                        pshx                          ; ..onto the stack
 EBE6 | 8D D2                     bsr       LEBBA               ; evaluate subscript expression into FPA0+2
 EBE8 | 38                        pulx                          ; pull saved array name off the..
 EBE9 | DF B1                     stx       VARNAM              ; ..stack and back into VARNAM
 EBEB | 33                        pulb                          ; pull dimension count off stack
 EBEC | 5C                        incb                          ; increment
 EBED | D7 82                     stab      TMPLOC              ; put in temp storage
 EBEF | 32                        pula                          ; pull saved DIMFLG and VALTYP..
 EBF0 | 33                        pulb                          ; ..into ACCD
 EBF1 | DE CC                     ldx       FPA0+2              ; X = subscript value
 EBF3 | 3C                        pshx                          ; push subscript value
 EBF4 | 37                        pshb                          ; push VALTYP
 EBF5 | 36                        psha                          ; push DIMFLG
 EBF6 | D6 82                     ldab      TMPLOC              ; get dimension count
 EBF8 | BD 00 F3                  jsr       >CHRGOT             ; get current parse character
 EBFB | 81 2C                     cmpa      #',                 ; if it is a comma then..
 EBFD | 27 E3                     beq       LEBE2               ; ..loop for next dimension
 EBFF | BD EA 29                  jsr       LEA29               ; issue ?SN ERROR if not a ')'
 EC02 | 38                        pulx                          ; restore DIMFLG and VALTYP..
 EC03 | DF 83                     stx       DIMFLG              ; ..to their saved values
      | 
      |                 * Search array table.
      |                 *
      |                 * Each array in the table consists of a 5 byte header:
      |                 *    0-1:  Array name
      |                 *    2-3:  Total size of array (in bytes) including the header
      |                 *      4:  Number of dimensions in the array
      |                 *
      |                 * The header is followed by N words (2 bytes each), where N is the number of
      |                 * dimensions in the array. Each word indicates the number of elements in that dimension.
      |                 *
 EC05 | C6 FF                     ldab      #$FF                ; not doing CLOAD* or CSAVE*
 EC07 | 37              LEC07     pshb                          ; push CLOAD* / CSAVE* flag onto stack
 EC08 | DE 97                     ldx       ARYTAB              ; point X to start of array table
 EC0A | 9C 99           LEC0A     cpx       ARYEND              ; does X point to end of array table?
 EC0C | 27 25                     beq       LEC33               ; branch if array not found
 EC0E | DC B1                     ldd       VARNAM              ; get the two array name characters..
 EC10 | A3 00                     subd      ,X                  ; ..and compare with name from table
 EC12 | 27 07                     beq       LEC1B               ; branch if array found
 EC14 | EC 02                     ldd       2,X                 ; get size of array
 EC16 | BD E2 2D                  jsr       LE22D               ; advance X to point to next array (X=X+ACCD)
 EC19 | 20 EF                     bra       LEC0A               ; keep searching
      | 
      |                 * Found existing array in table
 EC1B | C6 12           LEC1B     ldab      #DD_ERR             ; error code (doubly dimensioned)
 EC1D | 32                        pula                          ; get CLOAD* / CSAVE* flag
 EC1E | 4D                        tsta                          ; if doing a CLOAD* or CSAVE* then..
 EC1F | 27 BC                     beq       LEBDD               ; ..return with array address in X
 EC21 | 96 83                     ldaa      DIMFLG              ; if this is a DIM statement..
 EC23 | 26 0B                     bne       LEC30               ; ..then issue a ?DD ERROR
 EC25 | D6 82                     ldab      TMPLOC              ; get subscript dimension count
 EC27 | E1 04                     cmpb      4,X                 ; if number of subscript dimensions matches..
 EC29 | 27 5C                     beq       LEC87               ; ..number defined for the array then branch
 EC2B | C6 10           BADSUB    ldab      #BS_ERR             ; error code (Bad Subscript)
 EC2D | 8C                        fcb       SKP2                ; skip next instruction
      | 
 EC2E | C6 08           ILLFNC    ldab      #FC_ERR             ; error code (Illegal Function)
 EC30 | 7E E2 38        LEC30     jmp       ERRGEN              ; issue the error
      | 
      |                 * Array not found in table.
      |                 * X now points to the end of the array table where a new array can be added.
 EC33 | 32              LEC33     pula                          ; get CLOAD* / CSAVE* flag
 EC34 | 4D                        tsta                          ; if doing a CLOAD* or CSAVE* ..
 EC35 | 27 F7                     beq       ILLFNC              ; ..then issue an ?FC ERROR
 EC37 | CC 00 05                  ldd       #5                  ; initialize array size accumulator..
 EC3A | DD DE                     std       OUTPTR              ; ..to five (size of one item)
 EC3C | DC B1                     ldd       VARNAM              ; get the array name characters..
 EC3E | ED 00                     std       ,X                  ; ..and store at end of table
 EC40 | D6 82                     ldab      TMPLOC              ; get number of dimensions..
 EC42 | E7 04                     stab      4,X                 ; ..and store in table
 EC44 | BD E2 1A                  jsr       LE21A               ; ?OM ERROR if not enough memory for dimensions
 EC47 | DF BB                     stx       DSTEND              ; temp storage of array address
 EC49 | C6 0B           LEC49     ldab      #11                 ; the default size for an array dimension..
 EC4B | 4F                        clra                          ; ..is 11 which allows for X(0) to X(10)
 EC4C | 7D 00 83                  tst       DIMFLG              ; if not in a DIM statement..
 EC4F | 27 05                     beq       LEC56               ; ..then branch
 EC51 | 32                        pula                          ; pull dimension size off..
 EC52 | 33                        pulb                          ; ..the stack into ACCD
 EC53 | C3 00 01                  addd      #1                  ; add 1 to include X(0)
 EC56 | ED 05           LEC56     std       5,X                 ; store dimension size in table
 EC58 | 8D 5F                     bsr       LECB9               ; multiply array size accumulator by dimension size
 EC5A | DD DE                     std       OUTPTR              ; store new array size accumulator
 EC5C | 08                        inx                           ; increment X to point to..
 EC5D | 08                        inx                           ; ..next dimension size word (-5)
 EC5E | 7A 00 82                  dec       TMPLOC              ; decrement dimension count
 EC61 | 26 E6                     bne       LEC49               ; loop if more dimensions
      | 
 EC63 | BD E2 2D                  jsr       LE22D               ; ACCD + X --> ACCD,X (end of array - 5)
 EC66 | 24 03                     bcc       LEC6B               ; branch if <= $FFFF
 EC68 | 7E E2 36                  jmp       LE236               ; issue an ?OM ERROR
 EC6B | BD E2 1E        LEC6B     jsr       LE21E               ; issue ?OM ERROR if not enough free memory
 EC6E | 83 00 35                  subd      #STKBUF-5           ; ACCD = end of array (STKBUF was added in above call)
 EC71 | DD 99                     std       ARYEND              ; set new end of array table
 EC73 | 4F                        clra                          ; use zero for initializing
 EC74 | 09              LEC74     dex                           ; decrement initializer pointer
 EC75 | A7 05                     staa      5,X                 ; initialize one byte of the new array
 EC77 | 9C 89                     cpx       TMPTR1              ; reached bottom of array data?
 EC79 | 26 F9                     bne       LEC74               ; loop if more to initialize
      | 
 EC7B | DE BB                     ldx       DSTEND              ; point X to the array header
 EC7D | 96 99                     ldaa      ARYEND              ; point ACCD to end of array
 EC7F | 93 BB                     subd      DSTEND              ; compute total size of array
 EC81 | ED 02                     std       2,X                 ; save total size in header
 EC83 | 96 83                     ldaa      DIMFLG              ; if this is a DIM statement then..
 EC85 | 26 31                     bne       LECB8               ; ..return because we are all done
      | 
      |                 * Calculate the address of the referenced array element
 EC87 | E6 04           LEC87     ldab      4,X                 ; get number of dimensions
 EC89 | D7 82                     stab      TMPLOC              ; put dimension count in temp storage
 EC8B | 4F                        clra                          ; initialize physical..
 EC8C | 5F                        clrb                          ; ..element index to zero
 EC8D | DD DE           LEC8D     std       OUTPTR              ; store element index accumulator
 EC8F | 32                        pula                          ; pull one subscript..
 EC90 | 33                        pulb                          ; ..argument from the stack
 EC91 | DD CC                     std       FPA0+2              ; temporary save in FPA0
 EC93 | 37                        pshb                          ; push subscript argument..
 EC94 | 36                        psha                          ; ..back onto stack
 EC95 | A3 05                     subd      5,X                 ; compare with dimension size
 EC97 | 24 3F                     bcc       LECD8               ; go issue ?BS ERROR if out of range
 EC99 | DC DE                     ldd       OUTPTR              ; test current value of index accumulator
 EC9B | 32                        pula                          ; pull subscript argument..
 EC9C | 33                        pulb                          ; ..off the stack into ACCD
 EC9D | 27 04                     beq       LECA3               ; branch if index accumulator = 0 (first argument)
 EC9F | 8D 18                     bsr       LECB9               ; ACCD = index accumulator * dimension size
 ECA1 | D3 CC                     addd      FPA0+2              ; add subscript argument
 ECA3 | 08              LECA3     inx                           ; increment X to point to..
 ECA4 | 08                        inx                           ; ..next dimension size word (-5)
 ECA5 | 7A 00 82                  dec       TMPLOC              ; decrement dimension count
 ECA8 | 26 E3                     bne       LEC8D               ; loop if more subscript arguments
      | 
 ECAA | DD 89                     std       TMPTR1              ; temp storage of physical element index
 ECAC | 05                        asld                          ; multiply physical index..
 ECAD | 05                        asld                          ; ..by five (element size)..
 ECAE | D3 89                     addd      TMPTR1              ; ..to get the element offset
 ECB0 | C3 00 05                  addd      #5                  ; add 5 to compensate for header size
 ECB3 | BD E2 2D                  jsr       LE22D               ; add total offset to X
 ECB6 | DF B3                     stx       VARADR              ; return with element ptr in VARADR
 ECB8 | 39              LECB8     rts                           ; return
      | 
      | 
      |                 * Multiply size of one dimension (at 5,X) by the array size/index accumulator (at OUTPTR).
      |                 * Return the product in ACCD.
 ECB9 | 86 10           LECB9     ldaa      #16                 ; number of shifts needed for multiply
 ECBB | 97 BF                     staa      FPA4                ; store shift counter
 ECBD | EC 05                     ldd       5,X                 ; get size of dimension
 ECBF | DD 91                     std       STKSAV              ; store multiplier
 ECC1 | 4F                        clra                          ; initialize product..
 ECC2 | 5F                        clrb                          ; ..accumulator to zero
 ECC3 | 05              LECC3     asld                          ; shift product accumulator
 ECC4 | 25 12                     bcs       LECD8               ; issue ?BS ERROR if > $FFFF
 ECC6 | 78 00 DF                  asl       OUTPTR+1            ; shift multiplicand..
 ECC9 | 79 00 DE                  rol       OUTPTR              ; ..one bit to the left
 ECCC | 24 04                     bcc       LECD2               ; branch if no carry
 ECCE | D3 91                     addd      STKSAV              ; add multiplier to product accumualtor
 ECD0 | 25 06                     bcs       LECD8               ; issue ?BS ERROR if > $FFFF
 ECD2 | 7A 00 BF        LECD2     dec       FPA4                ; decrement shift counter
 ECD5 | 26 EC                     bne       LECC3               ; loop until completed
 ECD7 | 39                        rts                           ; return
      | 
      |                 * Branch Island for a ?BS ERROR
 ECD8 | 7E EC 2B        LECD8     jmp       BADSUB              ; go issue a ?BS ERROR
      | 
      | 
      |                 ***
      |                 *** MEM
      |                 ***
      |                 * NOTE: This function fails to exclude the size of the stack cushion (#STKBUF)
 ECDB | 9F 91           FRMEM     sts       STKSAV              ; move current stack ptr..
 ECDD | DC 91                     ldd       STKSAV              ; ..to ACCD and subtract last..
 ECDF | 93 99                     subd      ARYEND              ; ..address used by program/variables
 ECE1 | 21                        fcb       SKP1                ; skip next instruction
      | 
      |                 * Convert unsigned 8 bit integer in ACCB to FP number in FPA0
 ECE2 | 4F              LECE2     clra                          ; unsigned extension of ACCB to ACCD
      | 
      |                 * Convert signed 16 bit integer in ACCD to floating point in FPA0.
 ECE3 | 7F 00 84        GIVABF    clr       VALTYP              ; set value type to numeric
 ECE6 | DD CA                     std       FPA0                ; store integer in high word of FPA0 mantissa
 ECE8 | C6 90                     ldab      #$90                ; ACCB = pre-normalization exponent for 16 bit int
 ECEA | 7E F2 C3                  jmp       LF2C3               ; go normalize FPA0 and return
      | 
      | 
      |                 ***
      |                 *** STR$ (number)
      |                 ***
 ECED | BD E9 0E        STRSTR    jsr       LE90E               ; issue ?TM ERROR if argument is not numeric
 ECF0 | CE 43 34                  ldx       #MOVSTR             ; point X to temporary string buffer
 ECF3 | BD F4 29                  jsr       LF429               ; convert number in FPA0 to a string
 ECF6 | 38                        pulx                          ; pop return address off the stack
 ECF7 | CE 43 33                  ldx       #MOVSTR-1           ; point X to temporary string buffer (-1)
 ECFA | 20 0A                     bra       LED06               ; go move data to string space, push descriptor and return
      | 
      | 
      |                 * Setup the temporary string descriptor to reference ACCB bytes of newly allocated string space
 ECFC | DF C7           LECFC     stx       DESPTR              ; save original value of X for caller
 ECFE | 8D 5F           LECFE     bsr       LED5F               ; allocate string space for ACCB bytes
 ED00 | DF D2           LED00     stx       STRDES+2            ; store the string data pointer and..
 ED02 | D7 D0                     stab      STRDES              ; ..length in temporary descriptor
 ED04 | 39                        rts                           ; return
      | 
      |                 * Scan a string literal pointed to by X
 ED05 | 09              LED05     dex                           ; backup one character
      | 
      |                 * Scan a string literal pointed to by X+1
 ED06 | 86 22           LED06     ldaa      #'"                 ; use string delimiter (") for..
 ED08 | 97 80                     staa      CHARAC              ; ..both terminating
 ED0A | 97 81                     staa      ENDCHR              ; ..characters
      | 
      |                 * Scan string data starting at X+1 until a null terminator, CHARAC or ENDCHR is encountered.
      |                 * Place a descriptor for the string data onto the string stack.
      |                 * If the string data is located at or below MOVSTR then the data will be moved into string space.
 ED0C | 08              LED0C     inx                           ; start at X+1
 ED0D | DF DC                     stx       RESSGN              ; temp storage of start address
 ED0F | DF D2                     stx       STRDES+2            ; also store in temporary string descriptor
 ED11 | C6 FF                     ldab      #-1                 ; initial length = -1
 ED13 | 5C              LED13     incb                          ; increment length
 ED14 | A6 00                     ldaa      ,X                  ; examine next character
 ED16 | 27 0E                     beq       LED26               ; branch if null terminator
 ED18 | 08                        inx                           ; advance pointer
 ED19 | 91 80                     cmpa      CHARAC              ; does it match first terminator?
 ED1B | 27 04                     beq       LED21               ; branch if end
 ED1D | 91 81                     cmpa      ENDCHR              ; does it match second terminator?
 ED1F | 26 F2                     bne       LED13               ; continue if not at end
      | 
 ED21 | 81 22           LED21     cmpa      #'"                 ; terminated by string delimiter?
 ED23 | 27 01                     beq       LED26               ; consume string delimiter and branch
 ED25 | 09                        dex                           ; don't consume if not a string delimiter
 ED26 | DF DE           LED26     stx       OUTPTR              ; save pointer to end of string data
 ED28 | D7 D0                     stab      STRDES              ; save length in temporary string descriptor
 ED2A | 37                        pshb                          ; push length onto stack
 ED2B | DC DC                     ldd       RESSGN              ; get starting address of the data
 ED2D | 83 43 34                  subd      #MOVSTR             ; should data be moved to string space?
 ED30 | 33                        pulb                          ; pull length from stack
 ED31 | 22 07                     bhi       LED3A               ; branch if string space allocation not needed
 ED33 | 8D C7                     bsr       LECFC               ; call string space allocator
 ED35 | DE DC                     ldx       RESSGN              ; point X to start of data
 ED37 | BD EE 3A                  jsr       LEE3A               ; copy ACCB bytes from X to allocated string space
      | 
      |                 * Push the temporary string descriptor at STRDES onto the string stack
 ED3A | FE 42 3D        LED3A     ldx       SDSPTR              ; get string stack pointer
 ED3D | 8C 42 50                  cpx       #STRSTK+(NMSTRS*5)  ; is the string stack full?
 ED40 | 26 05                     bne       LED47               ; branch if not full
 ED42 | C6 1E                     ldab      #ST_ERR             ; code for ?ST ERROR
 ED44 | 7E E2 38        LED44     jmp       ERRGEN              ; issue the error
      | 
 ED47 | 96 D0           LED47     ldaa      STRDES              ; copy the temporary
 ED49 | A7 00                     staa      ,X                  ; ..string descriptor to..
 ED4B | DC D2                     ldd       STRDES+2            ; ..the current slot..
 ED4D | ED 02                     std       2,X                 ; ..on the string stack
 ED4F | 86 FF                     ldaa      #$FF                ; set the current..
 ED51 | 97 84                     staa      VALTYP              ; ..value type to String
 ED53 | FF 42 3F                  stx       TOPSTR              ; save pointer to string stack descriptor
 ED56 | DF CC                     stx       FPA0+2              ; also save in FPA0
 ED58 | C6 05                     ldab      #5                  ; 5 bytes per descriptor
 ED5A | 3A                        abx                           ; increment string stack pointer
 ED5B | FF 42 3D                  stx       SDSPTR              ; save new string stack pointer
 ED5E | 39                        rts                           ; return
      | 
      | ee55                *
      |                 * Allocate some string space.  Pass number of bytes to allocate in ACCB.
      |                 * Returns pointer to allocated string space in X and FRESPC.
 ED5F | 7F 00 85        LED5F     clr       TMPFLG              ; clear the 'Already Compacted' flag
 ED62 | 37              LED62     pshb                          ; push string length onto stack
 ED63 | 4F                        clra                          ; ACCD = 16 bit string length
 ED64 | DD 89                     std       TMPTR1              ; store 16 bit string length
 ED66 | DC 9D                     ldd       STRTAB              ; ACCD = string space allocation pointer
 ED68 | 93 89                     subd      TMPTR1              ; subtract size needed for allocation
 ED6A | 93 9B                     subd      FRETOP              ; subtract bottom of string space
 ED6C | 25 0B                     bcs       LED79               ; branch if not enough string space available
 ED6E | D3 9B                     addd      FRETOP              ; add bottom of string space back in 
 ED70 | DD 9D                     std       STRTAB              ; store new string space allocation pointer
 ED72 | DE 9D                     ldx       STRTAB              ; X = string space allocation pointer
 ED74 | 08                        inx                           ; point X to first char of newly allocated space
 ED75 | DF 9F                     stx       FRESPC              ; return pointer to allocated string space in FRESPC
 ED77 | 33                        pulb                          ; restore string length to ACCB
 ED78 | 39                        rts                           ; return
      | 
 ED79 | C6 1A           LED79     ldab      #OS_ERR             ; code for ?OS ERROR
 ED7B | 73 00 85                  com       TMPFLG              ; toggle the 'Already Compacted' flag
 ED7E | 27 C4                     beq       LED44               ; issue error if we have already compacted
 ED80 | 8D 03                     bsr       LED85               ; compact the string space
 ED82 | 33                        pulb                          ; restore string length to ACCB
 ED83 | 20 DD                     bra       LED62               ; go try allocation again
      | 
      |                 *
      |                 * Compact the string space
 ED85 | DE A1           LED85     ldx       MEMSIZ              ; point X to end of string space
 ED87 | DF 9D           LED87     stx       STRTAB              ; set new string space allocation pointer
 ED89 | 4F                        clra                          ; clear..
 ED8A | 5F                        clrb                          ; ..ACCD
 ED8B | DD C5                     std       HISTRD              ; 'highest string descriptor' = NIL
 ED8D | DE 9B                     ldx       FRETOP              ; set 'highest string data' address..
 ED8F | DF C1                     stx       SRCPTR              ; ..to bottom of string space
      | 
      |                 * Iterate active items in the string stack, looking for highest string
 ED91 | CE 42 41                  ldx       #STRSTK             ; point X to start of string descriptor stack
 ED94 | BC 42 3D        LED94     cpx       SDSPTR              ; compare with string stack pointer 
 ED97 | 27 04                     beq       LED9D               ; branch if no more strings on stack
 ED99 | 8D 32                     bsr       LEDCD               ; go see if it is the new 'highest string'
 ED9B | 20 F7                     bra       LED94               ; check for another stacked string
      | 
      |                 * Iterate simple variables, looking for highest string
 ED9D | DE 95           LED9D     ldx       VARTAB              ; point X to start of variables
 ED9F | 9C 97           LED9F     cpx       ARYTAB              ; if X points to start of arrays..
 EDA1 | 27 04                     beq       LEDA7               ; ..then break out of the loop
 EDA3 | 8D 22                     bsr       LEDC7               ; go see if variable is the new 'highest string'
 EDA5 | 20 F8                     bra       LED9F               ; loop to check next variable
      | 
      |                 * Iterate array variables, looking for highest string
 EDA7 | DF BB           LEDA7     stx       DSTEND              ; next array address = first array address
 EDA9 | DE BB           LEDA9     ldx       DSTEND              ; point X to next array
 EDAB | 9C 99           LEDAB     cpx       ARYEND              ; if X points to end of arrays..
 EDAD | 27 38                     beq       LEDE7               ; ..then break out of the loop
 EDAF | EC 02                     ldd       2,X                 ; ACCD = total size of array
 EDB1 | D3 BB                     addd      DSTEND              ; compute next array address
 EDB3 | DD BB                     std       DSTEND              ; save address of next array
 EDB5 | A6 01                     ldaa      1,X                 ; test 2nd byte of array name
 EDB7 | 2A F0                     bpl       LEDA9               ; branch if it is not a string array
 EDB9 | E6 04                     ldab      4,X                 ; get number of dimensions in array
 EDBB | 58                        aslb                          ; multiply by 2 (size of dimensions table)
 EDBC | CB 05                     addb      #5                  ; add size of array header
 EDBE | 3A                        abx                           ; point X to array's first element
 EDBF | 9C BB           LEDBF     cpx       DSTEND              ; if X points to start of next array..
 EDC1 | 27 E8                     beq       LEDAB               ; ..then break out of the loop
 EDC3 | 8D 08                     bsr       LEDCD               ; go see if array element is new 'highest string'
 EDC5 | 20 F8                     bra       LEDBF               ; loop to check next element of array
      | 
      |                 * Check variable's descriptor if the variable is a string
 EDC7 | A6 01           LEDC7     ldaa      1,X                 ; test string flag in 2nd byte of variable name
 EDC9 | 08                        inx                           ; advance X past the variable name..
 EDCA | 08                        inx                           ; ..so it points to value/descriptor
 EDCB | 2A 16                     bpl       LEDE3               ; branch if not a string variable
      | 
      |                 * Check the string descriptor pointed to by X to see if its data address is within unallocated
      |                 * string space and is the highest address found so far.  Records the descriptor address in HISTRD
      |                 * and the data address in SRCPTR if it is the new 'highest' string.
 EDCD | E6 00           LEDCD     ldab      ,X                  ; check string length
 EDCF | 27 12                     beq       LEDE3               ; skip null strings
 EDD1 | EC 02                     ldd       2,X                 ; ACCD = address of the string data
 EDD3 | 93 9D                     subd      STRTAB              ; compare with start of allocated space
 EDD5 | 22 0C                     bhi       LEDE3               ; branch if string has already been re-allocated
 EDD7 | EC 02                     ldd       2,X                 ; ACCD = address of the string data
 EDD9 | 93 C1                     subd      SRCPTR              ; compare with highest address found so far
 EDDB | 23 06                     bls       LEDE3               ; branch if it's not the highest so far
 EDDD | DF C5                     stx       HISTRD              ; save descriptor of highest string so far
 EDDF | EC 02                     ldd       2,X                 ; ACCD = address of the string data
 EDE1 | DD C1                     std       SRCPTR              ; save highest data address found so far
 EDE3 | C6 05           LEDE3     ldab      #5                  ; advance X past the..
 EDE5 | 3A                        abx                           ; ..value/descriptor
 EDE6 | 39              LEDE6     rts                           ; return
      | 
      |                 * Re-allocate string space for the 'highest' string found
 EDE7 | DE C5           LEDE7     ldx       HISTRD              ; point X to descriptor of 'highest' string
 EDE9 | 27 FB                     beq       LEDE6               ; RTS if no more strings to re-allocate
 EDEB | 4F                        clra                          ; load 16 bit string length..
 EDEC | E6 00                     ldab      ,X                  ; ..into ACCD
 EDEE | 5A                        decb                          ; adjust ACCD to contain address of..
 EDEF | D3 C1                     addd      SRCPTR              ; ..the last character in the string
 EDF1 | DD BD                     std       SRCEND              ; set source address for Upward Block Move
 EDF3 | DE 9D                     ldx       STRTAB              ; point X to first available byte of string space
 EDF5 | DF BB                     stx       DSTEND              ; set destination address for Upward Block Move
 EDF7 | BD E2 00                  jsr       LE200               ; move string data up to the new allocation address
 EDFA | DE C5                     ldx       HISTRD              ; point X to the string descriptor
 EDFC | DC BF                     ldd       DSTPTR              ; get new string data address
 EDFE | ED 02                     std       2,X                 ; update descriptor with new data address
 EE00 | DE BF                     ldx       DSTPTR              ; point X to new string data address
 EE02 | 09                        dex                           ; subtract 1
>EE03 | 7E ED 87                  jmp       LED87               ; go update allocation pointer and contine compacting
      | 
      |                 *
      |                 * String Catenation
 EE06 | DE CC           LEE06     ldx       FPA0+2              ; point X to left operand descriptor
 EE08 | 3C                        pshx                          ; save on stack
 EE09 | BD E9 E5                  jsr       LE9E5               ; evaluate next expression term
 EE0C | BD E9 0F                  jsr       LE90F               ; issue ?TM ERROR if not a string
 EE0F | 38                        pulx                          ; pull address of left operand descriptor
 EE10 | DF DC                     stx       RESSGN              ; temp storage in in FPA1
 EE12 | E6 00                     ldab      ,X                  ; ACCB = length of left string operand
 EE14 | DE CC                     ldx       FPA0+2              ; point X to right operand descriptor
 EE16 | EB 00                     addb      ,X                  ; ACCB = length of catenated string
 EE18 | 24 05                     bcc       LEE1F               ; branch if <= 255
 EE1A | C6 1C                     ldab      #LS_ERR             ; code for ?LS ERROR
 EE1C | 7E E2 38                  jmp       ERRGEN              ; go issue the error
      | 
 EE1F | BD EC FC        LEE1F     jsr       LECFC               ; allocate string space (put descriptor in STRDES)
 EE22 | DE DC                     ldx       RESSGN              ; point X to left operand descriptor
 EE24 | E6 00                     ldab      ,X                  ; ACCB = length of left string operand
 EE26 | 8D 10                     bsr       LEE38               ; copy left operand data to allocated string space
 EE28 | DE C7                     ldx       DESPTR              ; point X to right operand descriptor
 EE2A | 8D 2C                     bsr       LEE58               ; pop descriptor, point X to data, get length in ACCB
 EE2C | 8D 0C                     bsr       LEE3A               ; copy right operand data to allocated string space
 EE2E | DE DC                     ldx       RESSGN              ; point X to left operand descriptor
 EE30 | 8D 26                     bsr       LEE58               ; pop left operand descriptor
 EE32 | BD ED 3A                  jsr       LED3A               ; push catenated string descriptor onto string stack
 EE35 | 7E E9 2E                  jmp       LE92E               ; go parse another expression operator
      | 
      |                 * Copy ACCB bytes of string data whose descriptor address is in X to [FRESPC]
 EE38 | EE 02           LEE38     ldx       2,X
      | 
      |                 * Block move ACCB bytes from source [X] to destination [FRESPC].
      |                 * Return destination end +1 in X and FRESPC.
 EE3A | 07              LEE3A     tpa                           ; copy CC to ACCA
 EE3B | 36                        psha                          ; push IRQ mask state onto stack
 EE3C | 9F 91                     sts       STKSAV              ; save the stack pointer
 EE3E | 0F                        sei                           ; mask IRQs
 EE3F | 35                        txs                           ; move source pointer into S
 EE40 | DE 9F                     ldx       FRESPC              ; load destination pointer into X
 EE42 | 5C                        incb                          ; adjust byte count for pre-decrement
 EE43 | 20 04                     bra       LEE49               ; enter the loop
      | 
 EE45 | 32              LEE45     pula                          ; get one byte from source..
 EE46 | A7 00                     staa      ,X                  ; ..and store in destination
 EE48 | 08                        inx                           ; bump destination pointer
 EE49 | 5A              LEE49     decb                          ; decrement byte counter
 EE4A | 26 F9                     bne       LEE45               ; loop until finished
      | 
 EE4C | DF 9F                     stx       FRESPC              ; return end of destination (+1) in FRESPC
 EE4E | 9E 91                     lds       STKSAV              ; restore stack pointer
 EE50 | 32                        pula                          ; pull saved IRQ mask
 EE51 | 06                        tap                           ; restore old IRQ mask
 EE52 | 39                        rts                           ; return
      | 
      |                 * Pop and return the current string expression value (pointer to string data in X, length in ACCB)
 EE53 | BD E9 0F        LEE53     jsr       LE90F               ; issue a ?TM ERROR if not a string expression
 EE56 | DE CC           LEE56     ldx       FPA0+2              ; get ptr to string expression descriptor from FPA0
      | 
      |                 * Pop the string descriptor pointed to by X if it is on top of the string stack.
      |                 * Also deallocate the string's data from string space if it is located at the very bottom.
      |                 * Return a pointer to the possibly deallocated string data in X and the string length in ACCB.
 EE58 | E6 00           LEE58     ldab      ,X                  ; ACCB = string length
 EE5A | 8D 14                     bsr       LEE70               ; pop string stack if descriptor if is currently on top
 EE5C | 26 0F                     bne       LEE6D               ; branch if it was not popped
 EE5E | EE 07                     ldx       7,X                 ; point X to..
 EE60 | 09                        dex                           ; ..string data -1
 EE61 | 9C 9D                     cpx       STRTAB              ; compare with start of allocated string space
 EE63 | 26 06                     bne       LEE6B               ; branch if string data is not lowest in string space
 EE65 | 37                        pshb                          ; save string length on stack
 EE66 | D3 9D                     addd      STRTAB              ; add string length to string space..
 EE68 | DD 9D                     std       STRTAB              ; ..allocation pointer (deallocate)
 EE6A | 33                        pulb                          ; restore string length to ACCB
 EE6B | 08              LEE6B     inx                           ; point X to first character of string
 EE6C | 39                        rts                           ; return
      | 
 EE6D | EE 02           LEE6D     ldx       2,X                 ; point X to string data
 EE6F | 39                        rts                           ; return
      | 
      |                 * Pop string descriptor pointed to by X off the string stack if it is the top item.
 EE70 | BC 42 3F        LEE70     cpx       TOPSTR              ; does X point to top item on string stack?
 EE73 | 26 0C                     bne       LEE81               ; branch if not the top item
 EE75 | FF 42 3D                  stx       SDSPTR              ; update string stack pointer (next available)
 EE78 | 09                        dex                           ; subtract the size of..
 EE79 | 09                        dex                           ; ..a string descriptor (5)..
 EE7A | 09                        dex                           ; ..from X
 EE7B | 09                        dex                           ; ..
 EE7C | 09                        dex                           ; ..
 EE7D | FF 42 3F                  stx       TOPSTR              ; set pointer to new top item on string stack
 EE80 | 4F                        clra                          ; clear ACCA and set Z flag to indicate was popped
 EE81 | 39              LEE81     rts                           ; return
      | 
      |                 ***
      |                 *** LEN (string)
      |                 ***
 EE82 | 8D 03           LEN       bsr       LEE87               ; get string expression info (length in ACCB)
 EE84 | 7E EC E2        LEE84     jmp       LECE2               ; return length as floating point value in FPA0
      | 
      | 
      |                 * Extract string expression value and test its length.
      |                 * Returns pointer to string data in X and lengh in ACCB.
      |                 * Returns with the Z flag set if string length is zero.
 EE87 | 8D CA           LEE87     bsr       LEE53               ; pop string expression, get pointer and length
 EE89 | 7F 00 84                  clr       VALTYP              ; change expression value to numeric
 EE8C | 5D                        tstb                          ; set Z flag if null string
 EE8D | 39                        rts                           ; return
      | 
      | 
      |                 ***
      |                 *** CHR$ (number)
      |                 ***
>EE8E | BD EF 10        CHRSTR    jsr       LEF10               ; convert FPA0 to 8 bit integer
 EE91 | C6 01           LEE91     ldab      #1                  ; ACCB = length of string result (1)
 EE93 | BD ED 5F                  jsr       LED5F               ; allocate string space (get ptr in X)
 EE96 | 96 CD                     ldaa      FPA0+3              ; ACCA = character code
 EE98 | BD ED 00                  jsr       LED00               ; setup temporary string descriptor
 EE9B | A7 00                     staa      ,X                  ; save character in string space
 EE9D | 31              LEE9D     ins                           ; pop return address..
 EE9E | 31                        ins                           ; ..off the stack
 EE9F | 7E ED 3A        LEE9F     jmp       LED3A               ; push descriptor onto string stack and return
      | 
      | 
      |                 ***
      |                 *** ASC (string)
      |                 ***
 EEA2 | 8D 02           ASC       bsr       LEEA6               ; get first character of string expression in ACCB
 EEA4 | 20 DE                     bra       LEE84               ; return char as floating point value in FPA0
      | 
      |                 * Extract string expression value and issue an ?FC ERROR if it is a null string.
      |                 * Returns pointer to string data in X and first character of string in ACCB.
 EEA6 | 8D DF           LEEA6     bsr       LEE87               ; get string expression info (X points to data)
 EEA8 | 27 5D                     beq       LEF07               ; issue an ?FC ERROR if null string
 EEAA | E6 00                     ldab      ,X                  ; ACCB = first character of string
 EEAC | 39                        rts                           ; return
      | 
      |                 ***
      |                 *** LEFT$ (string, length)
      |                 ***
 EEAD | 8D 43           LFTSTR    bsr       LEEF2               ; parse the ')' and retrieve arguments
 EEAF | 4F                        clra                          ; LEFT$ always uses 0 for start offest
      | 
      |                 * Extract a sub-string from the string whose descriptor is pointed to by X.
      |                 * The sub-string starts at the offset specified in ACCA and has the length specified in ACCB.
 EEB0 | E1 00           LEEB0     cmpb      ,X                  ; compare length argument to string length
 EEB2 | 23 03                     bls       LEEB7               ; branch if argument <= string length
 EEB4 | E6 00                     ldab      ,X                  ; use actual string length instead..
 EEB6 | 4F                        clra                          ; ..and force starting offset to 0
 EEB7 | 37              LEEB7     pshb                          ; save length argument and..
 EEB8 | 36                        psha                          ; ..starting offset on the stack
 EEB9 | BD EC FE                  jsr       LECFE               ; allocate space and setup descriptor for result
 EEBC | DE C7                     ldx       DESPTR              ; point X to the string argument's descriptor
 EEBE | 8D 98                     bsr       LEE58               ; pop argument descriptor, point X to string data
 EEC0 | 33                        pulb                          ; pull starting offset int ACCB
 EEC1 | 3A                        abx                           ; point X to first sub-string character
 EEC2 | 33                        pulb                          ; pull sub-string length into ACCB
 EEC3 | BD EE 3A                  jsr       LEE3A               ; copy sub-string to new string space
 EEC6 | 20 D7                     bra       LEE9F               ; go push descriptor for result and return
      | 
      |                 ***
      |                 *** RIGHT$ (string, length)
      |                 ***
 EEC8 | 8D 28           RGTSTR    bsr       LEEF2               ; parse the ')' and retrieve arguments
 EECA | A6 00                     ldaa      ,X                  ; ACCA = length of string argument
 EECC | 10                        sba                           ; calc start offset by subtracting length argument
 EECD | 20 E1                     bra       LEEB0               ; go validate length and extract sub-string
      | 
      |                 ***
      |                 *** MID$ (string, start [,length])
      |                 ***
 EECF | C6 FF           MIDSTR    ldab      #255                ; set implicit length
 EED1 | D7 CD                     stab      FPA0+3              ; store implicit length in FPA0
 EED3 | 8D 44                     bsr       LEF19               ; get current parse character
 EED5 | 81 29                     cmpa      #')                 ; is it a ')' ?
 EED7 | 27 03                     beq       LEEDC               ; branch if explicit length not provided
>EED9 | BD EF 47                  jsr       LEF47               ; parse ',' and evaluate length argument
 EEDC | 8D 14           LEEDC     bsr       LEEF2               ; parse ')' and retrieve first two arguments
 EEDE | 27 27                     beq       LEF07               ; issue an ?FC ERROR if start is zero
 EEE0 | 5F                        clrb                          ; value for length if start is out-of-range
 EEE1 | 4A                        deca                          ; adjust start to be a zero-based offset
 EEE2 | A1 00                     cmpa      ,X                  ; compare offset to length of string
 EEE4 | 24 D1                     bcc       LEEB7               ; branch if start is greater than length of string
 EEE6 | 16                        tab                           ; copy offset into ACCB
 EEE7 | E0 00                     subb      ,X                  ; maximum sub-string length =
 EEE9 | 50                        negb                          ;  -(offset - string length)
 EEEA | D1 CD                     cmpb      FPA0+3              ; is length too long?
 EEEC | 23 C9                     bls       LEEB7               ; go use maximum value if length too long
 EEEE | D6 CD                     ldab      FPA0+3              ; ACCB = length argument
 EEF0 | 20 C5                     bra       LEEB7               ; go extract sub-string
      | 
      |                 * Retrieve the first two arguments for LEFT$, RIGHT$ or MID$ from the stack.
      |                 * The pointer to the string descripor (first argument) is returned in X and DESPTR.
      |                 * The second argument (0..255) is returned in ACCA and ACCB with Z set if zero.
 EEF2 | BD EA 29        LEEF2     jsr       LEA29               ; syntax check for ')'
 EEF5 | 30                        tsx                           ; point X to stack frame
 EEF6 | EC 05                     ldd       5,X                 ; ACCD = string argument's descriptor address
 EEF8 | DD C7                     std       DESPTR              ; return descriptor address in DESPTR
      | 
 EEFA | EC 00                     ldd       ,X                  ; get return address in ACCD..
 EEFC | ED 05                     std       5,X                 ; ..move it 5 bytes higher in stack
 EEFE | 31                        ins                           ; pop the two..
 EEFF | 31                        ins                           ; ..top return..
 EF00 | 31                        ins                           ; ..addresses..
 EF01 | 31                        ins                           ; ..off the stack
 EF02 | 32                        pula                          ; ACCA = second argument value
 EF03 | DE C7                     ldx       DESPTR              ; return ptr to string descriptor in X
 EF05 | 16                        tab                           ; return 2nd argument in ACCB (and update Z)
 EF06 | 39                        rts
      | 
      |                 * Branch island for ?FC ERROR
 EF07 | 7E EC 2E        LEF07     jmp       ILLFNC              ; issue an ?FC ERROR
      | 
      | 
      |                 * Evaluate an unsigned 8 bit integer expression and return it in ACCB.
      |                 * Produces an ?FC ERROR if value not in range (0..255).
 EF0A | BD 00 EB        LEF0A     jsr       >CHRGET             ; parse next character
 EF0D | BD E9 0C        LEF0D     jsr       LE90C               ; evaluate numeric expression into FPA0
 EF10 | BD EB C0        LEF10     jsr       LEBC0               ; integerize FPA0 (also returns int in ACCD)
 EF13 | 96 CC                     ldaa      FPA0+2              ; test MSB of resulting integer (could be TSTA)
 EF15 | 26 F0                     bne       LEF07               ; issue an ?FC ERROR if value > 255
 EF17 | D6 CD                     ldab      FPA0+3              ; return result in ACCB (unnecessary instruction)
 EF19 | 7E 00 F3        LEF19     jmp       CHRGOT              ; return with current parser byte in ACCA
      | 
      | 
      |                 ***
      |                 *** VAL (string)
      |                 ***
 EF1C | BD EE 87        VAL       jsr       LEE87               ; get string expression info (X = ptr to data)
 EF1F | 26 03                     bne       LEF24               ; branch if not a null string
 EF21 | 7E EF F4                  jmp       LEFF4               ; go return 0 in FPA0
      | 
 EF24 | BD E2 2C        LEF24     jsr       LE22C               ; point X to last string character + 1
 EF27 | A6 00                     ldaa      ,X                  ; get value of byte following the string..
 EF29 | 36                        psha                          ; ..and save it on the stack
 EF2A | 6F 00                     clr       ,X                  ; add a null-terminator to the string
 EF2C | DE F4                     ldx       CHRPTR              ; get current parser position..
 EF2E | DF DE                     stx       OUTPTR              ; ..and save in OUTPTR
 EF30 | DE 89                     ldx       TMPTR1              ; set parser position to the..
 EF32 | DF F4                     stx       CHRPTR              ; ..beginning of the string
 EF34 | 8D E3                     bsr       LEF19               ; parse to the first non-space char in string
 EF36 | BD F3 59                  jsr       LF359               ; parse ASCII number into FPA0
 EF39 | 32                        pula                          ; pull old terminator byte into ACCA
 EF3A | DE 8B                     ldx       TMPTR2              ; point X to last string character + 1
 EF3C | A7 00                     staa      ,X                  ; restore original terminator
 EF3E | DE DE           LEF3E     ldx       OUTPTR              ; restore parser position..
 EF40 | DF F4                     stx       CHRPTR              ; ..to the saved value
 EF42 | 39                        rts                           ; return
      | 
      | 
      |                 * Evaluate arguments for the POKE command (16-bit address and 8-bit byte value) 
 EF43 | 8D 07           LEF43     bsr       LEF4C               ; evaluate integer expression (0..65535) into X
 EF45 | DF A5                     stx       BINVAL              ; save address in BINVAL
      | 
      |                 * Syntax check for a comma ',' then evaluate integer expression (0..255) into ACCB and return
 EF47 | BD EA 2F        LEF47     jsr       SYNCOM              ; syntax check for comma ','
 EF4A | 20 C1                     bra       LEF0D               ; go evaulate int expression and return
      | 
      |                 *
      |                 * Evaluate integer expression (0..65535) and return it in X
 EF4C | BD E9 0C        LEF4C     jsr       LE90C               ; evaluate numeric expression into FPA0
      | 
      |                 * Convert FPA0 to an unsigned 16-bit integer in X
 EF4F | 96 CE           LEF4F     ldaa      FP0SGN              ; test sign
 EF51 | 2B B4                     bmi       LEF07               ; issue an ?FC error if negative
 EF53 | 96 C9                     ldaa      FP0EXP              ; get exponent
 EF55 | 81 90                     cmpa      #$90                ; test against exponent of largest integer (65535)
 EF57 | 22 AE                     bhi       LEF07               ; issue an ?FC error if too large
 EF59 | BD F3 0B                  jsr       LF30B               ; integerize the value in FPA0
 EF5C | DE CC                     ldx       FPA0+2              ; return integer value in X
 EF5E | 39                        rts
      | 
      | 
      |                 ***
      |                 *** PEEK (address)
      |                 ***
 EF5F | 8D EE           PEEK      bsr       LEF4F               ; evaluate address argument (returned in X)
 EF61 | E6 00                     ldab      ,X                  ; read the byte at that address
 EF63 | 7E EC E2                  jmp       LECE2               ; return the byte value as FP number in FPA0
      | 
      |                 ***
      |                 *** POKE address, value
      |                 ***
 EF66 | 8D DB           POKE      bsr       LEF43               ; evaluate arguments (BINVAL = address, ACCB = value)
 EF68 | DE A5                     ldx       BINVAL              ; point X to the address
 EF6A | E7 00                     stab      ,X                  ; write value to that address
 EF6C | 39                        rts                           ; return
      | 
      | 
      |                 *****************************************************
      |                 ***         Floating Point Math Package
      |                 *****************************************************
      | 
      |                 * Add 0.5 to FPA0 leaving sum in FPA0.
 EF6D | CE F5 24        ADDHLF    ldx       #ONEHLF             ; point X to constant 0.5
 EF70 | 20 0B                     bra       LEF7D               ; go perform addition
      | 
      |                 * Subtract [X] from FPA0 leaving difference in FPA0.
 EF72 | BD F1 60        LEF72     jsr       LDFPA1              ; load [X] into FPA1
      | 
      |                 * Subtract FPA1 from FPA0 leaving difference in FPA0.
 EF75 | 73 00 CE        FPSUB     com       FP0SGN              ; invert the sign of FPA0
 EF78 | 73 00 DC                  com       RESSGN              ; invert the predicted sign of the result
 EF7B | 20 03                     bra       FPADD               ; go perform subtraction by addition
      |                   
      |                 * Add [X] to FPA0 leaving sum in FPA0.
 EF7D | BD F1 60        LEF7D     jsr       LDFPA1              ; load [X] into FPA1
      | 
      |                 * Add FPA1 to FPA0 leaving sum in FPA0.
      |                 * Enter here with exponent of FPA0 in ACCB and exponent of FPA1 in ACCA.
 EF80 | 5D              FPADD     tstb                          ; test exponent of FPA0
 EF81 | 26 03                     bne       LEF86               ; branch if not zero
 EF83 | 7E F2 8B                  jmp       MOVFP0              ; move FPA1 to FPA0 and return (0 + N = N)
 EF86 | CE 00 D6        LEF86     ldx       #FP1EXP             ; point X to FPA1
 EF89 | 16              LEF89     tab                           ; ACCB = exponent from FPA1
 EF8A | 27 6D                     beq       LEFF9               ; return if zero (N + 0 = N)
 EF8C | D0 C9                     subb      FP0EXP              ; subtract FPA0 exponent from FPA1 exponent
 EF8E | 27 6A                     beq       LEFFA               ; branch if exponents are equal
 EF90 | 2B 0A                     bmi       LEF9C               ; branch if FPA0 exponent > FPA1 exponent
 EF92 | 97 C9                     staa      FP0EXP              ; replace FPA0 exponent with FPA1 exponent
 EF94 | 96 DB                     ldaa      FP1SGN              ; replace FPA0 sign..
 EF96 | 97 CE                     staa      FP0SGN              ; ..with FPA1 sign
 EF98 | CE 00 C9                  ldx       #FP0EXP             ; point X to FPA0
 EF9B | 50                        negb                          ; ACCB = negative number of right shifts needed
 EF9C | C1 F8           LEF9C     cmpb      #-8                 ; if 8 or more shifts required then..
 EF9E | 2F 5A                     ble       LEFFA               ; ..go start by shifting whole byte
 EFA0 | 4F                        clra                          ; initialize ACCA to accept bits shifted out
 EFA1 | 64 01                     lsr       1,X                 ; do the first shift, clearing the hi-order bit
 EFA3 | BD F0 80                  jsr       LF080               ; finish shifting -ACCB bits
 EFA6 | D6 DC           LEFA6     ldab      RESSGN              ; get predicted sign of result
 EFA8 | 2A 0B                     bpl       LEFB5               ; branch if operands had equal signs
 EFAA | 63 01                     com       1,X                 ; complement all..
 EFAC | 63 02                     com       2,X                 ; ..four bytes..
 EFAE | 63 03                     com       3,X                 ; ..of the mantissa..
 EFB0 | 63 04                     com       4,X                 ; ..along with the..
 EFB2 | 43                        coma                          ; ..sub-precsion byte
 EFB3 | 89 00                     adca      #0                  ; add 1 to sub-precision byte (COMA sets carry)
 EFB5 | 97 DD           LEFB5     staa      FPSBYT              ; store sub-precision byte
 EFB7 | 96 CD                     ldaa      FPA0+3              ; add the four..
 EFB9 | 99 DA                     adca      FPA1+3              ; ..mantissa bytes..
 EFBB | 97 CD                     staa      FPA0+3              ; ..from FPA1 to..
 EFBD | 96 CC                     ldaa      FPA0+2              ; ..those of FPA0
 EFBF | 99 D9                     adca      FPA1+2              ; ..
 EFC1 | 97 CC                     staa      FPA0+2              ; ..
 EFC3 | 96 CB                     ldaa      FPA0+1              ; ..
 EFC5 | 99 D8                     adca      FPA1+1              ; ..
 EFC7 | 97 CB                     staa      FPA0+1              ; ..
 EFC9 | 96 CA                     ldaa      FPA0                ; ..
 EFCB | 99 D7                     adca      FPA1                ; ..
 EFCD | 97 CA                     staa      FPA0                ; ..
 EFCF | 17                        tba                           ; test the predicted sign
 EFD0 | 2A 47                     bpl       LF019               ; branch if operands had equal signs
 EFD2 | 25 02           LEFD2     bcs       LEFD6               ; skip negation if already positive
 EFD4 | 8D 66                     bsr       LF03C               ; make positive by negating the mantissa and sign byte
      | 
      |                 * Normalize FPA0
 EFD6 | 5F              LEFD6     clrb                          ; exponent modifier = 0
 EFD7 | 96 CA           LEFD7     ldaa      FPA0                ; get hi-order byte of mantissa
 EFD9 | 26 34                     bne       LF00F               ; branch if <> 0  (shift one bit at a time)
      | 
      |                 * Shift FPA0 mantissa left by 8 bits (whole byte at a time)
 EFDB | 96 CB                     ldaa      FPA0+1              ; byte 2 into..
 EFDD | 97 CA                     staa      FPA0                ; ..byte 3
 EFDF | 96 CC                     ldaa      FPA0+2              ; byte 1 into..
 EFE1 | 97 CB                     staa      FPA0+1              ; ..byte 2
 EFE3 | 96 CD                     ldaa      FPA0+3              ; byte 0 into..
 EFE5 | 97 CC                     staa      FPA0+2              ; ..byte 1
 EFE7 | 96 DD                     ldaa      FPSBYT              ; sub-precision byte..
 EFE9 | 97 CD                     staa      FPA0+3              ; ..into byte 0
 EFEB | 7F 00 DD                  clr       FPSBYT              ; 0 into sub-precision byte
 EFEE | CB 08                     addb      #8                  ; add 8 to the exponent modifier
 EFF0 | C1 28                     cmpb      #5*8                ; has the mantissa been cleared (shifted 40 bits)?
 EFF2 | 2D E3                     blt       LEFD7               ; loop if less than 40 bits shifted
      | 
      |                 * Set FPA0 = 0
 EFF4 | 4F              LEFF4     clra                          ; use zero for the following
 EFF5 | 97 C9           LEFF5     staa      FP0EXP              ; set new exponent for FPA0
 EFF7 | 97 CE           LEFF7     staa      FP0SGN              ; set new sign for FPA0
 EFF9 | 39              LEFF9     rts                           ; return
      | 
      |                 * Un-normalize mantissa of FPA0 by shifting to the right -ACCB positions
 EFFA | 8D 78           LEFFA     bsr       LF074               ; go shift the mantissa
 EFFC | 0C                        clc                           ; clear carry
 EFFD | 20 A7                     bra       LEFA6               ; resume addition
      | 
      |                 * Shift FPA0 mantissa left one bit at a time until the hi-order bit is set
 EFFF | 5C              LEFFF     incb                          ; increment the exponent modifier
 F000 | 78 00 DD                  asl       FPSBYT              ; shift the sub-precision byte
 F003 | 79 00 CD                  rol       FPA0+3              ; shift all..
 F006 | 79 00 CC                  rol       FPA0+2              ; ..four of..
 F009 | 79 00 CB                  rol       FPA0+1              ; ..the mantissa..
 F00C | 79 00 CA                  rol       FPA0                ; ..bytes
 F00F | 2A EE           LF00F     bpl       LEFFF               ; loop if the MS bit has not yet been set
      | 
 F011 | 96 C9                     ldaa      FP0EXP              ; get the exponent
 F013 | 10                        sba                           ; subtract exponent modifier from exponent
 F014 | 97 C9                     staa      FP0EXP              ; store modified exponent
 F016 | 23 DC                     bls       LEFF4               ; if modified exponent <= 0 then set result to 0
 F018 | 8C                        fcb       SKP2                ; skip next instruction
 F019 | 25 09           LF019     bcs       LF024               ; branch if mantissa overflow
 F01B | 78 00 DD                  asl       FPSBYT              ; carry = hi-order bit from sub-precision byte
 F01E | 86 00                     ldaa      #0                  ; clear the sub-precision..
 F020 | 97 DD                     staa      FPSBYT              ; ..byte without clearing carry
 F022 | 20 11                     bra       LF035               ; go round upward if needed
      | 
 F024 | 7C 00 C9        LF024     inc       FP0EXP              ; increment exponent (multiplies value by 2)
 F027 | 27 2F                     beq       OVRFLW              ; branch if overflow error
 F029 | 76 00 CA                  ror       FPA0                ; divide the..
 F02C | 76 00 CB                  ror       FPA0+1              ; ..mantissa in..
 F02F | 76 00 CC                  ror       FPA0+2              ; ..half to compensate..
 F032 | 76 00 CD                  ror       FPA0+3              ; ..for larger exponent
 F035 | 24 04           LF035     bcc       LF03B               ; branch if round-up not needed
 F037 | 8D 12                     bsr       LF04B               ; add one to mantissa (round-up)
 F039 | 27 E9                     beq       LF024               ; adjust exponent if rounding caused an overflow
 F03B | 39              LF03B     rts                           ; return
      | 
      |                 * Negate the sign byte and mantissa of FPA0
 F03C | 73 00 CE        LF03C     com       FP0SGN              ; negate sign byte
      | 
      |                 * Negate the mantissa of FPA0
 F03F | 73 00 CA        LF03F     com       FPA0                ; first complement..
 F042 | 73 00 CB                  com       FPA0+1              ; ..all four..
 F045 | 73 00 CC                  com       FPA0+2              ; ..bytes of..
 F048 | 73 00 CD                  com       FPA0+3              ; ..the mantissa
 F04B | DE CC           LF04B     ldx       FPA0+2              ; add 1 to the..
 F04D | 08                        inx                           ; ..low-order word..
 F04E | DF CC                     stx       FPA0+2              ; ..of FPA0 mantissa
 F050 | 26 05                     bne       LF057               ; branch if no carry needed
 F052 | DE CA                     ldx       FPA0                ; add 1 to the..
 F054 | 08                        inx                           ; ..hi-order word..
 F055 | DF CA                     stx       FPA0                ; ..of the mantissa
 F057 | 39              LF057     rts                           ; return
      | 
      |                 * Issue an Overflow Error
 F058 | C6 0A           OVRFLW    ldab      #OV_ERR             ; error code
 F05A | 7E E2 38                  jmp       ERRGEN              ; issue the error
      | 
      |                 * Multiplication enters here to shift the temporary product to the right by 8 bits (ACCB = 0)
 F05D | CE 00 8C        LF05D     ldx       #FPA2-1             ; point to temporary product in FPA2
      | 
      |                 * Right-shift the unpacked FP accumulator at X by -ACCB positions.
      |                 * Entry here begins by shifting 8 bits.
 F060 | A6 04           LF060     ldaa      4,X                 ; shift low-order byte..
 F062 | 97 DD                     staa      FPSBYT              ; ..into the sub-precision byte
 F064 | A6 03                     ldaa      3,X                 ; shift the..
 F066 | A7 04                     staa      4,X                 ; ..three higher..
 F068 | A6 02                     ldaa      2,X                 ; ..bytes into..
 F06A | A7 03                     staa      3,X                 ; ..their right..
 F06C | A6 01                     ldaa      1,X                 ; ..adjacent..
 F06E | A7 02                     staa      2,X                 ; ..bytes
 F070 | 96 D5                     ldaa      SFTSGN              ; shift sign bits..
 F072 | A7 01                     staa      1,X                 ; ..into hi-order byte
 F074 | CB 08           LF074     addb      #8                  ; subtract 8 from remaining shift count (signs reversed) 
 F076 | 2F E8                     ble       LF060               ; branch if 8 or more shitfs remaining (whole byte)
 F078 | 96 DD                     ldaa      FPSBYT              ; ACCA = sub-precision byte
 F07A | C0 08                     subb      #8                  ; any bit shifting needed ?
 F07C | 27 0C                     beq       LF08A               ; return if NO
 F07E | 67 01           LF07E     asr       1,X                 ; shift all..
 F080 | 66 02           LF080     ror       2,X                 ; ..four bytes..
 F082 | 66 03                     ror       3,X                 ; ..of mantissa..
 F084 | 66 04                     ror       4,X                 ; ..to the right
 F086 | 46                        rora                          ; shift the sub-precision byte
 F087 | 5C                        incb                          ; decrement remaining shift count (signs reversed)
 F088 | 26 F4                     bne       LF07E               ; loop if more shifts needed
 F08A | 39              LF08A     rts                           ; return
      | 
      | 
 F08B | 81 00 00 00 00  FPONE     fcb       $81,$00,$00,$00,$00 ; 1.0
      | 
 F090 | 03              LOGCOF    fcb       3
 F091 | 7F 5E 56 CB 79            fcb       $7F,$5E,$56,$CB,$79 ; 0.434255942
 F096 | 80 13 9B 0B 64            fcb       $80,$13,$9B,$0B,$64 ; 0.576584541
 F09B | 80 76 38 93 16            fcb       $80,$76,$38,$93,$16 ; 0.961800759
 F0A0 | 82 38 AA 3B 20            fcb       $82,$38,$AA,$3B,$20 ; 2.88539007
      | 
 F0A5 | 80 35 04 F3 34  SQRHLF    fcb       $80,$35,$04,$F3,$34 ; 1 / SQR(2)
 F0AA | 81 35 04 F3 34  SQRTWO    fcb       $81,$35,$04,$F3,$34 ; SQR(2)
 F0AF | 80 80 00 00 00  HEGHLF    fcb       $80,$80,$00,$00,$00 ; -0.5
 F0B4 | 80 31 72 17 F8  LNTWO     fcb       $80,$31,$72,$17,$F8 ; LN(2)
      | 
      | 
      |                 ***
      |                 *** LOG (number)
      |                 ***
 F0B9 | BD F2 AD        LOG       jsr       FPTEST              ; compare the value in FPA0 to zero
 F0BC | 2E 03                     bgt       LF0C1               ; branch if greater than 0
 F0BE | 7E EC 2E                  jmp       ILLFNC              ; less than or equal to zero produces ?FC ERROR
 F0C1 | CE F0 A5        LF0C1     ldx       #SQRHLF             ; point X to constant: 1 / SQR(2)
 F0C4 | 96 C9                     ldaa      FP0EXP              ; get argument's exponent
 F0C6 | 80 80                     suba      #$80                ; subtract off the bias
 F0C8 | 36                        psha                          ; save it on the stack
 F0C9 | 86 80                     ldaa      #$80                ; force exponent..
 F0CB | 97 C9                     staa      FP0EXP              ; ..to be 0
 F0CD | BD EF 7D                  jsr       LEF7D               ; add 1/SQR(2) to FPA0
 F0D0 | CE F0 AA                  ldx       #SQRTWO             ; point X to constant: SQR(2)
 F0D3 | BD F1 C6                  jsr       LF1C6               ; divide SQR(2) by sum in FPA0
 F0D6 | CE F0 8B                  ldx       #FPONE              ; point X to constant: 1.0
 F0D9 | BD EF 72                  jsr       LEF72               ; subtract 1 from quotient in FPA0
 F0DC | CE F0 90                  ldx       #LOGCOF             ; point X to the table of coefficients 
 F0DF | BD F5 F8                  jsr       LF5F8               ; expand the polynomial
 F0E2 | CE F0 AF                  ldx       #HEGHLF             ; point X to constant: -0.5
 F0E5 | BD EF 7D                  jsr       LEF7D               ; subtract 0.5 from FPA0
 F0E8 | 33                        pulb                          ; get argument's exponent (without bias)
 F0E9 | BD F3 E9                  jsr       LF3E9               ; add ACCB to FPA0
 F0EC | CE F0 B4                  ldx       #LNTWO              ; point X to constant: LN(2)
      | 
      |                 * Multiply FPA0 by the packed value pointed to by X and leave result in FPA0
 F0EF | 8D 6F           LF0EF     bsr       LDFPA1              ; load value pointed to by X into FPA1
      | 
      |                 * Multiply FPA0 by FPA1 and leave result in FPA0.
      |                 * Enter with FPA1's exponent in ACCA and CC.Z set if FPA0 is zero.
 F0F1 | 27 6C           FPMULT    beq       LF15F               ; return if FPA0 = 0
 F0F3 | BD F1 79                  jsr       CALEXP              ; calculate exponent for product
 F0F6 | 86 00           LF0F6     ldaa      #0                  ; initialize the four bytes of the..
 F0F8 | 97 8D                     staa      FPA2                ; ..temporary product (FPA2) to zero..
 F0FA | 97 8E                     staa      FPA2+1              ; ..
 F0FC | 97 8F                     staa      FPA2+2              ; ..  ( WHY WASN"T LDD/STD USED? )
 F0FE | 97 90                     staa      FPA2+3              ; ..
 F100 | D6 CD                     ldab      FPA0+3              ; mutiply byte 0 of FPA0..
 F102 | 8D 26                     bsr       LF12A               ; ..by FPA1
 F104 | D6 DD                     ldab      FPSBYT              ; save sub-precion byte of partial..
 F106 | F7 42 55                  stab      RNDVAL+3            ; ..result as data for RND
 F109 | D6 CC                     ldab      FPA0+2              ; mutiply byte 1
 F10B | 8D 1D                     bsr       LF12A               ; ..
 F10D | D6 DD                     ldab      FPSBYT              ; ..
 F10F | F7 42 54                  stab      RNDVAL+2            ; ..
 F112 | D6 CB                     ldab      FPA0+1              ; mutiply byte 2
 F114 | 8D 14                     bsr       LF12A               ; ..
 F116 | D6 DD                     ldab      FPSBYT              ; ..
 F118 | F7 42 53                  stab      RNDVAL+1            ; ..
 F11B | D6 CA                     ldab      FPA0                ; mutiply byte 3
 F11D | 8D 10                     bsr       LF12F               ; ..
 F11F | D6 DD                     ldab      FPSBYT              ; ..
 F121 | F7 42 52                  stab      RNDVAL              ; ..
 F124 | BD F2 48                  jsr       LF248               ; move temporary product (FPA2) into FPA0
 F127 | 7E EF D6                  jmp       LEFD6               ; go normalize FPA0 and return
      | 
      |                 * Multiply the mantissa of FPA1 by ACCB, adding result to temporary product (FPA2)
 F12A | 26 03           LF12A     bne       LF12F               ; branch if ACCB <> 0
 F12C | 7E F0 5D                  jmp       LF05D               ; just shift temp product right 8 bits and return
 F12F | 0D              LF12F     sec                           ; set carry (will be shifted through ACCB 8 times)
 F130 | 96 8D           LF130     ldaa      FPA2                ; get hi-order byte from temp product
 F132 | 56                        rorb                          ; move next bit from ACCB into carry
 F133 | 27 2A                     beq       LF15F               ; branch if completed all 8 bits
 F135 | 24 16                     bcc       LF14D               ; branch if the bit is 0
 F137 | 96 90                     ldaa      FPA2+3              ; add mantissa of FPA1 to..
 F139 | 9B DA                     adda      FPA1+3              ; ..temporary product in..
 F13B | 97 90                     staa      FPA2+3              ; ..FPA2
 F13D | 96 8F                     ldaa      FPA2+2              ; ..
 F13F | 99 D9                     adca      FPA1+2              ; ..
 F141 | 97 8F                     staa      FPA2+2              ; ..
 F143 | 96 8E                     ldaa      FPA2+1              ; ..
 F145 | 99 D8                     adca      FPA1+1              ; ..
 F147 | 97 8E                     staa      FPA2+1              ; ..
 F149 | 96 8D                     ldaa      FPA2                ; ..
 F14B | 99 D7                     adca      FPA1                ; ..
 F14D | 46              LF14D     rora                          ; shift temporary..
 F14E | 97 8D                     staa      FPA2                ; ..product in FPA2..
 F150 | 76 00 8E                  ror       FPA2+1              ; ..right one position
 F153 | 76 00 8F                  ror       FPA2+2              ; ..
 F156 | 76 00 90                  ror       FPA2+3              ; ..
 F159 | 76 00 DD                  ror       FPSBYT              ; shift low order bit into sub-precsion byte
 F15C | 0C                        clc                           ; clear carry for subsequent RORB
 F15D | 20 D1                     bra       LF130               ; loop for another bit
 F15F | 39              LF15F     rts
      | 
      |                 *
      |                 * Load a packed FP value pointed to by X into FPA1.
      |                 * Set RESSGN to the predicted sign resulting from an operation between FPA0 and FPA1.
      |                 * Return with FPA1's exponent in ACCA, FAP0's exponent in ACCB and CC reflecting ACCB.
      |                 *
 F160 | EC 01           LDFPA1    ldd       1,X                 ; ACCD = upper half of packed mantissa
 F162 | 97 DB                     staa      FP1SGN              ; unpack sign bit into sign byte
 F164 | 8A 80                     oraa      #$80                ; normalize mantissa (high order bit always set)
 F166 | DD D7                     std       FPA1                ; store upper half of mantissa in FPA1
 F168 | D6 DB                     ldab      FP1SGN              ; get sign
 F16A | D8 CE                     eorb      FP0SGN              ; exclusive-or with sign of value in FPA0
 F16C | D7 DC                     stab      RESSGN              ; save predicted sign of result (negative if different)
 F16E | EC 03                     ldd       3,X                 ; copy lower half of.. 
 F170 | DD D9                     std       FPA1+2              ; ..mantissa to FPA1
 F172 | A6 00                     ldaa      ,X                  ; ACCA = exponent from source
 F174 | 97 D6                     staa      FP1EXP              ; store exponent in FPA1
 F176 | D6 C9                     ldab      FP0EXP              ; return with exponent..
 F178 | 39                        rts                           ; ..from FPA0 in ACCB
      | 
      |                 * Calculate exponent for the product of FPA0 * FPA1.
      |                 * Enter with FPA1's exponent in ACCA.
 F179 | 4D              CALEXP    tsta                          ; if FPA1 = 0 then go pop return..
 F17A | 27 19                     beq       LF195               ; ..address, set FPA0 to 0 and return
 F17C | 9B C9                     adda      FP0EXP              ; get sum of exponents
 F17E | 46                        rora                          ; clear the overflow flag..
 F17F | 49                        rola                          ; ..if exponent out of range
 F180 | 28 13                     bvc       LF195               ; branch if overflow
 F182 | 8B 80                     adda      #$80                ; add bias to exponent
 F184 | 97 C9                     staa      FP0EXP              ; store resulting exponent
 F186 | 26 03                     bne       LF18B               ; branch if result is not 0
 F188 | 7E EF F7                  jmp       LEFF7               ; go set sign to positive and return
 F18B | 96 DC           LF18B     ldaa      RESSGN              ; use predicted..
 F18D | 97 CE                     staa      FP0SGN              ; ..sign for the result
 F18F | 39                        rts                           ; return
      | 
      |                 * If sign of FPA0 is positive then OVERFLOW else set FPA0 to zero.
 F190 | 96 CE           LF190     ldaa      FP0SGN              ; get sign of FPA0
 F192 | 43                        coma                          ; change the sign
 F193 | 20 02                     bra       LF197               ; skip next two instructions
 F195 | 32              LF195     pula                          ; pop return address..
 F196 | 32                        pula                          ; ..off the stack
 F197 | 2B 03           LF197     bmi       LF19C               ; branch if overflow error
 F199 | 7E EF F4                  jmp       LEFF4               ; go set FPA0 to 0 and return
 F19C | 7E F0 58        LF19C     jmp       OVRFLW              ; issue an ?OV ERROR
      | 
      |                 * Perform a fast multiplication of FPA0 by 10.
 F19F | BD F2 9F        LF19F     jsr       MOVFP1              ; copy FPA0 into FPA1 (returns with exponent in ACCA)
 F1A2 | 27 0F                     beq       LF1B3               ; return if FPA0 = 0
 F1A4 | 8B 02                     adda      #2                  ; add 2 to exponent (mutiplies by 4)
 F1A6 | 25 F4                     bcs       LF19C               ; branch if number will overflow
 F1A8 | 7F 00 DC                  clr       RESSGN              ; predicted sign of result is positive
 F1AB | BD EF 89                  jsr       LEF89               ; add FPA1 to FPA0 (now multiplied by 5)
 F1AE | 7C 00 C9                  inc       FP0EXP              ; add 1 to exponent (now multiplied by 10)
 F1B1 | 27 E9                     beq       LF19C               ; branch if exponent overflow
 F1B3 | 39              LF1B3     rts                           ; return
      | 
 F1B4 | 84 20 00 00 00  FPTEN     fcb       $84,$20,$00,$00,$00 ; 10.0
      | 
      |                 * Divide the number in FPA0 by 10, leaving the absolute value of the quotient in FPA0.
 F1B9 | BD F2 9F        LF1B9     jsr       MOVFP1              ; copy FPA0 into FPA1
 F1BC | CE F1 B4                  ldx       #FPTEN              ; point X to floating point constant 10.0
 F1BF | 5F                        clrb                          ; set sign of result to positive
      | 
      |                 * Divide the number in FPA1 by the packed FP value pointed to by X.
      |                 * Enter with ACCB containing the sign for the result.
 F1C0 | D7 DC           LF1C0     stab      RESSGN              ; set sign of result
 F1C2 | BD F2 51                  jsr       LDFPA0              ; load [X] into FPA0
 F1C5 | 8C                        fcb       SKP2                ; skip next instruction
      | 
      |                 * Divide the packed FP number pointed to by X by the number in FPA0.
      |                 * Leave the quotient in FPA0.
 F1C6 | 8D 98           LF1C6     bsr       LDFPA1              ; load [X] into FPA1
      | 
      |                 * Divide FPA1 by FPA0 and leave the quotient in FPA0.
      |                 * Enter with CC.Z reflecting exponent of FPA0 (divisor).
 F1C8 | 27 79           FPDIV     beq       DIVZER              ; branch if dividing by zero
 F1CA | 70 00 C9                  neg       FP0EXP              ; set reciprocal exponent for divisor
 F1CD | 8D AA                     bsr       CALEXP              ; calculate exponent for the quotient
 F1CF | 7C 00 C9                  inc       FP0EXP              ; add 1 to exponent
 F1D2 | 27 C8                     beq       LF19C               ; branch if overflow
 F1D4 | CE 00 8D                  ldx       #FPA2               ; point X to temporary result (FPA2)
 F1D7 | C6 04                     ldab      #4                  ; setup counter for..
 F1D9 | D7 82                     stab      TMPLOC              ; ..a five-byte division
 F1DB | C6 01                     ldab      #1                  ; initialize shift accumulator
      | 
      |                 * Compare mantissas. Set Carry if Divisor <= Dividend (Quotient will be >= 1)
 F1DD | 96 CA           LF1DD     ldaa      FPA0                ; compare 1st (high order) bytes
 F1DF | 91 D7                     cmpa      FPA1                ; ..
 F1E1 | 26 13                     bne       LF1F6               ; branch if mantissas not equal
 F1E3 | 96 CB                     ldaa      FPA0+1              ; compare 2nd bytes
 F1E5 | 91 D8                     cmpa      FPA1+1              ; ..
 F1E7 | 26 0D                     bne       LF1F6               ; ..
 F1E9 | 96 CC                     ldaa      FPA0+2              ; compare 3rd bytes
 F1EB | 91 D9                     cmpa      FPA1+2              ; ..
 F1ED | 26 07                     bne       LF1F6               ; ..
 F1EF | 96 CD                     ldaa      FPA0+3              ; compare 4th bytes
 F1F1 | 91 DA                     cmpa      FPA1+3              ; ..
 F1F3 | 26 01                     bne       LF1F6               ; ..
 F1F5 | 0D                        sec                           ; mantissas are equal - set carry
 F1F6 | 07              LF1F6     tpa                           ; save carry flag in ACCA
 F1F7 | 59                        rolb                          ; rotate carry into low end of shift accumulator
 F1F8 | 24 0C                     bcc       LF206               ; branch if 8 shifts not yet completed
 F1FA | E7 00                     stab      ,X                  ; save into temporary result
 F1FC | 08                        inx                           ; point to next byte of temp result
 F1FD | 7A 00 82                  dec       TMPLOC              ; decremnt byte counter
 F200 | 2B 37                     bmi       LF239               ; branch if complete
 F202 | 27 31                     beq       LF235               ; branch if final byte
 F204 | C6 01                     ldab      #1                  ; reset shift accumulator
 F206 | 06              LF206     tap                           ; was divisor mantissa <= dividend mantissa ?
 F207 | 25 12                     bcs       LF21B               ; branch if yes
 F209 | 78 00 DA        LF209     asl       FPA1+3              ; shift dividend..
 F20C | 79 00 D9                  rol       FPA1+2              ; ..mantissa one.
 F20F | 79 00 D8                  rol       FPA1+1              ; ..bit to..
 F212 | 79 00 D7                  rol       FPA1                ; ..the left
 F215 | 25 DF                     bcs       LF1F6               ; loop if carry set
 F217 | 2B C4                     bmi       LF1DD               ; if hi-order bit set then go check magnitudes
 F219 | 20 DB                     bra       LF1F6               ; carry clear - do another bit
      | 
      |                 * Subtract divisor from dividend
 F21B | 96 DA           LF21B     ldaa      FPA1+3              ; subtract 4th (low order) bytes
 F21D | 90 CD                     suba      FPA0+3              ; ..
 F21F | 97 DA                     staa      FPA1+3              ; ..
 F221 | 96 D9                     ldaa      FPA1+2              ; subtract 3rd bytes (including borrow)
 F223 | 92 CC                     sbca      FPA0+2              ; ..
 F225 | 97 D9                     staa      FPA1+2              ; ..
 F227 | 96 D8                     ldaa      FPA1+1              ; subtract 2nd bytes (including borrow)
 F229 | 92 CB                     sbca      FPA0+1              ; ..
 F22B | 97 D8                     staa      FPA1+1              ; ..
 F22D | 96 D7                     ldaa      FPA1                ; subtract 1st (hi order) bytes (including borrow)
 F22F | 92 CA                     sbca      FPA0                ; ..
 F231 | 97 D7                     staa      FPA1                ; ..
 F233 | 20 D4                     bra       LF209               ; go shift left
      | 
 F235 | C6 40           LF235     ldab      #$40                ; use only two bits of the final (5th) byte
 F237 | 20 CD                     bra       LF206               ; go shift the last two bits
      | 
 F239 | 56              LF239     rorb                          ; move Carry, bit 0..
 F23A | 56                        rorb                          ; ..and bit 1 into..
 F23B | 56                        rorb                          ; ..bits 5-7 respectively
 F23C | D7 DD                     stab      FPSBYT              ; store sub-precision byte
 F23E | 8D 08                     bsr       LF248               ; move temporary result (FPA2) into FPA0
 F240 | 7E EF D6                  jmp       LEFD6               ; go normalize FPA0 and return
      | 
      |                 * Issue a Division-by-Zero Error
 F243 | C6 14           DIVZER    ldab      #D0_ERR             ; error code
 F245 | 7E E2 38                  jmp       ERRGEN              ; go issue the error
      | 
      |                 * Copy FPA2 to the mantissa bytes of FPA0
 F248 | DE 8D           LF248     ldx       FPA2                ; copy hi-order word
 F24A | DF CA                     stx       FPA0                ; ..
 F24C | DE 8F                     ldx       FPA2+2              ; copy low-order word
 F24E | DF CC                     stx       FPA0+2              ; ..
 F250 | 39                        rts                           ; return
      | 
      |                 * Load a packed FP value pointed to by X into FPA0 (unpacked)
 F251 | 36              LDFPA0    psha                          ; preserve ACCA
 F252 | EC 01                     ldd       1,X                 ; ACCD = upper half of packed mantissa
 F254 | 97 CE                     staa      FP0SGN              ; unpack sign bit into sign byte
 F256 | 8A 80                     oraa      #$80                ; normalize mantissa (high order bit always set)
 F258 | DD CA                     std       FPA0                ; store upper half of mantissa in FPA0
 F25A | 7F 00 DD                  clr       FPSBYT              ; clear sub-byte
 F25D | E6 00                     ldab      ,X                  ; ACCB = exponent from source
 F25F | EE 03                     ldx       3,X                 ; X = lower half of source mantissa
 F261 | DF CC                     stx       FPA0+2              ; store lower half of mantissa in FPA0
 F263 | D7 C9                     stab      FP0EXP              ; store exponent in FPA0
 F265 | 32                        pula                          ; restore ACCA
 F266 | 39                        rts                           ; return
      | 
      |                 * Save a packed copy of FPA0 at FPA4
 F267 | CE 00 BF        MOVFP4    ldx       #FPA4               ; point X to FPA4
 F26A | 20 06                     bra       STFPA0              ; store FPA0 into FPA4
      | 
      |                 * Save a packed copy of FPA0 into FPA3
 F26C | CE 00 BA        MOVFP3    ldx       #FPA3               ; point X to FPA3
 F26F | 8C                        fcb       SKP2                ; skip next instruction
      | 
      |                 * Save a packed copy of FPA0 into the variable pointed to by VARDES
 F270 | DE B5           LF270     ldx       VARDES              ; point X to the variable value
      | 
      |                 * Store FPA0 at [X] (packed)
 F272 | 96 C9           STFPA0    ldaa      FP0EXP              ; copy the..
 F274 | A7 00                     staa      ,X                  ; ..exponent
 F276 | 96 CE                     ldaa      FP0SGN              ; get sign byte
 F278 | 8A 7F                     oraa      #$7F                ; set bits 0-6, leaving sign in bit 7
 F27A | 94 CA                     anda      FPA0                ; pack sign with upper 7 bits of mantissa
 F27C | A7 01                     staa      1,X                 ; store packed mantissa/sign
 F27E | 96 CB                     ldaa      FPA0+1              ; ..
 F280 | A7 02                     staa      2,X                 ; ..
 F282 | 96 CC                     ldaa      FPA0+2              ; ..copy the 3 lower..
 F284 | A7 03                     staa      3,X                 ; ..bytes of mantissa
 F286 | 96 CD                     ldaa      FPA0+3              ; ..
 F288 | A7 04                     staa      4,X                 ; ..
 F28A | 39                        rts                           ; return
      | 
      |                 *
      |                 * Copy FPA1 to FPA0, clearing the sub-precision byte.
      |                 * Returns with the sign byte in ACCA.
      |                 *
 F28B | 96 DB           MOVFP0    ldaa      FP1SGN              ; ACCA = sign byte from FPA1
 F28D | 97 CE           LF28D     staa      FP0SGN              ; set sign byte for FPA0 from ACCA
 F28F | DE D6                     ldx       FP1EXP              ; get exponent and mantissa MSB..
 F291 | DF C9                     stx       FP0EXP              ; ..from FPA1 and copy to FPA0
 F293 | 7F 00 DD                  clr       FPSBYT              ; clear the sub-precision byte
 F296 | DE D8                     ldx       FPA1+1              ; get middle mantissa bytes..
 F298 | DF CB                     stx       FPA0+1              ; ..from FPA1 and copy to FPA0
 F29A | DE D9                     ldx       FPA1+2              ; get low-order mantissa bytes..
 F29C | DF CC                     stx       FPA0+2              ; ..from FPA1 and copy to FPA0
 F29E | 39                        rts                           ; return
      | 
      |                 *
      |                 * Copy FPA0 to FPA1.
      |                 * Returns with the exponent in ACCA and CC reflecting the exponent's value.
      |                 *
 F29F | DC C9           MOVFP1    ldd       FP0EXP              ; copy the 6 bytes..
 F2A1 | DD D6                     std       FP1EXP              ; ..of FPA0..
 F2A3 | DE CB                     ldx       FPA0+1              ; ..to FPA1
 F2A5 | DF D8                     stx       FPA1+1              ; ..
 F2A7 | DE CD                     ldx       FPA0+3              ; ..
 F2A9 | DF DA                     stx       FPA1+3              ; ..
 F2AB | 4D                        tsta                          ; set CC to reflect value of exponent
 F2AC | 39                        rts                           ; return
      | 
      |                 *
      |                 * Set ACCB to indicate the sign of the value in FPA0:
      |                 *  -1 if negative
      |                 *   0 if zero
      |                 *  +1 if positive
      |                 *
 F2AD | D6 C9           FPTEST    ldab      FP0EXP              ; get exponent
 F2AF | 27 08                     beq       LF2B9               ; return if zero (FP value = 0)
 F2B1 | D6 CE           LF2B1     ldab      FP0SGN              ; get sign byte
>F2B3 | 59              LF2B3     rolb                          ; set carry if negative
 F2B4 | C6 FF                     ldab      #-1                 ; result = -1
 F2B6 | 25 01                     bcs       LF2B9               ; return if carry set (negative)
 F2B8 | 50                        negb                          ; result = 1
 F2B9 | 39              LF2B9     rts                           ; return
      | 
      | 
      |                 ***
      |                 *** SGN (number)
      |                 ***
 F2BA | 8D F1           SGN       bsr       FPTEST              ; Calculate result in ACCB (-1, 0, +1)
      | 
      |                 * Convert signed 8 bit integer in ACCB to floating point value in FPA0
 F2BC | D7 CA           LF2BC     stab      FPA0                ; store 8 bit result in high byte of FPA0 mantissa
 F2BE | 7F 00 CB                  clr       FPA0+1              ; clear third byte of FPA0 mantissa
 F2C1 | C6 88                     ldab      #$88                ; ACCB = pre-normalization exponent
      | 
      |                 * Normalize a signed integer value in the high end of FPA0 with a pre-normalized exponent in ACCB
 F2C3 | 96 CA           LF2C3     ldaa      FPA0                ; get high byte of FPA0 mantissa
 F2C5 | 80 80                     suba      #$80                ; set carry if integer is positive
 F2C7 | D7 C9           LF2C7     stab      FP0EXP              ; store pre-normalized exponent
 F2C9 | 86 00                     ldaa      #0                  ; clear ACCD without affecting..
 F2CB | 16                        tab                           ; ..the carry flag (LDD would be faster)
 F2CC | DD CC                     std       FPA0+2              ; clear low word of FPA0 mantissa
 F2CE | 97 DD                     staa      FPSBYT              ; clear sub-precision byte
 F2D0 | 97 CE                     staa      FP0SGN              ; clear FPA0 sign byte
 F2D2 | 7E EF D2                  jmp       LEFD2               ; go normalize FPA0
      | 
      | 
      |                 ***
      |                 *** ABS (number)
      |                 ***
 F2D5 | 7F 00 CE        ABS       clr       FP0SGN              ; force the sign of FPA0 to be positive
 F2D8 | 39                        rts                           ; return
      | 
      | 
      |                 *
      |                 * Compare packed FP number at [X] with value in FPA0.
      |                 * Returns result in ACCB:  0 if equal,  -1 if FPA0 < [X],  1 if FPA0 > [X].
      |                 *
 F2D9 | E6 00           LF2D9     ldab      ,X                  ; get operand exponent
 F2DB | 27 D0                     beq       FPTEST              ; branch if operand = 0
 F2DD | E6 01                     ldab      1,X                 ; get sign of operand (hi order mantissa bit)
 F2DF | D8 CE                     eorb      FP0SGN              ; are signs different?
 F2E1 | 2B CE                     bmi       LF2B1               ; branch if signs different
 F2E3 | D6 C9           LF2E3     ldab      FP0EXP              ; get exponent from FPA0
 F2E5 | E1 00                     cmpb      ,X                  ; compare with operand exponent
 F2E7 | 26 1D                     bne       LF306               ; branch if exponents differ
 F2E9 | E6 01                     ldab      1,X                 ; get MSB from operand mantissa
 F2EB | CA 7F                     orab      #$7F                ; set all bits other than the sign bit
 F2ED | D4 CA                     andb      FPA0                ; get MSB from FPA0 mantissa with packed sign bit
 F2EF | E1 01                     cmpb      1,X                 ; compare with operand MSB
 F2F1 | 26 13                     bne       LF306               ; branch if mantissa's differ
 F2F3 | D6 CB                     ldab      FPA0+1              ; compare byte 2 of mantissas
 F2F5 | E1 02                     cmpb      2,X                 ; ..
 F2F7 | 26 0D                     bne       LF306               ; ..
 F2F9 | D6 CC                     ldab      FPA0+2              ; compare byte 1 of mantissas
 F2FB | E1 03                     cmpb      3,X                 ; ..
 F2FD | 26 07                     bne       LF306               ; ..
 F2FF | D6 CD                     ldab      FPA0+3              ; compare mantissa LSB's..
 F301 | E0 04                     subb      4,X                 ; ..clearing B if equal
 F303 | 26 01                     bne       LF306               ; ..
 F305 | 39                        rts                           ; return with ACCB=0 for equality
 F306 | 56              LF306     rorb                          ; set hi-order bit of ACCB if FPA0 < [X]
 F307 | D8 CE                     eorb      FP0SGN              ; invert hi-order bit of ACCB for negative operands
 F309 | 20 A8                     bra       LF2B3               ; go set ACCB to +/- 1 and return
      | 
      |                 * Convert value in FPA0 to a 32-bit integer, leaving result in the mantissa
 F30B | D6 C9           LF30B     ldab      FP0EXP              ; check exponent
 F30D | 27 41                     beq       LF350               ; if zero then clear  mantissa and return
 F30F | C0 A0                     subb      #$A0                ; get (negative) number of shifts needed
 F311 | 96 CE                     ldaa      FP0SGN              ; check the sign byte
 F313 | 2A 06                     bpl       LF31B               ; branch if positive
 F315 | 73 00 D5                  com       SFTSGN              ; set 'shift-in' bits for negative value
 F318 | BD F0 3F                  jsr       LF03F               ; negate the mantissa
 F31B | CE 00 C9        LF31B     ldx       #FP0EXP             ; point X to FPA0 exponent
 F31E | C1 F8                     cmpb      #-8                 ; if fewer than 8 shifts needed..
 F320 | 2E 07                     bgt       LF329               ; ..then go prep for one bit at a time
 F322 | BD F0 74                  jsr       LF074               ; shift digits right by -B bits
 F325 | 7F 00 D5                  clr       SFTSGN              ; clear the sign shift bits
 F328 | 39                        rts                           ; return
      | 
 F329 | 7F 00 D5        LF329     clr       SFTSGN              ; clear the 'shift-in' bits
 F32C | 96 CE                     ldaa      FP0SGN              ; get sign byte
 F32E | 49                        rola                          ; move sign into carry
 F32F | 76 00 CA                  ror       FPA0                ; first shift to set sign bit in mantissa
 F332 | 7E F0 80                  jmp       LF080               ; do remaining shifts arithmetically then return
      | 
      |                 ***
      |                 *** INT (number)
      |                 ***
 F335 | D6 C9           INT       ldab      FP0EXP              ; get argument's exponent
 F337 | C1 A0                     cmpb      #$A0                ; if argument's absolute value is outside..
 F339 | 24 1D                     bcc       LF358               ; ..integer range (7FFFFFFF) then return
 F33B | 8D CE                     bsr       LF30B               ; shift mantissa to produce 32 bit integer
 F33D | D7 DD                     stab      FPSBYT              ; clear sub-precision byte (ACCB = 0)
 F33F | 96 CE                     ldaa      FP0SGN              ; get argument's sign
 F341 | D7 CE                     stab      FP0SGN              ; force sign to be positive
 F343 | 80 80                     suba      #$80                ; set carry if argument was positive
 F345 | 86 A0                     ldaa      #$A0                ; set exponent of FPA0..
 F347 | 97 C9                     staa      FP0EXP              ; ..to that of largest integer
 F349 | 96 CD                     ldaa      FPA0+3              ; save integer's LSB for..
 F34B | 97 80                     staa      CHARAC              ; ..use by EXP function
 F34D | 7E EF D2                  jmp       LEFD2               ; go normalize FPA0 and return
      | 
      |                 * Fill FPA0 mantissa with value in ACCB (0)
 F350 | D7 CA           LF350     stab      FPA0                ; fill all..
 F352 | D7 CB                     stab      FPA0+1              ; ..four bytes..
 F354 | D7 CC                     stab      FPA0+2              ; ..of mantissa..
 F356 | D7 CD                     stab      FPA0+3              ; ..with ACCB
 F358 | 39              LF358     rts                           ; return
      | 
      | 
      |                 *
      |                 * Parse ASCII representation of a number and convert it to a floating point value in FPA0.
      |                 * Accepts both conventional representation and scientifc notation.
      |                 *
 F359 | BD 42 9D        LF359     jsr       RVEC9               ; call extension hook
 F35C | CE 00 00                  ldx       #0                  ; initialize..
 F35F | DF CE                     stx       FP0SGN              ; ..all bytes..
 F361 | DF C9                     stx       FP0EXP              ; ..of FPA0..
 F363 | DF CB                     stx       FPA0+1              ; ..to zero..
 F365 | DF CC                     stx       FPA0+2              ; ..
 F367 | DF C1                     stx       SCIEXP              ; initialize scientific notation (E+0)
 F369 | DF BF                     stx       FRACNT              ; initialize fractional digit flag and counter
 F36B | 25 6B                     bcs       LF3D8               ; branch if numeric character
 F36D | 81 2D                     cmpa      #'-                 ; minus sign?
 F36F | 26 05                     bne       LF376               ; branch if no
 F371 | 73 00 CF                  com       COEFCT              ; toggle 'minus sign' flag ($FF = negative)
 F374 | 20 04                     bra       LF37A               ; go parse next character
 F376 | 81 2B           LF376     cmpa      #'+                 ; plus sign?
 F378 | 26 05                     bne       LF37F               ; branch if no
 F37A | BD 00 EB        LF37A     jsr       >CHRGET             ; parse next character
 F37D | 25 59                     bcs       LF3D8               ; branch if numeric
 F37F | 81 2E           LF37F     cmpa      #'.                 ; decimal point?
 F381 | 27 2D                     beq       LF3B0               ; branch if yes
 F383 | 81 45                     cmpa      #'E                 ; 'E' for scientific notation?
 F385 | 26 2E                     bne       LF3B5               ; branch if no
      | 
      |                 * Evaluate exponent for scientific notation
 F387 | BD 00 EB                  jsr       >CHRGET             ; parse next character
 F38A | 25 69                     bcs       LF3F5               ; branch if numeric
 F38C | 81 A8                     cmpa      #$A8                ; unary minus token (-) ?
 F38E | 27 0E                     beq       LF39E               ; branch if yes
 F390 | 81 2D                     cmpa      #'-                 ; minus sign?
 F392 | 27 0A                     beq       LF39E               ; branch if yes
 F394 | 81 A7                     cmpa      #$A7                ; addition token (+) ?
 F396 | 27 09                     beq       LF3A1               ; branch if yes
 F398 | 81 2B                     cmpa      #'+                 ; plus sign?
 F39A | 27 05                     beq       LF3A1               ; branch if yes
 F39C | 20 08                     bra       LF3A6               ; no sign given for exponent
 F39E | 73 00 C2        LF39E     com       EXPSGN              ; set negative exponent flag
      | 
      |                 * Parse ASCII exponent and convert to 8 bit integer in SCIEXP (overflow ignored)
 F3A1 | BD 00 EB        LF3A1     jsr       >CHRGET             ; parse next character
 F3A4 | 25 4F                     bcs       LF3F5               ; branch if numeric
 F3A6 | 7D 00 C2        LF3A6     tst       EXPSGN              ; test exponent sign flag
 F3A9 | 27 0A                     beq       LF3B5               ; branch if positive
 F3AB | 70 00 C1                  neg       SCIEXP              ; negate exponent
 F3AE | 20 05                     bra       LF3B5               ; 
      | 
 F3B0 | 73 00 C0        LF3B0     com       DECFLG              ; toggle the decimal point flag
 F3B3 | 26 C5                     bne       LF37A               ; branch if first occurence of decimal point
      | 
      |                 * Finish ASCII to floating point conversion
 F3B5 | 96 C1           LF3B5     ldaa      SCIEXP              ; get scientific notation exponent
 F3B7 | 90 BF                     suba      FRACNT              ; subtract number of fractional digits
 F3B9 | 97 C1                     staa      SCIEXP              ; store updated exponent
 F3BB | 27 14                     beq       LF3D1               ; branch if exponent is zero
 F3BD | 2A 0A                     bpl       LF3C9               ; branch if exponent is positive
      |                 * Apply negative exponent to value in FPA0
 F3BF | BD F1 B9        LF3BF     jsr       LF1B9               ; divide FPA0 by 10
 F3C2 | 7C 00 C1                  inc       SCIEXP              ; increment exponent
 F3C5 | 26 F8                     bne       LF3BF               ; loop until exponent is zero
 F3C7 | 20 08                     bra       LF3D1
      |                 * Apply positive exponent to value in FPA0
 F3C9 | BD F1 9F        LF3C9     jsr       LF19F               ; multiply FPA0 by 10
 F3CC | 7A 00 C1                  dec       SCIEXP              ; decrement exponent
 F3CF | 26 F8                     bne       LF3C9               ; loop until exponent is zero
      |                 * Negate FPA0 if a minus sign preceded the number
 F3D1 | 96 CF           LF3D1     ldaa      COEFCT              ; test the 'minus sign' flag
 F3D3 | 2A 83                     bpl       LF358               ; return if not set
 F3D5 | 7E F5 93                  jmp       LF593               ; go negate FPA0 and return
      | 
      |                 * Accumulate value of the digit
 F3D8 | D6 BF           LF3D8     ldab      FRACNT              ; get decimal point flag (-1 if encountered)
 F3DA | D0 C0                     subb      DECFLG              ; add 1 to number of fractional digits..
 F3DC | D7 BF                     stab      FRACNT              ; ..if decimal point has been encountered
 F3DE | 36                        psha                          ; save ASCII digit on the stack
 F3DF | BD F1 9F                  jsr       LF19F               ; multiply FPA0 by 10
 F3E2 | 33                        pulb                          ; pull ASCII digit into ACCB
 F3E3 | C0 30                     subb      #$30                ; convert ASCII to decimal
 F3E5 | 8D 02                     bsr       LF3E9               ; add ACCB to FPA0
 F3E7 | 20 91                     bra       LF37A               ; continue parsing
      | 
      |                 * Add 8 bit integer in ACCB to FPA0
 F3E9 | BD F2 6C        LF3E9     jsr       MOVFP3              ; copy current value of FPA0 to FPA3
 F3EC | BD F2 BC                  jsr       LF2BC               ; convert ACCB to floating point value in FPA0
 F3EF | CE 00 BA                  ldx       #FPA3               ; point X to FPA3
 F3F2 | 7E EF 7D                  jmp       LEF7D               ; compute sum in FPA0 and return
      | 
      |                 * Multiply SCIEXP by 10 then add to it the decimal value of ASCII digit in ACCA
 F3F5 | D6 C1           LF3F5     ldab      SCIEXP              ; get current value
 F3F7 | 58                        aslb                          ; multiply..
 F3F8 | 58                        aslb                          ; ..it by 4
 F3F9 | DB C1                     addb      SCIEXP              ; add original value (now multiplied by 5)
 F3FB | 58                        aslb                          ; multiply by 2 to get original value * 10
 F3FC | 80 30                     suba      #'0                 ; convert ASCII digit to decimal
 F3FE | 1B                        aba                           ; add digit's value to ACCB
 F3FF | 97 C1                     staa      SCIEXP              ; put back into memory
 F401 | 20 9E                     bra       LF3A1               ; continue parsing
      | 
 F403 | 9B 3E BC 1F FD  MAXFRA    fcb       $9B,$3E,$BC,$1F,$FD ; 99999999.9
 F408 | 9E 6E 6B 27 FD  MAXINT    fcb       $9E,$6E,$6B,$27,$FD ; 999999999
 F40D | 9E 6E 6B 28 00  BILION    fcb       $9E,$6E,$6B,$28,$00 ; 1000000000
      | 
      |                 * Output "IN linenumber" message to console.
 F412 | CE E1 B6        LF412     ldx       #IN_MSG-1           ; point X to " IN " string (-1)
 F415 | 8D 0C                     bsr       LF423               ; print to console
 F417 | DC E2                     ldd       CURLIN              ; ACCD = current line number
      | 
      |                 * Convert the 16 bit unsigned integer in ACCD to a string and print it to the console.
 F419 | DD CA           LF419     std       FPA0                ; put integer into hi-order word of FPA0 mantissa
 F41B | C6 90                     ldab      #$90                ; ACCB = pre-normalized exponent for 16 bit integer
 F41D | 0D                        sec                           ; set Carry flag to indicate a positive number
 F41E | BD F2 C7                  jsr       LF2C7               ; normalize FPA0
 F421 | 8D 03                     bsr       LF426               ; convert number to a string in STRBUF
 F423 | 7E E7 A8        LF423     jmp       STROUT
      | 
      |                 *
      |                 * Convert floating point number in FPA0 to a string in STRBUF
 F426 | CE 43 35        LF426     ldx       #STRBUF             ; point X to temporary string buffer
      | 
      |                 * Convert floating point number in FPA0 to a null-terminated string.
      |                 * Enter with X pointing to the output string buffer.
 F429 | 86 20           LF429     ldaa      #SPACE              ; first character is a space for positive numbers
 F42B | D6 CE                     ldab      FP0SGN              ; test the sign of FPA0
 F42D | 2A 02                     bpl       LF431               ; branch if positive
 F42F | 86 2D                     ldaa      #'-                 ; use minus sign as first character
 F431 | A7 00           LF431     staa      ,X                  ; put sign character into string buffer
 F433 | 97 CE                     staa      FP0SGN              ; save sign character in FPA0's sign byte
 F435 | DF DE                     stx       OUTPTR              ; use OUTPTR as temp storage for buffer start
 F437 | 08                        inx                           ; increment buffer pointer
 F438 | 86 30                     ldaa      #'0                 ; prepare for a value of zero
 F43A | D6 C9                     ldab      FP0EXP              ; test exponent of FPA0
 F43C | 26 03                     bne       LF441               ; branch if not zero
 F43E | 7E F5 1C                  jmp       LF51C               ; go put a '0' in the buffer and return
      | 
 F441 | 4F              LF441     clra                          ; decimal point position = 0
 F442 | C1 80                     cmpb      #$80                ; check the exponent and..
 F444 | 22 08                     bhi       LF44E               ; ..branch if number > 1.0
 F446 | CE F4 0D                  ldx       #BILION             ; point X to constant:  1,000,000,000
 F449 | BD F0 EF                  jsr       LF0EF               ; multiply a number < 1.0 by one billion
 F44C | 86 F7                     ldaa      #-9                 ; decimal point position = -9
 F44E | 97 BF           LF44E     staa      FRACNT              ; store decimal point position
 F450 | CE F4 08        LF450     ldx       #MAXINT             ; point X to constant:  999,999,999
 F453 | BD F2 E3                  jsr       LF2E3               ; compare FPA0 with [X]
 F456 | 2E 10                     bgt       LF468               ; branch if FPA0 > 999,999,999
 F458 | CE F4 03        LF458     ldx       #MAXFRA             ; point X to constant:  99,999,999.9
 F45B | BD F2 E3                  jsr       LF2E3               ; compare FPA0 with [X]
 F45E | 2E 10                     bgt       LF470               ; branch if FPA0 > 99,999,999.9
 F460 | BD F1 9F                  jsr       LF19F               ; multiply FPA0 by 10
 F463 | 7A 00 BF                  dec       FRACNT              ; decrement decimal point position
 F466 | 20 F0                     bra       LF458               ; continue normalization
      | 
 F468 | BD F1 B9        LF468     jsr       LF1B9               ; divide FPA0 by 10
 F46B | 7C 00 BF                  inc       FRACNT              ; increment decimal point position
 F46E | 20 E0                     bra       LF450               ; continue normalization
      | 
 F470 | BD EF 6D        LF470     jsr       ADDHLF              ; add 0.5 to FPA0 then..
 F473 | BD F3 0B                  jsr       LF30B               ; ..integerize to round-up
 F476 | C6 01                     ldab      #$01                ; 
 F478 | 96 BF                     ldaa      FRACNT              ; get decimal point position
 F47A | 8B 0A                     adda      #10                 ; if more than 9 fractional digits..
 F47C | 2B 08                     bmi       LF486               ; ..then scientific notation required
 F47E | 81 0B                     cmpa      #9+2                ; if more than 9 whole number digits..
 F480 | 24 04                     bcc       LF486               ; ..then scientific notation required
 F482 | 4A                        deca                          ; decrement decimal point position
 F483 | 16                        tab                           ; ACCB = decimal point position
 F484 | 86 02                     ldaa      #$02                ; scientific notation exponent = 2
 F486 | 4A              LF486     deca                          ; subtract two from..
 F487 | 4A                        deca                          ; ..scientific notation exponent
 F488 | 97 C1                     staa      SCIEXP              ; store scientific notation exponent
 F48A | D7 BF                     stab      FRACNT              ; store decimal point position
 F48C | 2E 11                     bgt       LF49F               ; branch if any digits to the left of decimal point
 F48E | DE DE                     ldx       OUTPTR              ; point X to start of string buffer
 F490 | 86 2E                     ldaa      #'.                 ; set decimal point..
 F492 | 08                        inx                           ; ..as 2nd character..
 F493 | A7 00                     staa      ,X                  ; ..of the output string
 F495 | 5D                        tstb                          ; test decimal point position
 F496 | 27 05                     beq       LF49D               ; branch if number < 0.01
 F498 | 86 30                     ldaa      #'0                 ; append a '0'..
 F49A | 08                        inx                           ; ..character to..
 F49B | A7 00                     staa      ,X                  ; ..the output string
 F49D | DF DE           LF49D     stx       OUTPTR              ; save string output ptr
 F49F | CE F5 29        LF49F     ldx       #PWRTEN             ; point X to table of powers of ten
 F4A2 | C6 80                     ldab      #$80                ; initialize digit counter
      | 
 F4A4 | 96 CD           LF4A4     ldaa      FPA0+3              ; ..
 F4A6 | AB 03                     adda      3,X                 ; ..
 F4A8 | 97 CD                     staa      FPA0+3              ; ..
 F4AA | 96 CC                     ldaa      FPA0+2              ; ..add the..
 F4AC | A9 02                     adca      2,X                 ; ..power of..
 F4AE | 97 CC                     staa      FPA0+2              ; ..ten mantissa..
 F4B0 | 96 CB                     ldaa      FPA0+1              ; ..to the..
 F4B2 | A9 01                     adca      1,X                 ; ..mantissa..
 F4B4 | 97 CB                     staa      FPA0+1              ; ..of FPA0..
 F4B6 | 96 CA                     ldaa      FPA0                ; ..
 F4B8 | A9 00                     adca      ,X                  ; ..
 F4BA | 97 CA                     staa      FPA0                ; ..
 F4BC | 5C                        incb                          ; increment digit counter
 F4BD | 56                        rorb                          ; rotate carry into bit 7 
 F4BE | 59                        rolb                          ; set overflow and branch if..
>F4BF | 28 E3                     bvc       LF4A4               ; ..carry set and positive mantissa or..
 F4C1 | 24 03                     bcc       LF4C6               ; ..carry clear and negative mantissa
 F4C3 | C0 0B                     subb      #10+1               ; take the 9's complement..
 F4C5 | 50                        negb                          ; ..if adding mantissa
 F4C6 | CB 2F           LF4C6     addb      #'0'-1              ; convert to ASCII digit
 F4C8 | 08                        inx                           ; advance X to..
 F4C9 | 08                        inx                           ; ..the next..
 F4CA | 08                        inx                           ; ..power of ten.. 
 F4CB | 08                        inx                           ; ..mantissa
 F4CC | DF B3                     stx       VARADR              ; save power of ten ptr
 F4CE | DE DE                     ldx       OUTPTR              ; get string output ptr
 F4D0 | 08                        inx                           ; advance for next output character
 F4D1 | 17                        tba                           ; move character to ACCA
 F4D2 | 84 7F                     anda      #$7F                ; mask off the add/subtract flag
 F4D4 | A7 00                     staa      ,X                  ; append character to string
 F4D6 | 7A 00 BF                  dec       FRACNT              ; decrement decimal point position counter
 F4D9 | 26 05                     bne       LF4E0               ; branch if not time for decimal point
 F4DB | 86 2E                     ldaa      #'.                 ; append decimal..
 F4DD | 08                        inx                           ; ..point to the..
 F4DE | A7 00                     staa      ,X                  ; ..output string
 F4E0 | DF DE           LF4E0     stx       OUTPTR              ; save string output ptr
 F4E2 | DE B3                     ldx       VARADR              ; get powers of ten ptr
 F4E4 | 53                        comb                          ; toggle the add/subtract flag
 F4E5 | C4 80                     andb      #$80                ; keep only the add/subtract flag
 F4E7 | 8C F5 4D                  cpx       #ENDTEN             ; end of the powers of ten table?
 F4EA | 26 B8                     bne       LF4A4               ; loop if no
      | 
      |                 * Remove trailing zeroes and/or decimal point
 F4EC | DE DE                     ldx       OUTPTR              ; get string output ptr
 F4EE | A6 00           LF4EE     ldaa      ,X                  ; get last character in string
 F4F0 | 09                        dex                           ; decrement string ptr
 F4F1 | 81 30                     cmpa      #'0                 ; is last character a '0' ?
 F4F3 | 27 F9                     beq       LF4EE               ; loop if yes
 F4F5 | 81 2E                     cmpa      #'.                 ; is last character a decimal point?
 F4F7 | 27 01                     beq       LF4FA               ; branch if yes (decimal point not needed)
 F4F9 | 08                        inx                           ; increment string ptr
      | 
      |                 * Append scientific notation exponent if needed
 F4FA | 86 2B           LF4FA     ldaa      #'+                 ; assume positive exponent for scientific notation
 F4FC | D6 C1                     ldab      SCIEXP              ; get exponent
 F4FE | 27 1E                     beq       LF51E               ; branch if scientific notation not needed
 F500 | 2A 03                     bpl       LF505               ; branch if positive exponent
 F502 | 86 2D                     ldaa      #'-                 ; minus sign for negative exponent
 F504 | 50                        negb                          ; ACCB = ABS(exponent)
 F505 | A7 02           LF505     staa      2,X                 ; put exponent sign in output string at offset 2
 F507 | 86 45                     ldaa      #'E                 ; put an 'E' in the output..
 F509 | A7 01                     staa      1,X                 ; ..string at offset 1
 F50B | 86 2F                     ldaa      #'0'-1              ; init 10's digit for ASCII exponent to '0' (-1)
 F50D | 4C              LF50D     inca                          ; increment 10's digit for ASCII exponent
 F50E | C0 0A                     subb      #10                 ; subtract 10 from exponent
 F510 | 24 FB                     bcc       LF50D               ; loop if >= 0
 F512 | CB 3A                     addb      #'9'+1              ; ACCB = one's digit for ASCII exponent
 F514 | A7 03                     staa      3,X                 ; store 10's digit in output string (WHY NOT STD?)
 F516 | E7 04                     stab      4,X                 ; store 1's digit in output string
 F518 | 6F 05                     clr       5,X                 ; append null terminator to output string
 F51A | 20 04                     bra       LF520
      | 
 F51C | A7 00           LF51C     staa      ,X                  ; append character in ACCA to the string
 F51E | 6F 01           LF51E     clr       1,X                 ; append null terminator
 F520 | CE 43 35        LF520     ldx       #STRBUF             ; point X to the beginning of the string
 F523 | 39              LF523     rts                           ; return
      | 
      | 
 F524 | 80 00 00 00 00  ONEHLF    fcb       $80,$00,$00,$00,$00 ; 0.5
      | 
      |                 * Un-normalized powers of ten
 F529 | FA 0A 1F 00     PWRTEN    fcb       $FA,$0A,$1F,$00     ; -100,000,000
 F52D | 00 98 96 80               fcb       $00,$98,$96,$80     ; 10,000,000
 F531 | FF F0 BD C0               fcb       $FF,$F0,$BD,$C0     ; -1,000,000
 F535 | 00 01 86 A0               fcb       $00,$01,$86,$A0     ; 100,000
 F539 | FF FF D8 F0               fcb       $FF,$FF,$D8,$F0     ; -10,000
 F53D | 00 00 03 E8               fcb       $00,$00,$03,$E8     ; 1,000
 F541 | FF FF FF 9C               fcb       $FF,$FF,$FF,$9C     ; -100
 F545 | 00 00 00 0A               fcb       $00,$00,$00,$0A     ; 10
 F549 | FF FF FF FF               fcb       $FF,$FF,$FF,$FF     ; -1
      |                 ENDTEN    equ       *
      | 
      | 
      |                 ***
      |                 *** SQR (number)
      |                 ***
 F54D | BD F2 9F        SQR       jsr       MOVFP1              ; copy argument to FPA1
 F550 | CE F5 24                  ldx       #ONEHLF             ; load exponent of 0.5..
 F553 | BD F2 51                  jsr       LDFPA0              ; ..into FPA0
      | 
      |                 * Raise number in FPA1 to the power of number in FPA0, leaving result in FPA0.
 F556 | 27 71           FPPOWR    beq       EXPFN               ; do natural exponentiation if exponent is zero
 F558 | 4D                        tsta                          ; if value being exponentiated <> 0..
 F559 | 26 0A                     bne       LF565               ; ..then branch
 F55B | 96 CE                     ldaa      FP0SGN              ; if raising 0 to..
 F55D | 2A 03                     bpl       LF562               ; ..a negative power then..
 F55F | 7E F2 43                  jmp       DIVZER              ; ..issue a division-by-zero error
 F562 | 7E EF F5        LF562     jmp       LEFF5               ; ..else result = 0
      | 
 F565 | CE 00 C4        LF565     ldx       #FPA5               ; store exponent..
 F568 | BD F2 72                  jsr       STFPA0              ; ..in FPA5
 F56B | 5F                        clrb                          ; predict sign of result to be positive
 F56C | 96 DB                     ldaa      FP1SGN              ; check sign of argument
 F56E | 2A 10                     bpl       LF580               ; branch if positive
 F570 | BD F3 35                  jsr       INT                 ; integerize the exponent
 F573 | CE 00 C4                  ldx       #FPA5               ; point X to original exponent
 F576 | 96 DB                     ldaa      FP1SGN              ; ACCA = sign of argument (negative)
 F578 | BD F2 E3                  jsr       LF2E3               ; compare original and integerized exponents
 F57B | 26 03                     bne       LF580               ; branch if different
 F57D | 43                        coma                          ; ACCA = inverted argument sign (positive)
 F57E | D6 80                     ldab      CHARAC              ; ACCB = LSB of integerized exponent (sign flag)
 F580 | BD F2 8D        LF580     jsr       LF28D               ; move argument to FPA0 with sign in ACCA
 F583 | 37                        pshb                          ; save sign flag on stack
 F584 | BD F0 B9                  jsr       LOG                 ; compute natural logarithm of argument
 F587 | CE 00 C4                  ldx       #FPA5               ; point X to exponent in FPA5
 F58A | BD F0 EF                  jsr       LF0EF               ; multiply exponent by log(arg)
 F58D | 8D 3A                     bsr       EXPFN               ; calculate E ** FPA0
 F58F | 32                        pula                          ; pull saved sign flag
 F590 | 46                        rora                          ; move sign flag to Carry
 F591 | 24 90                     bcc       LF523               ; return if positive
 F593 | 96 C9           LF593     ldaa      FP0EXP              ; if result is zero..
 F595 | 27 03                     beq       LF59A               ; ..then return
 F597 | 73 00 CE                  com       FP0SGN              ; toggle sign of the result
 F59A | 39              LF59A     rts                           ; return
      | 
      | 
      |                 * Correction factor for the EXP function
 F59B | 81 38 AA 3B 29  EXPCF     fcb       $81,$38,$AA,$3B,$29 ; 1.44269504 (CF)
      | 
      |                 * Coefficients Table for the EXP function
 F5A0 | 07              PLYEXP    fcb       8-1                 ; eight coefficients in the table
 F5A1 | 71 34 58 3E 56            fcb       $71,$34,$58,$3E,$56 ; 0.00002150   1 / (7! * CF^7)
 F5A6 | 74 16 7E B3 1B            fcb       $74,$16,$7E,$B3,$1B ; 0.00014352   1 / (6! * CF^6)
 F5AB | 77 2F EE E3 85            fcb       $77,$2F,$EE,$E3,$85 ; 0.00134226   1 / (5! * CF^5)
 F5B0 | 7A 1D 84 1C 2A            fcb       $7A,$1D,$84,$1C,$2A ; 0.00961402   1 / (4! * CF^4)
 F5B5 | 7C 63 59 58 0A            fcb       $7C,$63,$59,$58,$0A ; 0.05550513   1 / (3! * CF^3)
 F5BA | 7E 75 FD E7 C6            fcb       $7E,$75,$FD,$E7,$C6 ; 0.24022638   1 / (2! * CF^2)
 F5BF | 80 31 72 18 10            fcb       $80,$31,$72,$18,$10 ; 0.69314719   1 / (1! * CF^1)
 F5C4 | 81 00 00 00 00            fcb       $81,$00,$00,$00,$00 ; 1.0
      | 
      |                 ***
      |                 *** EXP (number)
      |                 ***
 F5C9 | CE F5 9B        EXPFN     ldx       #EXPCF              ; point X to correction factor
 F5CC | 8D 36                     bsr       LF604               ; multiply argument by correction factor
 F5CE | BD F2 6C                  jsr       MOVFP3              ; copy result of multiplication to FPA3
 F5D1 | 96 C9                     ldaa      FP0EXP              ; get exponent of corrected argument
 F5D3 | 81 88                     cmpa      #$88                ; if ABS(argument) < 89..
 F5D5 | 25 03                     blo       LF5DA               ; ..then branch
 F5D7 | 7E F1 90        LF5D7     jmp       LF190               ; return 0 for negative arg, ?OV ERROR for positive
 F5DA | BD F3 35        LF5DA     jsr       INT                 ; integerize the corrected argument
 F5DD | 96 80                     ldaa      CHARAC              ; get LSB of the integer
 F5DF | 8B 81                     adda      #$81                ; if LSB = 127...
 F5E1 | 27 F4                     beq       LF5D7               ; ..then overflow
 F5E3 | 4A                        deca                          ; adjust bias to $80
 F5E4 | 36                        psha                          ; save exponent on stack
 F5E5 | CE 00 BA                  ldx       #FPA3               ; point X to argument copy in FPA3
 F5E8 | BD EF 72                  jsr       LEF72               ; subtract integerized value from argument
 F5EB | CE F5 A0                  ldx       #PLYEXP             ; point X to the table of coefficients
 F5EE | 8D 17                     bsr       LF607               ; evaluate polynomial for fractional portion
 F5F0 | 7F 00 DC                  clr       RESSGN              ; force result to be positive
 F5F3 | 32                        pula                          ; get integer exponent from stack
 F5F4 | BD F1 79                  jsr       CALEXP              ; calc exp for result
 F5F7 | 39                        rts                           ; return
      | 
      |                 *
      |                 * Expand a polynomial of the form:
      |                 *     AQ + BQ**3 + CQ**5 +DQ**7...
      |                 * where Q = the value in FPA0 and X points to the table of coefficients A,B,C,D...
      |                 *
 F5F8 | DF DE           LF5F8     stx       OUTPTR              ; save pointer to coefficients table
 F5FA | BD F2 6C                  jsr       MOVFP3              ; move FPA0 to FPA3
 F5FD | 8D 05                     bsr       LF604               ; multiply FPA0 by FPA3
 F5FF | 8D 08                     bsr       LF609               ; expand the polynomial
 F601 | CE 00 BA                  ldx       #FPA3               ; point X to FPA3
 F604 | 7E F0 EF        LF604     jmp       LF0EF               ; multiply FPA0 by [X] and return
      | 
      |                 *
      |                 * Calculate an expanded polynomial expression.
      |                 * Enter with X pointing to a table of coefficients, the first byte being the number of
      |                 * coefficients in the table -1.  The expression is evaluated as:
      |                 *   (((FPA0 * Y0 + Y1) * FPA0 + Y2) * FPA0 + Yn) ...
      |                 *
 F607 | DF DE           LF607     stx       OUTPTR              ; save ptr to coefficients table
 F609 | BD F2 67        LF609     jsr       MOVFP4              ; move FPA0 to FPA4
 F60C | DE DE                     ldx       OUTPTR              ; point X to coefficients table
 F60E | E6 00                     ldab      ,X                  ; get coefficient count
 F610 | D7 CF                     stab      COEFCT              ; save counter
 F612 | 08                        inx                           ; point X to first coefficient
 F613 | DF DE                     stx       OUTPTR              ; save coefficient pointer
 F615 | 8D ED           LF615     bsr       LF604               ; multiply FPA0 by [X]
 F617 | DE DE                     ldx       OUTPTR              ; get coefficient pointer..
 F619 | C6 05                     ldab      #$05                ; ..and increment it..
 F61B | 3A                        abx                           ; ..to point to next coefficient
 F61C | DF DE                     stx       OUTPTR              ; save new coefficient pointer
 F61E | BD EF 7D                  jsr       LEF7D               ; add coefficient to FPA0
 F621 | CE 00 BF                  ldx       #FPA4               ; point X to FPA4
 F624 | 7A 00 CF                  dec       COEFCT              ; decrement coefficient count
 F627 | 26 EC                     bne       LF615               ; loop if more to do
 F629 | 39                        rts                           ; return
      | 
      |                 ***
      |                 *** RND (number)
      |                 ***
 F62A | BD F2 AD        RND       jsr       FPTEST              ; compare argument with zero
 F62D | 2B 21                     bmi       LF650               ; branch if negative argument
 F62F | 27 15                     beq       LF646               ; branch if argument = 0
 F631 | 8D 10                     bsr       LF643               ; integerize the argument
 F633 | BD F2 6C                  jsr       MOVFP3              ; copy integerized arg to FPA3
 F636 | 8D 0E                     bsr       LF646               ; get random value from 0.0 to 1.0 in FPA0
 F638 | CE 00 BA                  ldx       #FPA3               ; point X to integerized argument
 F63B | 8D C7                     bsr       LF604               ; multiply argument by random value
 F63D | CE F0 8B                  ldx       #FPONE              ; point X to constant: 1.0
 F640 | BD EF 7D                  jsr       LEF7D               ; add 1 to result
 F643 | 7E F3 35        LF643     jmp       INT                 ; integerize result and return
      | 
      |                 * Compute next value in pseudo-random number sequence:  0.0 < Random Value < 1.0
 F646 | FE 42 18        LF646     ldx       RVSEED              ; copy variable..
 F649 | DF CA                     stx       FPA0                ; ..seed value..
 F64B | FE 42 1A                  ldx       RVSEED+2            ; ..into mantissa..
 F64E | DF CC                     stx       FPA0+2              ; ..of FPA0
 F650 | FE F6 82        LF650     ldx       RCSEED              ; copy constant..
 F653 | DF D7                     stx       FPA1                ; ..seed value..
 F655 | FE F6 84                  ldx       RCSEED+2            ; ..into mantissa..
 F658 | DF D9                     stx       FPA1+2              ; ..of FPA1
 F65A | BD F0 F6                  jsr       LF0F6               ; multiply seed values
 F65D | FC 42 54                  ldd       RNDVAL+2            ; get low-order word of product..
 F660 | C3 65 8B                  addd      #$658B              ; ..and add it to constant
 F663 | FD 42 1A                  std       RVSEED+2            ; save in low word of variable seed..
 F666 | DD CC                     std       FPA0+2              ; ..and low word of FPA0 mantissa
 F668 | FC 42 52                  ldd       RNDVAL              ; get hi-order word of product..
 F66B | C9 B0                     adcb      #$B0                ; ..and add it..
 F66D | 89 05                     adca      #$05                ; ..to constant
 F66F | FD 42 18                  std       RVSEED              ; save in hi word of variable seed..
 F672 | DD CA                     std       FPA0                ; ..and hi word of FPA0 mantissa
 F674 | 7F 00 CE                  clr       FP0SGN              ; force FPA0 to be positive
 F677 | 86 80                     ldaa      #$80                ; set biased exponent for FPA0..
 F679 | 97 C9                     staa      FP0EXP              ; ..such that:  0.0 < FPA0 < 1.0
 F67B | 96 8F                     ldaa      FPA2+2              ; use byte 1 from FPA2 mantissa as the..
 F67D | 97 DD                     staa      FPSBYT              ; ..sub-precision byte (more randomness)
 F67F | 7E EF D6                  jmp       LEFD6               ; go normalize FPA0 and return
      | 
 F682 | 40 E6 4D AB     RCSEED    fcb       $40,$E6,$4D,$AB     ; constant random number seed
      | 
      | 
      |                 ***
      |                 *** COS (number)     = SIN(n+(Pi/2))
      |                 ***
 F686 | CE F6 F6        COS       ldx       #HALFPI             ; point X to constant:  Pi / 2
 F689 | BD EF 7D                  jsr       LEF7D               ; compute sum of argument + (Pi / 2)
      |                                                         ; fall through to SIN function
      |                 ***
      |                 *** SIN (number)
      |                 ***
 F68C | BD F2 9F        SIN       jsr       MOVFP1              ; copy the argument into FPA1
 F68F | CE F6 FB                  ldx       #TWOPI              ; point X to 2*Pi
 F692 | D6 DB                     ldab      FP1SGN              ; ACCB = sign of argument
 F694 | BD F1 C0                  jsr       LF1C0               ; divide the argument by (2*Pi)
 F697 | BD F2 9F                  jsr       MOVFP1              ; copy quotient to FPA1
 F69A | BD F3 35                  jsr       INT                 ; remove fractional part
 F69D | 7F 00 DC                  clr       RESSGN              ; set resulting sign to positive
 F6A0 | 96 D6                     ldaa      FP1EXP              ; get exponent of FPA1
 F6A2 | D6 C9                     ldab      FP0EXP              ; get exponent of FPA0
 F6A4 | BD EF 75                  jsr       FPSUB               ; FPA0 = FPA1 - FPA0
      | 
      |                 * FPA0 now contains only the fractional part of: argument / (2*Pi)
 F6A7 | CE F7 00                  ldx       #QUARTR             ; point X to 0.25
 F6AA | BD EF 72                  jsr       LEF72               ; subtract 0.25 from FPA0
 F6AD | 96 CE                     ldaa      FP0SGN              ; get sign resulting from subtraction
 F6AF | 36                        psha                          ; save sign on the stack
 F6B0 | 2A 0A                     bpl       LF6BC               ; branch if positive
 F6B2 | BD EF 6D                  jsr       ADDHLF              ; add 0.5 to FPA0
 F6B5 | 96 CE                     ldaa      FP0SGN              ; get sign resulting from addition
 F6B7 | 2B 06                     bmi       LF6BF               ; branch if still negative
 F6B9 | 73 00 88                  com       RELFLG              ; complemet Quadrant Flag for TAN (+(3*Pi)/2 >= arg >+ Pi/2)
 F6BC | BD F5 93        LF6BC     jsr       LF593               ; negate FPA0
 F6BF | CE F7 00        LF6BF     ldx       #QUARTR             ; add 0.5..
 F6C2 | BD EF 7D                  jsr       LEF7D               ; ..to FPA0
 F6C5 | 32                        pula                          ; get saved sign (quadrant flag for TAN)
 F6C6 | 4D                        tsta                          ; if positve then..
 F6C7 | 2A 03                     bpl       LF6CC               ; ..don't negate
 F6C9 | BD F5 93                  jsr       LF593               ; negate value in FPA0
 F6CC | CE F7 05        LF6CC     ldx       #SINCOF             ; point X to the table of coefficients
 F6CF | 7E F5 F8                  jmp       LF5F8               ; go calculate polynomial value and return
      | 
      |                 ***
      |                 *** TAN (number)    = SIN(n) / COS(n)
      |                 ***
 F6D2 | BD F2 6C        TAN       jsr       MOVFP3              ; copy the argument into FPA3
 F6D5 | 7F 00 88                  clr       RELFLG              ; clear quadrant flag
 F6D8 | 8D B2                     bsr       SIN                 ; calculate sine of argument
 F6DA | CE 00 C4                  ldx       #FPA5               ; save sine..
 F6DD | BD F2 72                  jsr       STFPA0              ; ..in FPA5
 F6E0 | CE 00 BA                  ldx       #FPA3               ; load original argument..
 F6E3 | BD F2 51                  jsr       LDFPA0              ; ..from FPA3 back into FPA0
 F6E6 | 7F 00 CE                  clr       FP0SGN              ; absolute value
 F6E9 | 96 88                     ldaa      RELFLG              ; get quadrant flag from SIN computation
 F6EB | 8D 06                     bsr       LF6F3               ; calculate cosine
 F6ED | CE 00 C4                  ldx       #FPA5               ; point X to sine in FPA5
 F6F0 | 7E F1 C6                  jmp       LF1C6               ; go divide sine by cosine and return
      | 
 F6F3 | 36              LF6F3     psha                          ; push quadrant flag onto the stack
 F6F4 | 20 C6                     bra       LF6BC               ; do sine calculation
      | 
      | 
 F6F6 | 81 49 0F DA A2  HALFPI    fcb       $81,$49,$0F,$DA,$A2 ; 1.57079632 Pi/2
 F6FB | 83 49 0F DA A2  TWOPI     fcb       $83,$49,$0F,$DA,$A2 ; 6.28318531 2*Pi
      | 
 F700 | 7F 00 00 00 00  QUARTR    fcb       $7F,$00,$00,$00,$00 ; 0.25  or  1/4
      | 
 F705 | 05              SINCOF    fcb       6-1                 ; six coefficients in the table
 F706 | 84 E6 1A 2D 1B            fcb       $84,$E6,$1A,$2D,$1B ; -14.38139067 -(2*Pi)^11/11!
 F70B | 86 28 07 FB F8            fcb       $86,$28,$07,$FB,$F8 ;  42.00779712  (2*Pi)^9 / 9!
 F710 | 87 99 68 89 01            fcb       $87,$99,$68,$89,$01 ; -76.70417026 -(2*Pi)^7 / 7!
 F715 | 87 23 35 DF E1            fcb       $87,$23,$35,$DF,$E1 ;  81.60522369  (2*Pi)^5 / 5!
 F71A | 86 A5 5D E7 28            fcb       $86,$A5,$5D,$E7,$28 ; -41.34170210 -(2*Pi)^3 / 3!
 F71F | 83 49 0F DA A2            fcb       $83,$49,$0F,$DA,$A2 ;   6.28318531  (2*Pi)^1 / 1!
      | 
      | 
      |                 * The text 'MICROSOFT!' obfuscated and reversed.   Some versions
      |                 * of Microsoft Basic include a routine to print this message to the
      |                 * console, but MicroColor Basic does not.
 F724 | A1                        fcb       $80+'!'
 F725 | 54                        fcb       $00+'T'
 F726 | 46                        fcb       $00+'F'
 F727 | 8F                        fcb       $40+'O'
 F728 | 13                        fcb       $1F&'S'
 F729 | 8F                        fcb       $40+'O'
 F72A | 52                        fcb       $00+'R'
 F72B | 43                        fcb       $00+'C'
 F72C | 89                        fcb       $40+'I'
 F72D | CD                        fcb       $80+'M'
      | 
      | 
      |                 *****************************************************
      |                 ***
      |                 *** The remaining code consists of the routines
      |                 *** which deal with machine-specific issues.
      |                 ***
      |                 *****************************************************
      | 
      |                 *
      |                 * The CPU's reset vector points here
 F72E | 86 FF           CPURES    ldaa      #$FF                ; set port 1 data direction register..
 F730 | 97 00                     staa      P1DDR               ; ..to all outputs (keyboard strobe)
 F732 | 86 01                     ldaa      #$01                ; set port 2 data direction register to..
 F734 | 97 01                     staa      P2DDR               ; ..output on bit 0 only (RS232 / Cassette)
 F736 | 86 01                     ldaa      #$01                ; set RS232 output..
 F738 | 97 03                     staa      P2DATA              ; ..state to MARK
 F73A | 96 EA                     ldaa      RSTFLG              ; get warm/cold flag
 F73C | 81 55                     cmpa      #$55                ; is this a warm start?
 F73E | 26 0A                     bne       LF74A               ; branch if cold start
 F740 | FE 42 21                  ldx       WSTVEC              ; get warm start routine vector
 F743 | A6 00                     ldaa      ,X                  ; get first instruction opcode
 F745 | 4A                        deca                          ; subtract 1 (NOP opcode)
 F746 | 26 02                     bne       LF74A               ; branch if first instruction is not NOP
 F748 | 6E 00                     jmp       ,X                  ; jump to the warm start routine
      | 
      |                 *
      |                 * Perform Cold Start initialization
 F74A | CE 00 80        LF74A     ldx       #$0080              ; point X to 6803 internal RAM
 F74D | 6F 00           LF74D     clr       ,X                  ; clear RAM byte
 F74F | 08                        inx                           ; bump pointer
 F750 | 8C 01 00                  cpx       #$0100              ; end of internal RAM?
 F753 | 26 F8                     bne       LF74D               ; loop if more to do
      | 

COMPUTERSTART TEST OF RAM

      |                 * Initialize and test RAM (determines memory size)
 F755 | CE 41 FD                  ldx       #VIDRAM+#200-3           ; point X to upper system globals -3
 F758 | 08              LF758     inx                           ; bump pointer
 F759 | A6 02                     ldaa      2,X                 ; read byte from memory
 F75B | 63 02                     com       2,X                 ; complement the byte in memory 
 F75D | E6 02                     ldab      2,X                 ; read byte again
 F75F | 6F 02                     clr       2,X                 ; clear the byte in memory
 F761 | 43                        coma                          ; complement first value loaded 
 F762 | 11                        cba                           ; compare against second value loaded
 F763 | 27 F3                     beq       LF758               ; loop if RAM tested good

; for the emulator on the ZX Spectrum above RAM-check doesn't work since
; ROM is unprotected. Also amount of RAM will be limited to 8K
; the routine will become:

; Altered RAM test routine #F755
;	db #CE,#3F,#FD		; F755 LDX #vidram-3
;	db #08			; F758 INX
;	db #6F,#02		; F759 CLR 2,X
;	db #8C,#5F,#FE		; F75B CPX #vidram-3+#1000	;  MAX 4K RAM
;	db #01,#01		; F75D NOP NOP
;	db #01,#01		; F75F NOP NOP
;	db #01			; F761 NOP
;	db #26,#F3		; F763 BNE LF758


      | 
      |                 * Reserve string space and set stack location
 F765 | FF 42 50                  stx       TOPRAM              ; save highest physical RAM address -1
 F768 | DF A1                     stx       MEMSIZ              ; set highest address avaialble to Basic
 F76A | DF 9D                     stx       STRTAB              ; initialize string space allocator
 F76C | DC 9D                     ldd       STRTAB              ; get top of string space
 F76E | 83 00 64                  subd      #100                ; initial size of string space is 100 bytes
 F771 | DD 9B                     std       FRETOP              ; set boundary between string space and stack
 F773 | 9E 9B                     lds       FRETOP              ; initialize stack pointer
      | 
      |                 * Copy initialization data from ROM to RAM
 F775 | CE F7 CF                  ldx       #PARSER-1           ; point to self-modifying parser routine in ROM
 F778 | CC 00 EB                  ldd       #CHRGET             ; ACCD = RAM address for parser routine
 F77B | 8D 30                     bsr       LF7AD               ; copy parser routine from ROM to RAM
 F77D | CE F7 DE                  ldx       #INIDAT             ; point X to initialization data in ROM
 F780 | CC 42 00                  ldd       #SCIVEC             ; point D to destination address in RAM
 F783 | 8D 28                     bsr       LF7AD               ; initialize RAM with ROM data
      | 
      |                 * Initialize all of Basic's extension vectors to RTS
 F785 | 86 39                     ldaa      #$39                ; RTS opcode
 F787 | CE 42 85                  ldx       #RVEC1              ; point X to first Extension Vector
 F78A | A7 00           LF78A     staa      ,X                  ; initialize to RTS
 F78C | 08                        inx                           ; bump pointer
 F78D | 8C 42 AF                  cpx       #RVEC14+3           ; end of extension vectors?
 F790 | 26 F8                     bne       LF78A               ; loop if more to do
 F792 | 73 42 AF                  com       RVEC14+3            ; mark end of vector table??  (could be COM 0,X)
      | 
      |                 * Setup Basic program and data space
 F795 | CE 43 46                  ldx       #PRGRAM             ; normal start address for Basic Program
 F798 | DF 93                     stx       TXTTAB              ; set start of Basic program
 F79A | BD E3 CF                  jsr       LE3CF               ; do a 'NEW'
      | 
      |                 * Display startup screen
 F79D | BD FB D4                  jsr       LFBD4               ; clear the screen
 F7A0 | CE F8 0F                  ldx       #CPYRGT-1           ; point X to copyright message -1
 F7A3 | BD E7 A8                  jsr       STROUT              ; output message to screen
 F7A6 | 86 55                     ldaa      #$55                ; initialize the..
 F7A8 | 97 EA                     staa      RSTFLG              ; ..warm start flag
 F7AA | 7E E2 71        LF7AA     jmp       LE271               ; display OK prompt and initiate Direct Mode
      | 
      | 
      |                 *
      |                 * Copy a block of memory from [X+1] to [D].  The block size (1..256) is loaded from [X]
 F7AD | DD BF           LF7AD     std       DSTPTR              ; store destination address
 F7AF | E6 00                     ldab      ,X                  ; get block size into ACCB
 F7B1 | 08              LF7B1     inx                           ; point X to next data byte
      | 
      |                 * Copy block of memory from [X] to [DSTPTR].  Pass the block size (1..256) in ACCB
 F7B2 | A6 00           LF7B2     ldaa      ,X                  ; get a byte from source
 F7B4 | DF C1                     stx       SRCPTR              ; temporary storage of source ptr
 F7B6 | DE BF                     ldx       DSTPTR              ; get destination ptr
 F7B8 | A7 00                     staa      ,X                  ; store byte in destination
 F7BA | 08                        inx                           ; bump destination ptr
 F7BB | DF BF                     stx       DSTPTR              ; store destination ptr
 F7BD | DE C1                     ldx       SRCPTR              ; retrieve source ptr
 F7BF | 5A                        decb                          ; decrement byte counter
 F7C0 | 26 EF                     bne       LF7B1               ; loop if more to do
 F7C2 | 39                        rts
      | 
      |                 *
      |                 * Default Warm Start routine
 F7C3 | 01              WMSTRT    nop                           ; warm starts must begin with NOP
 F7C4 | 7F 00 E8                  clr       DEVNUM              ; set keyboard/screen as current I/O device
 F7C7 | BD E3 EE                  jsr       LE3EE               ; setup the stack and disable CONT
 F7CA | BD FB D4                  jsr       LFBD4               ; clear the screen
 F7CD | 20 DB                     bra       LF7AA               ; display OK prompt and initiate Direct Mode
      | 
      | 
      |                 *
      |                 * Byte parser subroutine utilizing self-modifying code.
      |                 * This routine is copied to RAM at CHRGET ($00EB) during cold start.
      |                 *
 F7CF | 0E                        fcb       INIDAT-PARSER       ; number of bytes to copy
 F7D0 | 7C 00 F5        PARSER    inc       CHRPTR+1            ; increment LSB of parse location
 F7D3 | 26 03                     bne       LF7D8               ; branch if no carry
 F7D5 | 7C 00 F4                  inc       CHRPTR              ; increment MSB of parse location
 F7D8 | B6 00 00        LF7D8     ldaa      >$0000              ; load byte from parse location into ACCA
 F7DB | 7E E1 C8                  jmp       BPARSE              ; call back-end of parser routine in ROM
      | 
      | 
      |                 *
      |                 * This is initialization data that is copied to RAM ($4200-$4230) on a cold start.
      |                 *
 F7DE | 31              INIDAT    fcb       CPYRGT-(*+1)        ; number of bytes to copy
      | 
 F7DF | 3B                        rti                           ; secondary SCI vector
 F7E0 | 00 00                     fdb       $0000
 F7E2 | 3B                        rti                           ; secondary TOF vector
 F7E3 | 00 00                     fdb       $0000
 F7E5 | 3B                        rti                           ; secondary OCF vector
 F7E6 | 00 00                     fdb       $0000
 F7E8 | 3B                        rti                           ; secondary ICF vector
 F7E9 | 00 00                     fdb       $0000
 F7EB | 3B                        rti                           ; secondary IRQ vector
 F7EC | 00 00                     fdb       $0000
 F7EE | 3B                        rti                           ; secondary SWI vector
 F7EF | 00 00                     fdb       $0000
 F7F1 | 3B                        rti                           ; secondary NMI vector
 F7F2 | 00 00                     fdb       $0000
      | 
 F7F4 | 7E EC 2E                  jmp       ILLFNC              ; USR vector (?FC ERROR)
 F7F7 | 4F C7 52 59               fcb       $4F,$C7,$52,$59     ; random number seed 1
 F7FB | FF                        fcb       $FF                 ; caps lock flag
 F7FC | 04 5E                     fdb       $045E               ; keyboard debounce delay
 F7FE | EC 2E                     fdb       ILLFNC              ; EXEC address (?FC ERROR)
 F800 | F7 C3                     fdb       WMSTRT              ; warm start vector
 F802 | 00 76                     fdb       118                 ; printer baud rate delay (600 Baud)
 F804 | 00 01                     fdb       1                   ; printer carriage return delay
 F806 | 10                        fcb       16                  ; printer tab width
 F807 | 70                        fcb       112                 ; printer's last tab position
 F808 | 84                        fcb       132                 ; printer's line width
 F809 | 00                        fcb       0                   ; current printer column location
 F80A | 01                        fcb       1                   ; cursor blink delay counter
 F80B | 15                        fcb       21                  ; cassette 1200/2400 Hz cycle partition
 F80C | 1A                        fcb       26                  ; time limit for a valid cassette transition
 F80D | 0B                        fcb       11                  ; cassette 1200/2400 Hz transition partition
 F80E | 00 80                     fdb       128                 ; number of cassette leader bytes to write        
      | 
      | 
      |                 * Copyright Message String
 F810 | 4D 49 43 52 4F  CPYRGT    fcc       'MICROCOLOR BASIC 1.0'
 F815 | 43 4F 4C 4F 52 
 F81A | 20 42 41 53 49 
 F81F | 43 20 31 2E 30 
 F824 | 0D                        fcb       CR
 F825 | 43 4F 50 59 52            fcc       'COPYRIGHT 1982 '
 F82A | 49 47 48 54 20 
 F82F | 31 39 38 32 20 
 F834 | 4D 49 43 52 4F  MS_STR    fcc       'MICROSOFT'
 F839 | 53 4F 46 54 
 F83D | 0D 00                     fcb       CR,$00
      | 
      | 
      |                 * Blink the cursor if it is time
 F83F | 7A 42 2B        LF83F     dec       BLNKTM              ; decrement blink timer
 F842 | 26 1A                     bne       LF85E               ; branch if not yet time to blink
 F844 | B6 42 82                  ldaa      CRSCLR              ; get current cursor state
 F847 | 88 0F                     eora      #$0F                ; toggle the four pixel bits
 F849 | B7 42 82                  staa      CRSCLR              ; save new cursor state
 F84C | 8A 80                     oraa      #$80                ; set the graphics bit
 F84E | FE 42 80                  ldx       CRSPTR              ; point X to cursor location in Video RAM
 F851 | A7 00                     staa      ,X                  ; change the cursor color
 F853 | C6 16                     ldab      #22                 ; timer value when cursor is off
 F855 | 84 0F                     anda      #$0F                ; test the cursor state
 F857 | 27 02                     beq       LF85B               ; branch if cursor is off
 F859 | C6 58                     ldab      #88                 ; timer value when cursor is on
 F85B | F7 42 2B        LF85B     stab      BLNKTM              ; restart the timer
 F85E | CE 03 FA        LF85E     ldx       #1018               ; X = timer interval delay
      | 
      |                 *
      |                 * Run a delay loop by decrementing X until it reaches 0  (resolution = approx 7 microseconds)
 F861 | 09              LF861     dex                           ; Decrement delay counter
 F862 | 26 FD                     bne       LF861               ; Loop until delay counter reaches 0
 F864 | 39                        rts                           ; return
      | 
      |                 *
      |                 * CONSOLE IN
      |                 *
      |                 * Read one byte from the current device and return it in ACCA.  The only device supported
      |                 * by MicroColor Basic is the keyboard.  Other devices can be implemented through the
      |                 * RVEC1 extension hook.  Such extensions can also set EOFLAG ($009E) to indicate an
      |                 * End-Of-File condition.
      |                 *
 F865 | BD 42 85        CNSLIN    jsr       RVEC1               ; call extension hook
 F868 | 3C                        pshx                          ; save X
 F869 | 37                        pshb                          ; save B
      | 
 F86A | 8D D3           LF86A     bsr       LF83F               ; blink the cursor if it is time
 F86C | 8D 15                     bsr       KEYIN               ; poll the keyboard
 F86E | 27 FA                     beq       LF86A               ; loop if no key pressed
      | 
 F870 | C6 60                     ldab      #$60                ; blank character
 F872 | FE 42 80                  ldx       CRSPTR              ; point X to cursor location in Video RAM
 F875 | E7 00                     stab      ,X                  ; erase the cursor
 F877 | 20 52                     bra       LF8CB               ; go restore B,X and return
      | 
      |                 *
      |                 * Do a quick check for ANY key down before entering KEYIN
 F879 | 4F              LF879     clra                          ; value for strobing all keyboard columns
 F87A | 8D 54                     bsr       LF8D0               ; check for SHIFT, BREAK or CONTROL
 F87C | 26 05                     bne       KEYIN               ; proceed with KEYIN if any of these are pressed
 F87E | 8D 64                     bsr       LF8E4               ; read character key rows
 F880 | 4C                        inca                          ; A=0 if no character keys pressed
 F881 | 27 4A                     beq       LF8CD               ; return if no keys are down
      | 
      |                 *
      |                 * Poll the keyboard for a key-down transition.
      |                 * Return ASCII/control code in ACCA or 0 if no key-down transitions.
 F883 | BD 42 A9        KEYIN     jsr       RVEC13              ; call extension hook
 F886 | 3C                        pshx                          ; save X
 F887 | 37                        pshb                          ; save B
      | 
      |                 * First check for a key-down transition of the BREAK key
 F888 | 86 FB                     ldaa      #$FB                ; value for strobing BREAK key column
 F88A | 8D 44                     bsr       LF8D0               ; ACCA = current BREAK key state ($FF = down)
 F88C | 16                        tab                           ; copy key state to ACCB ($00 = up)
 F88D | 27 03                     beq       LF892               ; branch if BREAK key not down
 F88F | F8 42 3B                  eorb      BRKSTA              ; clear ACCB if BREAK was down previously
 F892 | B7 42 3B        LF892     staa      BRKSTA              ; store new BREAK key state
 F895 | 5D                        tstb                          ; has state changed from up to down?
 F896 | 27 06                     beq       LF89E               ; branch if not a key-down transition
 F898 | 8D 42                     bsr       LF8DC               ; debounce delay
 F89A | 		8D 36     bsr       LF8D2               ; read state of BREAK key again
 F89C | 26 2A                     bne       LF8C8               ; if still down then go return BREAK key code
      | 
      |                 * Scan keyboard looking for a key-down transition
 F89E | CE 42 30        LF89E     ldx       #KEYBUF-1           ; point X to keyboard tracking state -1
 F8A1 | 5F                        clrb                          ; clear ACCB and the carry flag
 F8A2 | 5A                        decb                          ; set all bits of ACCB
 F8A3 | F7 42 39                  stab      KEYCOL              ; intialize column number to -1
 F8A6 | 59              LF8A6     rolb                          ; ACCB = next column strobe value
 F8A7 | 24 1D                     bcc       LF8C6               ; branch if finished all columns
 F8A9 | 7C 42 39                  inc       KEYCOL              ; increment column number
 F8AC | 8D 34                     bsr       LF8E2               ; strobe keyboard column and read rows
 F8AE | 37                        pshb                          ; save column strobe on stack
 F8AF | 16                        tab                           ; copy row data to ACCB
 F8B0 | 08                        inx                           ; point X to tracking state for the column
 F8B1 | A8 00                     eora      ,X                  ; ACCA = rows where key state has changed
 F8B3 | A4 00                     anda      ,X                  ; ACCA = rows where new key has been pressed
 F8B5 | E7 00                     stab      ,X                  ; store new tracking state for the column
 F8B7 | 33                        pulb                          ; restore column strobe to ACCB
 F8B8 | 4D                        tsta                          ; has a new key in the column been pressed?
 F8B9 | 0D                        sec                           ; set carry which was just cleared by TSTA
 F8BA | 27 EA                     beq       LF8A6               ; loop if no new key has been pressed
 F8BC | 36                        psha                          ; save new key press rows on stack
      | 
      |                 * NOTE:
      |                 *    Although the instruction sequence below
      |                 *    contains a bug, it has no ill effect.
 F8BD | 8D 1D                     bsr       LF8DC               ; debounce delay (returns with X=0)
 F8BF | 8D 23                     bsr       LF8E4               ; read keyboard rows again
 F8C1 | A1 00                     cmpa      ,X                  ; BUG: X=0 as a result of the debounce delay
 F8C3 | 32                        pula                          ; restore new key press rows to ACCA
 F8C4 | 26 24                     bne       LF8EA               ; BUG: always branches because reading $0000 returns $FF
      | 
 F8C6 | 4F              LF8C6     clra                          ; set result to 'no key' pressed
 F8C7 | 8C                        fcb       SKP2                ; skip next instruction
 F8C8 | 86 03           LF8C8     ldaa      #3                  ; set result to BREAK key pressed
 F8CA | 4D              LF8CA     tsta                          ; set Z flag if no key pressed
 F8CB | 33              LF8CB     pulb                          ; restore ACCB
 F8CC | 38                        pulx                          ; restore X
 F8CD | 39              LF8CD     rts                           ; return
      | 
      | 
      |                 * Test the keyboard to see if the SHIFT key is pressed
 F8CE | 86 7F           LF8CE     ldaa      #$7F                ; value for strobing SHIFT key column
      | 
      |                 * Test the keyboard to see if the SHIFT, CONTROL or BREAK key is pressed.
      |                 * Pass the appropriate column strobe value in ACCA.
      |                 * Returns $FF in ACCA if pressed, 0 otherwise.
 F8D0 | 97 02           LF8D0     staa      P1DATA              ; strobe keyboard column(s)
 F8D2 | 96 03           LF8D2     ldaa      P2DATA              ; read port 2
 F8D4 | 43                        coma                          ; invert key state (1=pressed)
 F8D5 | 84 02                     anda      #$02                ; keep only the SHIFT/BREAK/CTRL key row bit
 F8D7 | 27 02                     beq       LF8DB               ; RTS if key not pressed
 F8D9 | 86 FF                     ldaa      #$FF
 F8DB | 39              LF8DB     rts
      | 
      |                 * Keyboard debounce delay
 F8DC | FE 42 1D        LF8DC     ldx       DEBDLY              ; X = debounce delay loop count
 F8DF | 7E F8 61                  jmp       LF861               ; go run delay loop and return
      | 
      |                 * Strobe keyboard columns with the value in ACCB and read rows into ACCA
 F8E2 | D7 02           LF8E2     stab      P1DATA              ; strobe keyboard column(s)
 F8E4 | B6 BF FF        LF8E4     ldaa      KVSPRT              ; read all 5 character rows
 F8E7 | 8A C0                     oraa      #$C0                ; set the 2 floating bits high
 F8E9 | 39                        rts                           ; return
      | 
      |                 * Translate column number (KEYCOL) and row data (ACCA) into a key code in ACCB
 F8EA | C6 F8           LF8EA     ldab      #-8                 ; initialize row offset
 F8EC | CB 08           LF8EC     addb      #8                  ; increment offset for next row
 F8EE | 44                        lsra                          ; shift row state into carry
 F8EF | 24 FB                     bcc       LF8EC               ; loop if key-down is not in this row
 F8F1 | FB 42 39                  addb      KEYCOL              ; add column number to row offset
      | 
      |                 * Check if the CONTROL key is also down
 F8F4 | 86 FE                     ldaa      #$FE                ; value for strobing the CONTROL key
 F8F6 | 8D D8                     bsr       LF8D0               ; ACCA = current CONTROL key state ($FF = down)
 F8F8 | B7 42 3A                  staa      CTRLKY              ; store CONTROL key flag
 F8FB | BD 42 AC                  jsr       RVEC14              ; call extension hook
 F8FE | 27 11                     beq       LF911               ; branch if CONTROL key not down
 F900 | CE F9 7C                  ldx       #KEYTOK             ; point X to Control key token table
 F903 | C1 20                     cmpb      #32                 ; if not CONTROL-0..
 F905 | 26 27                     bne       LF92E               ; ..then branch
 F907 | B6 42 82                  ldaa      CRSCLR              ; get cursor color preference
 F90A | 8B 10                     adda      #$10                ; increment color number
 F90C | B7 42 82                  staa      CRSCLR              ; set new cursor color
 F90F | 20 B5                     bra       LF8C6               ; go return 'no key' result
      | 
      |                 * Translate a non-alpha key
 F911 | 17              LF911     tba                           ; copy key code to ACCA
 F912 | 27 05                     beq       LF919               ; branch if '@' key
 F914 | C1 1A                     cmpb      #26                 ; if key 'A' - 'Z' ..
 F916 | 23 1B                     bls       LF933               ; ..then branch
 F918 | 8C                        fcb       SKP2                ; skip next instruction
 F919 | C6 1D           LF919     ldab      #29                 ; '@' key code = 29
 F91B | CE F9 39                  ldx       #KYMAP1-29          ; point X to unshifted key map -29
 F91E | 8D AE                     bsr       LF8CE               ; test state of the SHIFT key
 F920 | 27 0C                     beq       LF92E               ; branch if SHIFT key not down
 F922 | CE F9 4C                  ldx       #KYMAP2-29          ; point X to shifted key map -29
 F925 | C1 20                     cmpb      #32                 ; if not SHIFT-0..
 F927 | 26 05                     bne       LF92E               ; ..then branch
 F929 | 73 42 1C                  com       CAPLOK              ; toggle the Caps Lock state
 F92C | 20 98                     bra       LF8C6               ; go return 'no key' result
      | 
 F92E | 3A              LF92E     abx                           ; point X to key map entry
 F92F | A6 00                     ldaa      ,X                  ; get mapped value
 F931 | 20 97                     bra       LF8CA               ; go return mapped value
      | 
      |                 * Translate an alpha (A..Z) key
 F933 | 8D 99           LF933     bsr       LF8CE               ; test state of the SHIFT key
 F935 | B8 42 1C                  eora      CAPLOK              ; invert SHIFT state if Caps Lock on
 F938 | 26 07                     bne       LF941               ; branch if capital letter
 F93A | B6 42 1C                  ldaa      CAPLOK              ; get Caps Lock state
 F93D | 26 07                     bne       LF946               ; branch if both SHIFT and Caps Lock
 F93F | CA 20                     orab      #$20                ; add lower case offset to key code
 F941 | 17              LF941     tba                           ; move key code to ACCA
 F942 | 8A 40                     oraa      #$40                ; map alpha key code to ASCII 
 F944 | 20 84           LF944     bra       LF8CA               ; go return the ASCII code
      | 
      |                 * Translate a semi-graphics key
 F946 | CE F9 AB        LF946     ldx       #GRKEYS-1           ; point X to graphics key map -1
 F949 | 3A                        abx                           ; point X to key map entry
 F94A | A6 00                     ldaa      ,X                  ; get pixel pattern from map
 F94C | 2A F6                     bpl       LF944               ; branch if not a graphics key
 F94E | F6 42 82                  ldab      CRSCLR              ; get cursor color
 F951 | C4 70                     andb      #$70                ; clear all pixel bits
 F953 | 1B                        aba                           ; combine pixel pattern with color
 F954 | 20 EE                     bra       LF944               ; go return the semi-graphics character
      | 
      |                 *** Non-Alpha ASCII Map (un-shifted)
 F956 | 40 0D 20        KYMAP1    fcb       '@',CR,SPACE
 F959 | 30 31 32 33               fcb       '0','1','2','3'
 F95D | 34 35 36 37               fcb       '4','5','6','7'
 F961 | 38 39 3A 3B               fcb       '8','9',':',';'
 F965 | 2C 2D 2E 2F               fcb       ',','-','.','/'
      | 
      |                 *** Non-Alpha ASCII Map (shifted)
 F969 | 13 0D 20        KYMAP2    fcb       PAUSE,CR,SPACE
 F96C | 00 21 22 23               fcb       $00,'!','"','#'
 F970 | 24 25 26 27               fcb       '$','%','&','''
 F974 | 28 29 2A 2B               fcb       '(',')','*','+'
 F978 | 3C 3D 3E 3F               fcb       '<','=','>','?'
      | 
      |                 *** Key Code to Basic Token Map
 F97C | 88 08 B3 B2     KEYTOK    fcb       $88,BS,$B3,$B2      ; INPUT, <-, ABS, INT
 F980 | 82 9B 90 84               fcb       $82,$9B,$90,$84     ; GOSUB, SET, RETURN, IF
 F984 | A3 8A 81 9E               fcb       $A3,$8A,$81,$9E     ; THEN, NEXT, GOTO, SOUND
 F988 | BC BA B9 A5               fcb       $BC,$BA,$B9,$A5     ; PEEK, COS, SIN, STEP
 F98C | C7 15 9C 09               fcb       $C7,$15,$9C,$09     ; INKEY$, L.DEL, RESET, ->
 F990 | 8C 80 B5 5E               fcb       $8C,$80,$B5,$5E     ; READ, FOR, RND, UP-ARROW
 F994 | B1 8F 0A 00               fcb       $B1,$8F,$0A,$00     ; SGN, RESTORE, DWN-ARROW, null
 F998 | 00 00 0D 20               fcb       $00,$00,CR,SPACE    ; null, null, ENTER, SPACE
 F99C | 00 8E 93 98               fcb       $00,$8E,$93,$98     ; null, RUN, CONT, CSAVE
 F9A0 | 97 96 94 95               fcb       $97,$96,$94,$95     ; CLOAD, NEW, LIST, CLEAR
 F9A4 | 9D 86 89 92               fcb       $9D,$86,$89,$92     ; CLS, PRINT, END, POKE
 F9A8 | BB 91 B7 B6               fcb       $BB,$91,$B7,$B6     ; TAN, STOP, LOG, SQR
      | 
      |                 *** Alpha Key Code to Semi-Graphic Pixels Map
 F9AC | 89 80 82 87     GRKEYS    fcb       $89,$80,$82,$87
 F9B0 | 8D 86 85 48               fcb       $8D,$86,$85,'H'
 F9B4 | 49 4A 4B 4C               fcb       'I','J','K','L'
 F9B8 | 4D 4E 4F 50               fcb       'M','N','O','P'
 F9BC | 8F 8C 88 8B               fcb       $8F,$8C,$88,$8B
 F9C0 | 55 81 8E 83               fcb       'U',$81,$8E,$83
 F9C4 | 8A 84                     fcb       $8A,$84
      | 
      | 
      |                 *
      |                 * CONSOLE OUT
      |                 *
      |                 * Send character in ACCA to the current output device. The only devices supported
      |                 * by MicroColor Basic are the screen and a serial port printer.  Other devices can
      |                 * be implemented through the RVEC2 extension hook.
      |                 *
 F9C6 | BD 42 88        PUTCHR    jsr       RVEC2               ; call extension hook
>F9C9 | 3C                        pshx                          ; preserve X
 F9CA | 37                        pshb                          ; preserve B
 F9CB | 36                        psha                          ; save output character on stack
 F9CC | D6 E8                     ldab      DEVNUM              ; which output device?
 F9CE | 27 4B                     beq       LFA1B               ; branch if outputting to screen
      | 
      |                 *
      |                 * Send character in ACCA to serial port printer
 F9D0 | 16                        tab                           ; copy output character to ACCB
 F9D1 | 07                        tpa                           ; move IRQ mask to ACCA
 F9D2 | 36                        psha                          ; save IRQ mask on stack
 F9D3 | 0F                        sei                           ; mask IRQs
 F9D4 | 17                        tba                           ; move character back to ACCA
      | 
      |                 * Loop until printer indicates it is ready
 F9D5 | D6 03           LF9D5     ldab      P2DATA              ; read CPU port 2
 F9D7 | C4 04                     andb      #$04                ; test the SERIAL IN state
 F9D9 | 26 FA                     bne       LF9D5               ; loop unitl printer is ready
      | 
      |                 * Transmit a byte:  STOP BIT, START BIT, 8 DATA BITS, STOP BIT
 F9DB | 8D 2D                     bsr       LFA0A               ; send a Stop Bit
 F9DD | 5F                        clrb                          ; 0 = SPACE
 F9DE | 8D 2C                     bsr       LFA0C               ; send the Start Bit
 F9E0 | C6 08                     ldab      #8                  ; setup loop counter for 8 data bits
 F9E2 | 37              LF9E2     pshb                          ; push loop counter
 F9E3 | 5F                        clrb                          ; clear output data
 F9E4 | 44                        lsra                          ; shift data bit into Carry..
 F9E5 | 59                        rolb                          ; ..then to bit 0 of ACCB
 F9E6 | 8D 24                     bsr       LFA0C               ; send the data bit
 F9E8 | 33                        pulb                          ; pull bit loop counter
 F9E9 | 5A                        decb                          ; decrement
 F9EA | 26 F6                     bne       LF9E2               ; loop unitl 8 data bits sent
 F9EC | 8D 1C                     bsr       LFA0A               ; send a Stop Bit
 F9EE | 32                        pula                          ; pull saved IRQ mask
 F9EF | 06                        tap                           ; restore previous IRQ mask
 F9F0 | 32                        pula                          ; load the character into ACCA
 F9F1 | 81 0D                     cmpa      #CR                 ; is it a carriage return?
 F9F3 | 27 0B                     beq       LFA00               ; branch if CR
 F9F5 | 7C 42 2A                  inc       LPTPOS              ; bump the printer line postion
 F9F8 | F6 42 2A                  ldab      LPTPOS              ; get new line position
 F9FB | F1 42 29                  cmpb      LPTWID              ; compare to maximum line width
 F9FE | 25 07                     blo       LFA07               ; branch if not at end of line
 FA00 | 7F 42 2A        LFA00     clr       LPTPOS              ; set new line position to 0
 FA03 | 8D 10                     bsr       LFA15               ; run the carriage return..
 FA05 | 8D 0E                     bsr       LFA15               ; ..delay loop twice
 FA07 | 33              LFA07     pulb                          ; restore B
 FA08 | 38                        pulx                          ; retore X
 FA09 | 39                        rts                           ; return
      | 
      |                 * Transmit a Stop Bit through the serial port
 FA0A | C6 01           LFA0A     ldab      #1                  ; set bit 0 of ACCB to MARK
      | 
      |                 * Transmit bit 0 of ACCB through the serial port
 FA0C | D7 03           LFA0C     stab      P2DATA              ; write the bit to CPU port 2
 FA0E | 8D 00                     bsr       LFA10               ; run the baud delay loop twice
 FA10 | FE 42 23        LFA10     ldx       LPTBTD              ; get delay loop count
 FA13 | 20 03                     bra       LFA18               ; run delay loop and return
      | 
      |                 * Delay following a printer carriage return
 FA15 | FE 42 25        LFA15     ldx       LPTLND              ; get delay loop count
 FA18 | 7E F8 61        LFA18     jmp       LF861               ; run delay loop and return
      | 
      | 
      |                 * Output character in ACCA to the screen
 FA1B | FE 42 80        LFA1B     ldx       CRSPTR              ; point X to current cursor location
 FA1E | 81 08                     cmpa      #BS                 ; check for BACKSPACE character
 FA20 | 26 0C                     bne       LFA2E               ; branch if not a BACKSPACE
 FA22 | 8C 40 00                  cpx       #VIDRAM             ; if cursor is already at..
 FA25 | 27 50                     beq       LFA77               ; ..the home location then exit
 FA27 | 86 60                     ldaa      #$60                ; ACCA = blank character code
 FA29 | 09                        dex                           ; decrement cursor location
 FA2A | A7 00                     staa      ,X                  ; erase character from screen
 FA2C | 20 2E                     bra       LFA5C               ; go update cursor position
      | 
 FA2E | 81 0D           LFA2E     cmpa      #CR                 ; check for a carriage return
 FA30 | 26 14                     bne       LFA46               ; branch if not a carriage return
 FA32 | FE 42 80                  ldx       CRSPTR              ; point X to cursor location (redundant)
 FA35 | 86 60           LFA35     ldaa      #$60                ; ACCA = blank character code
 FA37 | A7 00                     staa      ,X                  ; erase character past end of line
 FA39 | 08                        inx                           ; increment cursor location
 FA3A | FF 42 80                  stx       CRSPTR              ; store cursor location
 FA3D | F6 42 81                  ldab      CRSPTR+1            ; get LSB of cursor address
 FA40 | C5 1F                     bitb      #$1F                ; modulo 32 gives current line position
 FA42 | 26 F1                     bne       LFA35               ; loop until cursor at start of next line (should be BNE $FA37)
 FA44 | 20 16                     bra       LFA5C               ; go
      | 
 FA46 | 81 20           LFA46     cmpa      #SPACE              ; compare output character to Space
 FA48 | 25 2D                     blo       LFA77               ; exit if non-printable character
 FA4A | 4D                        tsta                          ; test alpha/graphics bit (7)
 FA4B | 2B 0C                     bmi       LFA59               ; branch if graphics
 FA4D | 81 40                     cmpa      #$40                ; check ASCII character code
 FA4F | 25 06                     blo       LFA57               ; branch if digit/punctuation
 FA51 | 81 60                     cmpa      #$60                ; check ASCII character code
 FA53 | 25 04                     blo       LFA59               ; branch if upper case alpha / special chars
 FA55 | 84 DF                     anda      #$DF                ; change lower case ASCII to upper case VDG code
 FA57 | 88 40           LFA57     eora      #$40                ; toggle reverse-video bit for VDG code
 FA59 | A7 00           LFA59     staa      ,X                  ; put VDG code into video RAM
 FA5B | 08                        inx                           ; increment cursor location
 FA5C | FF 42 80        LFA5C     stx       CRSPTR              ; save new cursor location
 FA5F | 8C 42 00                  cpx       #VIDRAM+512         ; if new cursor position is not at..
 FA62 | 26 13                     bne       LFA77               ; ..the end of video RAM then branch
      | 
      |                 * Scroll the screen by one line
 FA64 | CE 40 00                  ldx       #VIDRAM             ; point X to start of video RAM
 FA67 | EC 20           LFA67     ldd       $20,X               ; get two bytes from following line..
 FA69 | ED 00                     std       ,X                  ; ..and store in line above it
 FA6B | 08                        inx                           ; advance X to the next..
 FA6C | 08                        inx                           ; ..pair of bytes
 FA6D | 8C 41 E0                  cpx       #VIDRAM+512-32      ; loop until X points to the..
 FA70 | 26 F5                     bne       LFA67               ; ..last line of the screen
 FA72 | C6 60                     ldab      #$60                ; ACCB = blank character code
 FA74 | BD FB D9                  jsr       LFBD9               ; do part of a CLS for last line only
      | 
 FA77 | 32              LFA77     pula                          ; restore registers and return
 FA78 | 33                        pulb
 FA79 | 38                        pulx
 FA7A | 39                        rts
      | 
      |                 *
      |                 * Setup the Tab Width, Last Tab Column, Line Width and Current Line Position settings for the current device
 FA7B | BD 42 8B        LFA7B     jsr       RVEC3               ; call extension hook
 FA7E | 3C                        pshx                          ; preserve X..
 FA7F | 37                        pshb                          ; ..and B..
 FA80 | 36                        psha                          ; ..and A
 FA81 | 96 E8                     ldaa      DEVNUM              ; check current device number
 FA83 | 27 08                     beq       LFA8D               ; branch if outputting to screen
 FA85 | FE 42 27                  ldx       LPTCFW              ; get printer settings for tab width and last tab column
 FA88 | FC 42 29                  ldd       LPTWID              ; get printer settings for line width and current position
 FA8B | 20 0A                     bra       LFA97               ; go store settings for current device
      | 
 FA8D | F6 42 81        LFA8D     ldab      CRSPTR+1            ; get LSB of absolute cursor address
 FA90 | C4 1F                     andb      #$1F                ; modulo 32 gives line position
 FA92 | CE 10 10                  ldx       #(16<<8)|16         ; MSB = tab width (16), LSB = last tab column (16)
 FA95 | 86 20                     ldaa      #32                 ; line width of screen = 32
      | 
 FA97 | DF E4           LFA97     stx       DEVCFW              ; install tab width and last tab column for current device
 FA99 | D7 E6                     stab      DEVPOS              ; install line position for current device
 FA9B | 97 E7                     staa      DEVWID              ; install line width of current device
 FA9D | 32                        pula                          ; restore A..
 FA9E | 33                        pulb                          ; ..and B..
 FA9F | 38                        pulx                          ; ..and X
 FAA0 | 39                        rts                           ; return
      | 
      | 
      |                 * Clear the screen and read a line from Console In.
 FAA1 | BD FB D4        LFAA1     jsr       LFBD4               ; clear the screen
      | 
      |                 * Read a line of data from Console In.
      |                 * Return with Carry set if line input terminated by BREAK.
      |                 * Return with X pointing to line input buffer -1.
 FAA4 | BD 42 91        LFAA4     jsr       RVEC5               ; call extension hook for line input
 FAA7 | 7F 42 7F        LFAA7     clr       IKYCOD              ; clear INKEY$ buffer
 FAAA | CE 42 B2                  ldx       #LINBUF             ; point X to line input buffer
 FAAD | C6 01                     ldab      #1                  ; initialize character count (+1)
 FAAF | BD F8 65        LFAAF     jsr       CNSLIN              ; read a character from Console In
 FAB2 | 7D 00 E9                  tst       EOFLAG              ; test End-Of-File flag (device extensions only)
 FAB5 | 26 4D                     bne       LFB04               ; branch if EOF
 FAB7 | 7D 00 E8                  tst       DEVNUM              ; check current input device
 FABA | 26 44                     bne       LFB00               ; branch if not the keyboard
 FABC | 4D                        tsta                          ; test key code
 FABD | 2A 1E                     bpl       LFADD               ; branch if < $80
 FABF | 7D 42 3A                  tst       CTRLKY              ; check CTRL key state
 FAC2 | 27 19                     beq       LFADD               ; branch if CTRL key was not pressed
 FAC4 | BD E4 B2                  jsr       LE4B2               ; point X to corresponding keyword (old X in TMPTR1)
 FAC7 | A6 00           LFAC7     ldaa      ,X                  ; get character from keyword
 FAC9 | 08                        inx                           ; point to next character
 FACA | 3C                        pshx                          ; save keyword character pointer on the stack
 FACB | 36                        psha                          ; save keyword character on the stack
 FACC | 84 7F                     anda      #$7F                ; mask out the hi-order bit (termination flag)
 FACE | DE 89                     ldx       TMPTR1              ; point X to current position in line input buffer
 FAD0 | 8D 48                     bsr       LFB1A               ; add character to buffer and display
 FAD2 | DF 89                     stx       TMPTR1              ; save current buffer position
 FAD4 | 32                        pula                          ; restore unmasked character code to ACCA
 FAD5 | 38                        pulx                          ; restore keyword character pointer to X
 FAD6 | 4D                        tsta                          ; is termination flag set in character code?
 FAD7 | 2A EE                     bpl       LFAC7               ; loop if not the last keyword character
 FAD9 | DE 89                     ldx       TMPTR1              ; point X to current position in line input buffer
 FADB | 20 D2                     bra       LFAAF               ; go get next input character
      | 
 FADD | 81 0C           LFADD     cmpa      #12                 ; is it the CLEAR key? (no such key on MC-10)
 FADF | 27 C0                     beq       LFAA1               ; clear screen and start over if CLEAR key
 FAE1 | 81 08                     cmpa      #BS                 ; is it a BACKSPACE?
 FAE3 | 26 08                     bne       LFAED               ; branch if not a BACKSPACE
 FAE5 | 5A                        decb                          ; decrement buffer character counter
 FAE6 | 27 BF                     beq       LFAA7               ; branch if already at beginning of the line
 FAE8 | 09                        dex                           ; decrement buffer pointer
 FAE9 | 8D 37                     bsr       LFB22               ; output the BACKSPACE to the console
 FAEB | 20 C2                     bra       LFAAF               ; go get next input character
      | 
 FAED | 81 15           LFAED     cmpa      #21                 ; is it [L. DEL] ?
 FAEF | 26 0A                     bne       LFAFB               ; branch if not a Line Delete
 FAF1 | 5A              LFAF1     decb                          ; decrement buffer character counter
 FAF2 | 27 B3                     beq       LFAA7               ; branch if at beginning of the line
 FAF4 | 86 08                     ldaa      #BS                 ; ACCA = BACKSPACE
 FAF6 | BD F9 C6                  jsr       PUTCHR              ; output a BACKSPACE to the console
 FAF9 | 20 F6                     bra       LFAF1               ; loop until buffer is empty
      | 
 FAFB | 81 03           LFAFB     cmpa      #3                  ; is it BREAK?
 FAFD | 0D                        sec                           ; set carry to indicate termination by BREAK
 FAFE | 27 05                     beq       LFB05               ; branch if BREAK key pressed
 FB00 | 81 0D           LFB00     cmpa      #CR                 ; is it ENTER?
 FB02 | 26 0E                     bne       LFB12               ; branch if not the ENTER key
 FB04 | 4F              LFB04     clra                          ; clear carry to indicate termination by ENTER
 FB05 | 07              LFB05     tpa                           ; move carry flag to ACCA
 FB06 | 36                        psha                          ; save carry flag on the stack
 FB07 | BD E7 66                  jsr       LE766               ; output a carriage return to the console
 FB0A | 6F 00                     clr       ,X                  ; null terminate the line input buffer
 FB0C | CE 42 B1                  ldx       #LINBUF-1           ; return with X pointing to line input buffer -1
 FB0F | 32                        pula                          ; get termination status bit from stack
 FB10 | 06                        tap                           ; put termination status into carry flag
 FB11 | 39              LFB11     rts                           ; return
      | 
 FB12 | 81 20           LFB12     cmpa      #SPACE              ; is it a non-printing character?
 FB14 | 25 99                     blo       LFAAF               ; ignore if not printable
 FB16 | 8D 02                     bsr       LFB1A               ; add character to the buffer and display it
 FB18 | 20 95                     bra       LFAAF               ; go get next input character
      | 
      |                 * Append character in ACCA to the line input buffer if the buffer is not full.
 FB1A | C1 80           LFB1A     cmpb      #LBUFMX             ; is the line input buffer full?
 FB1C | 24 F3                     bcc       LFB11               ; RTS if buffer is full
>FB1E | A7 00                     staa      ,X                  ; append character in ACCA to the line
 FB20 | 08                        inx                           ; bump the buffer pointer..
 FB21 | 5C                        incb                          ; ..and the character count
 FB22 | 7E F9 C6        LFB22     jmp       PUTCHR              ; output character to console and return
      | 
      | 
      |                 ***
      |                 *** SET (x,y,color)
      |                 ***
 FB25 | 8D 43           SETST     bsr       LFB6A               ; evaluate X and Y args, calc byte address and mask
 FB27 | 3C                        pshx                          ; save video RAM byte address on stack
 FB28 | BD EF 47                  jsr       LEF47               ; parse ',' and evaluate color argument into ACCB
 FB2B | 38                        pulx                          ; point X to the video RAM byte
 FB2C | C1 08                     cmpb      #8                  ; check if color value is in range (0-8)
 FB2E | 22 37                     bhi       LFB67               ; issue an ?FC ERROR if color out of range
 FB30 | 5A                        decb                          ; adjust to a VDG color code 
 FB31 | 2B 05                     bmi       LFB38               ; branch if "current color" specified (0)
 FB33 | 86 10                     ldaa      #16                 ; shift the color code left into..
 FB35 | 3D                        mul                           ; ..bits 4-6 (4 LSLB's would be faster)
 FB36 | 20 08                     bra       LFB40               ; continue below
      | 
      |                 * Use the color currently assigned to the pixel's byte
 FB38 | E6 00           LFB38     ldab      ,X                  ; get video RAM byte
 FB3A | 2A 03                     bpl       LFB3F               ; branch if text
 FB3C | C4 70                     andb      #$70                ; keep only the color code bits
 FB3E | 21                        fcb       SKP1                ; skip next instruction
 FB3F | 5F              LFB3F     clrb                          ; use text background color (green/amber)
      | 
 FB40 | D7 82           LFB40     stab      TMPLOC              ; put color code bits into temporary storage
 FB42 | 8D 70                     bsr       LFBB4               ; syntax check for ')'
 FB44 | A6 00                     ldaa      ,X                  ; get video RAM byte
 FB46 | 2B 01                     bmi       LFB49               ; branch if not text
 FB48 | 4F                        clra                          ; change text to empty graphics
 FB49 | 84 0F           LFB49     anda      #$0F                ; strip out the old color code
 FB4B | BA 42 3C                  oraa      PIXMSK              ; set the specified pixel bit
 FB4E | 9A 82                     oraa      TMPLOC              ; OR in the new color code
 FB50 | 8A 80           LFB50     oraa      #$80                ; set the graphics bit
 FB52 | A7 00                     staa      ,X                  ; store new value in video RAM
 FB54 | 39                        rts                           ; return
      | 
      | 
      |                 ***
      |                 *** RESET (x,y)
      |                 ***
 FB55 | 8D 13           RESET     bsr       LFB6A               ; evaluate arguments, calc byte address and mask
 FB57 | 8D 5B                     bsr       LFBB4               ; syntax check for ')'
 FB59 | 4F                        clra                          ; value with no pixels on
 FB5A | E6 00                     ldab      ,X                  ; get video RAM byte
 FB5C | 2A F2                     bpl       LFB50               ; if text then go convert to empty graphic
 FB5E | 73 42 3C                  com       PIXMSK              ; invert the pixel mask
 FB61 | F4 42 3C                  andb      PIXMSK              ; clear the specified pixel bit
 FB64 | E7 00                     stab      ,X                  ; store new value in video RAM
 FB66 | 39                        rts                           ; return
      | 
      | 
      |                 * Branch island for ?FC ERROR
 FB67 | 7E EC 2E        LFB67     jmp       ILLFNC              ; go issue an ?FC ERROR
      | 
      | 
      |                 *
      |                 * Evaluate the X and Y arguments for grahics functions SET, RESET and POINT.
      |                 * Returns with X pointing to the video RAM byte and PIXMSK containing the pixel mask.
      |                 *
 FB6A | BD EA 2C        LFB6A     jsr       LEA2C               ; syntax check for '('
 FB6D | BD EF 0D        LFB6D     jsr       LEF0D               ; evaulate unsigned 8 bit int expression into ACCB
 FB70 | C1 3F                     cmpb      #63                 ; check if X coordinate is in range (0-63)
 FB72 | 22 F3                     bhi       LFB67               ; issue an ?FC ERROR if out-of-range
 FB74 | 37                        pshb                          ; push X coordinate onto stack
 FB75 | BD EF 47                  jsr       LEF47               ; parse ',' and evaluate expression for Y
 FB78 | C1 1F                     cmpb      #31                 ; check if Y coordinate is in range (0-31)
 FB7A | 22 EB                     bhi       LFB67               ; issue an ?FC ERROR if out-of-range
 FB7C | 37                        pshb                          ; push Y coordinate onto stack
 FB7D | 54                        lsrb                          ; compute video RAM row number (Y/2)
 FB7E | 86 20                     ldaa      #32                 ; ACCA = bytes per row
 FB80 | 3D                        mul                           ; ACCD = row offset
 FB81 | C3 40 00                  addd      #VIDRAM             ; ACCD = address of video RAM row
 FB84 | 37                        pshb                          ; push row address..
 FB85 | 36                        psha                          ; ..onto stack
 FB86 | 30                        tsx                           ; point X to stacked values
 FB87 | E6 03                     ldab      3,X                 ; get X coordinate
 FB89 | 54                        lsrb                          ; compute row byte offset (X/2)
 FB8A | 38                        pulx                          ; point X to start of row
 FB8B | 3A                        abx                           ; point X to the video RAM byte
 FB8C | 32                        pula                          ; ACCA = Y coordinate
 FB8D | 33                        pulb                          ; ACCB = X coordinate
 FB8E | 84 01                     anda      #1                  ; ACCA = Y odd/even
 FB90 | 56                        rorb                          ; Carry = X odd/even
 FB91 | 49                        rola                          ; ACCA = pixel position (0-3)
 FB92 | C6 10                     ldab      #$10                ; initialize pixel mask by setting bit 4
 FB94 | 54              LFB94     lsrb                          ; shift the mask once to the..
 FB95 | 4A                        deca                          ; ..right until the bit is in..
 FB96 | 2A FC                     bpl       LFB94               ; ..position for the selected pixel
 FB98 | F7 42 3C                  stab      PIXMSK              ; store pixel mask
 FB9B | 39                        rts                           ; return
      | 
      |                 ***
      |                 *** POINT (x,y)
      |                 ***
 FB9C | 8D CF           POINT     bsr       LFB6D               ; evaluate arguments, calc byte address and mask
 FB9E | C6 FF                     ldab      #-1                 ; set result to -1 for text character
 FBA0 | A6 00                     ldaa      ,X                  ; get the video RAM byte
 FBA2 | 2A 0E                     bpl       LFBB2               ; go return result if not graphics
 FBA4 | B4 42 3C                  anda      PIXMSK              ; test the specified pixel
 FBA7 | 27 08                     beq       LFBB1               ; go return 0 if pixel not set
 FBA9 | E6 00                     ldab      ,X                  ; get the video RAM byte
 FBAB | 54                        lsrb                          ; shift the byte..
 FBAC | 54                        lsrb                          ; ..four positions to the right
 FBAD | 54                        lsrb                          ; ..to put color value (0-7)..
 FBAE | 54                        lsrb                          ; ..into the 3 lowest bits
 FBAF | C4 07                     andb      #$07                ; mask out the alpha/graphics bit
 FBB1 | 5C              LFBB1     incb                          ; increment result (now 0-8)
 FBB2 | 8D 03           LFBB2     bsr       LFBB7               ; put signed result in FPA0
 FBB4 | 7E EA 29        LFBB4     jmp       LEA29               ; syntax check for ')' and return
      | 
      |                 * Convert signed 8-bit integer in ACCB to FP value in FPA0
 FBB7 | 4F              LFBB7     clra                          ; zero extend ACCB to ACCD
 FBB8 | 5D                        tstb                          ; test the sign of ACCB
 FBB9 | 2A 01                     bpl       LFBBC               ; branch if positive
 FBBB | 43                        coma                          ; sign extend ACCB to ACCD
 FBBC | 7E EC E3        LFBBC     jmp       GIVABF              ; convert to FP value in FPA0 and return
      | 
      | 
      |                 ***
      |                 *** CLS [color]
      |                 ***
 FBBF | 27 13           CLS       beq       LFBD4               ; branch if no parameter provided
 FBC1 | BD EF 0D                  jsr       LEF0D               ; Evaulate unsigned 8 bit integer expression into ACCB
 FBC4 | C1 08                     cmpb      #8                  ; if color number > 8 then..
 FBC6 | 22 1D                     bhi       LFBE5               ; ..go clear with default color and print 'MICROSOFT'
 FBC8 | 5D                        tstb                          ; check for color code if 0
 FBC9 | 27 06                     beq       LFBD1               ; branch if CLS 0
 FBCB | 5A                        decb                          ; convert the color number..
 FBCC | 86 10                     ldaa      #16                 ; ..to a SemiGraphics 4 VDG code..
 FBCE | 3D                        mul                           ; ..using the formula:
 FBCF | CA 0F                     orab      #$0F                ; .. (colorNum - 1) * 16 | $0F
 FBD1 | CA 80           LFBD1     orab      #$80                ; ..and set the graphics bit (bit 7)
 FBD3 | 8C                        fcb       SKP2                ; skip next instruction
 FBD4 | C6 60           LFBD4     ldab      #$60                ; default color blank character
 FBD6 | CE 40 00                  ldx       #VIDRAM             ; point X to start of video RAM
 FBD9 | FF 42 80        LFBD9     stx       CRSPTR              ; set new cursor location
 FBDC | E7 00           LFBDC     stab      ,X                  ; clear screen location with color code
 FBDE | 08                        inx                           ; bump pointer
 FBDF | 8C 42 00                  cpx       #VIDRAM+$200        ; end of video RAM?
 FBE2 | 26 F8                     bne       LFBDC               ; loop if more to do
 FBE4 | 39                        rts                           ; return
      | 
      |                 * Clear screen using default color and then print 'MICROSOFT'
 FBE5 | 8D ED           LFBE5     bsr       LFBD4               ; clear screen
 FBE7 | CE F8 33                  ldx       #MS_STR-1           ; point X to 'MICROSOFT' string (-1)
 FBEA | 7E E7 A8                  jmp       STROUT              ; output string
      | 
      | 
      |                 ***
      |                 *** INKEY$
      |                 ***
 FBED | B6 42 7F        INKEY     ldaa      IKYCOD              ; get key buffered during BREAK check
 FBF0 | 26 03                     bne       LFBF5               ; branch if a key has been buffered
 FBF2 | BD F8 83                  jsr       KEYIN               ; read the keyboard now
 FBF5 | 7F 42 7F        LFBF5     clr       IKYCOD              ; clear the key buffer
 FBF8 | 97 CD                     staa      FPA0+3              ; store character code in FPA0
 FBFA | 27 03                     beq       LFBFF               ; branch if no key to return
 FBFC | 7E EE 91                  jmp       LEE91               ; go build string descriptor and return
      | 
 FBFF | 97 D0           LFBFF     staa      STRDES              ; set descriptor string length  to zero
 FC01 | 7E EE 9D                  jmp       LEE9D               ; go return string descriptor
      | 
      | 
      |                 ***
      |                 *** EXEC [address]
      |                 ***
 FC04 | 27 06           EXECST    beq       LFC0C               ; branch if no address specified
 FC06 | BD EF 4C                  jsr       LEF4C               ; evaluate integer expression into X
 FC09 | FF 42 1F                  stx       EXECJP              ; save as new default EXEC address 
 FC0C | FE 42 1F        LFC0C     ldx       EXECJP              ; get default EXEC address
 FC0F | 6E 00                     jmp       ,X                  ; go there
      | 
      | 
      |                 ***
      |                 *** VARPTR (varName)
      |                 ***
 FC11 | DE 99           VARPTR    ldx       ARYEND              ; get end address of all variables 
 FC13 | 3C                        pshx                          ; save on the stack
 FC14 | BD EB 1B                  jsr       LEB1B               ; parse variable name and find/create it
 FC17 | BD EA 29                  jsr       LEA29               ; syntax check for ')'
 FC1A | DF 89                     stx       TMPTR1              ; temp storage of var pointer
 FC1C | 38                        pulx                          ; X = previous end of all variables
 FC1D | DC 89                     ldd       TMPTR1              ; ACCD = var pointer
 FC1F | 9C 99                     cpx       ARYEND              ; compare X with new end of all variables
 FC21 | 27 03                     beq       LFC26               ; branch if address did not change
 FC23 | 7E EC 2E                  jmp       ILLFNC              ; variable was created so issue ?FC ERROR
 FC26 | 7E EC E3        LFC26     jmp       GIVABF              ; convert var pointer to FP in FPA0 and return
      | 
      | 
      |                 * ERROR?????
      |                 * Evaluate PRINT @ expression and translate it to a Video RAM address in CRSPTR
 FC29 | BD EB BA        LFC29     jsr       LEBBA               ; evaluate integer expression into ACCD
 FC2C | 83 01 FF                  subd      #511                ; check if between 0 and 511
 FC2F | 23 03                     bls       LFC34               ; branch if valid screen position
 FC31 | 7E EC 2E                  jmp       ILLFNC              ; issue an ?FC ERROR
 FC34 | C3 41 FF        LFC34     addd      #VIDRAM+511         ; calculate address within video RAM
 FC37 | FD 42 80                  std       CRSPTR              ; set new cursor location
 FC3A | 39                        rts                           ; return
      | 
      | 
      |                 ***
      |                 *** CSAVE [*] [fileName]
      |                 ***
 FC3B | DE 93           CSAVE     ldx       TXTTAB              ; point X to start of Basic program
 FC3D | FF 42 6F                  stx       CASBEG              ; set starting address for output
 FC40 | DE 95                     ldx       VARTAB              ; point X to end of Basic program
 FC42 | FF 42 71                  stx       CASEND              ; set ending address for output
 FC45 | 5F                        clrb                          ; ACCB = Basic Program File Type ($00)
 FC46 | 81 A9                     cmpa      #$A9                ; is current parse token a '*' ?
 FC48 | 26 05                     bne       LFC4F               ; branch if not saving an array
 FC4A | BD FD DB                  jsr       LFDDB               ; parse array name and set new start/end
 FC4D | C6 04                     ldab      #$04                ; ACCB = Array Data File Type ($04)
 FC4F | F7 42 67        LFC4F     stab      CFTYPE              ; store file type in name block buffer
 FC52 | FC 42 71                  ldd       CASEND              ; calculate file size by subtracting..
 FC55 | B3 42 6F                  subd      CASBEG              ; ..start address from end address
 FC58 | FD 42 6C                  std       LDSIZE              ; store file size in name block buffer
 FC5B | 8D 2E                     bsr       LFC8B               ; evaluate filename and write Name Block
 FC5D | FE 42 6F                  ldx       CASBEG              ; point X to first data byte
 FC60 | FF 42 78        LFC60     stx       BLKPTR              ; set start address for block write
 FC63 | 86 FF                     ldaa      #255                ; default block size = 255 bytes
 FC65 | B7 42 76                  staa      BLKLEN              ; set block size to default
 FC68 | FC 42 71                  ldd       CASEND              ; calculate number of..
 FC6B | B3 42 78                  subd      BLKPTR              ; ..bytes remaining to write
 FC6E | 23 0E                     bls       LFC7E               ; branch if none remaining
 FC70 | 4D                        tsta                          ; if more than 255 bytes remaining..
 FC71 | 26 07                     bne       LFC7A               ; ..then branch (use default)
 FC73 | C1 FF                     cmpb      #255                ; if exactly 255 bytes remaining..
 FC75 | 27 03                     beq       LFC7A               ; ..then branch (seems unnecessary)
 FC77 | F7 42 76                  stab      BLKLEN              ; set length for final data block (<255)
 FC7A | 8D 44           LFC7A     bsr       PUTBLK              ; write the data block to cassette
 FC7C | 20 E2                     bra       LFC60               ; loop to do next data block
      | 
      |                 * Write End-Of-File Block to cassette
 FC7E | 70 42 75        LFC7E     neg       BLKTYP              ; change block type to EOF ($FF)
 FC81 | 7F 42 76                  clr       BLKLEN              ; set block length to zero
 FC84 | 8D 3A                     bsr       PUTBLK              ; write the EOF block to cassette
 FC86 | 86 01           LFC86     ldaa      #$01                ; set the serial port output (which is..
 FC88 | 97 03                     staa      P2DATA              ; .. shared with cassette output) to MARK
 FC8A | 39                        rts                           ; return
      | 
      |                 * Evaluate the optional filename argument for CSAVE then write the Name Block to cassette.
      |                 * Also writes 1/2 second of silence and the leader for the first data block.
      |                 * The ASCII and Gaps flags in the Name Block are both cleared.
      |                 * Other fields in the Name Block must be setup before calling.
      |                 *
 FC8B | BD FD 29        LFC8B     jsr       LFD29               ; parse filename argument if given
 FC8E | CE 42 5F                  ldx       #NAMBLK             ; point X to name block buffer
 FC91 | FF 42 78                  stx       BLKPTR              ; set start address for block write 
 FC94 | DF BF                     stx       DSTPTR              ; set destination address for block move
 FC96 | 6F 09                     clr       $09,X               ; clear ASCII flag (ASCFLG)
 FC98 | 6F 0A                     clr       $0A,X               ; clear Gaps flag (GAPFLG)
 FC9A | CE 42 57                  ldx       #CFNSTR             ; point X to filename string buffer
 FC9D | C6 08                     ldab      #8                  ; prepare to move 8 bytes
 FC9F | BD F7 B2                  jsr       LF7B2               ; copy filename string into name block
 FCA2 | 7F 42 75                  clr       BLKTYP              ; set block type to 'Name Block'
 FCA5 | 86 0F                     ldaa      #15                 ; size of Name Block
 FCA7 | B7 42 76                  staa      BLKLEN              ; set block length
 FCAA | 8D 0B                     bsr       LDROUT              ; write leader to tape
 FCAC | 8D 12                     bsr       PUTBLK              ; write the name block to tape
 FCAE | 7C 42 75                  inc       BLKTYP              ; change block type to 'Data Block'
 FCB1 | CE 00 00                  ldx       #0                  ; X = maximum delay loop count (65536)
 FCB4 | BD F8 61                  jsr       LF861               ; delay for roughly 1/2 second
      | 
      |                 * Write a series of leader of bytes ($55) to cassette
 FCB7 | FE 42 2F        LDROUT    ldx       CLDRSZ              ; X = number of bytes to write
 FCBA | 8D 45           LFCBA     bsr       LFD01               ; write one leader byte
 FCBC | 09                        dex                           ; decrement count
 FCBD | 26 FB                     bne       LFCBA               ; loop until leader complete
 FCBF | 39                        rts                           ; return
      | 
      |                 * Write one block to cassette
 FCC0 | 01              PUTBLK    nop                           ; delay ??
 FCC1 | 0F                        sei                           ; mask IRQs
 FCC2 | F6 42 76                  ldab      BLKLEN              ; ACCB = block length
 FCC5 | F7 42 7B                  stab      CCTERR              ; store in I/O counter
 FCC8 | B6 42 76                  ldaa      BLKLEN              ; initial checksum = length (why not TBA?)
 FCCB | 27 09                     beq       LFCD6               ; branch if empty block
 FCCD | FE 42 78                  ldx       BLKPTR              ; point X to the block data
      | 
 FCD0 | AB 00           LFCD0     adda      ,X                  ; add data byte to checksum
 FCD2 | 08                        inx                           ; advance to next byte in block
 FCD3 | 5A                        decb                          ; decrement remaining byte count
 FCD4 | 26 FA                     bne       LFCD0               ; loop until all bytes summed
      | 
      |                 * Write block header
 FCD6 | BB 42 75        LFCD6     adda      BLKTYP              ; add block type to checksum
 FCD9 | B7 42 7A                  staa      BLKSUM              ; store final checksum byte
 FCDC | FE 42 78                  ldx       BLKPTR              ; point X to the block data
 FCDF | 8D 20                     bsr       LFD01               ; write one byte of $55..
 FCE1 | 86 3C                     ldaa      #$3C                ; ..followed by one byte..
 FCE3 | 8D 1E                     bsr       LFD03               ; ..of $3C to cassette
 FCE5 | B6 42 75                  ldaa      BLKTYP              ; write the Block Type..
 FCE8 | 8D 19                     bsr       LFD03               ; ..byte to cassette
 FCEA | B6 42 76                  ldaa      BLKLEN              ; write the Block Length..
 FCED | 8D 14                     bsr       LFD03               ; byte to cassette
 FCEF | 4D                        tsta                          ; if block has no contents..
 FCF0 | 27 0A                     beq       LFCFC               ; ..then branch
      | 
      |                 * Write block data to cassette
 FCF2 | A6 00           LFCF2     ldaa      ,X                  ; get a byte from the block
 FCF4 | 08                        inx                           ; advance to next byte in block
 FCF5 | 8D 0C                     bsr       LFD03               ; write the byte to cassette
 FCF7 | 7A 42 7B                  dec       CCTERR              ; decrement remaining byte count
 FCFA | 26 F6                     bne       LFCF2               ; loop until all bytes written
      | 
      |                 * Write block checksum to cassette
 FCFC | B6 42 7A        LFCFC     ldaa      BLKSUM              ; get checksum byte
 FCFF | 8D 02                     bsr       LFD03               ; write byte to cassette
      | 
      |                 * Write one $55 byte to cassette
 FD01 | 86 55           LFD01     ldaa      #$55
      | 
      |                 * Write byte in ACCA to cassette
 FD03 | 3C              LFD03     pshx                          ; preserve X
 FD04 | 36                        psha                          ; preserve ACCA
 FD05 | 36                        psha                          ; allocate stack byte for data shifting
 FD06 | C6 08                     ldab      #8                  ; ACCB = bit loop counter
 FD08 | 30              LFD08     tsx                           ; point X to data shift location
 FD09 | 64 00                     lsr       ,X                  ; shift next bit into carry
 FD0B | CE 00 20                  ldx       #32                 ; loop count for a 2400 Hz cycle
 FD0E | 25 03                     bcs       LFD13               ; branch if data bit is a '1'
 FD10 | CE 00 40                  ldx       #64                 ; loop count for a 1200 Hz cycle
 FD13 | 3C              LFD13     pshx                          ; push loop count onto stack
 FD14 | 86 01                     ldaa      #$01                ; set cassette output..
 FD16 | 97 03                     staa      P2DATA              ; ..level to HI
 FD18 | 09              LFD18     dex                           ; decrement loop count
 FD19 | 26 FD                     bne       LFD18               ; loop until X reaches 0
 FD1B | 4F                        clra                          ; set cassette output..
 FD1C | 97 03                     staa      P2DATA              ; ..level to LO
 FD1E | 38                        pulx                          ; pull loop count into X
 FD1F | 09              LFD1F     dex                           ; decrement loop count
 FD20 | 26 FD                     bne       LFD1F               ; loop until X reaches 0
 FD22 | 5A                        decb                          ; decrement remaining bits counter
 FD23 | 26 E3                     bne       LFD08               ; loop until all bits written
 FD25 | 32                        pula                          ; pop data shift byte
 FD26 | 32                        pula                          ; restore ACCA
 FD27 | 38                        pulx                          ; restore X
 FD28 | 39              LFD28     rts                           ; return
      | 
      | 
      |                 * Parse the optional filename argument for CSAVE [*].
 FD29 | 8D 08           LFD29     bsr       LFD33               ; parse filename argument if given
 FD2B | BD 00 F3                  jsr       >CHRGOT             ; get current parse character
 FD2E | 27 F8                     beq       LFD28               ; RTS if end of statement
 FD30 | 7E EA 3C                  jmp       SYNERR              ; issue an ?SN Error
      | 
      |                 *
      |                 * Parse an optional string expression and store the string data in the file name
      |                 * string buffer (CFNSTR).  The buffer is padded with spaces if the string length
      |                 * is less than 8 or if no string argument is provided.
      |                 *
      |                 * BUG: The string is not clipped to 8 characters. Passing a long
      |                 *      string argument to CLOAD, CSAVE or SKIPF can overwrite other
      |                 *      system variables and potentially crash the computer.
      |                 *
 FD33 | CE 42 56        LFD33     ldx       #CFNLEN             ; point X to length byte for file name buffer
 FD36 | 6F 00                     clr       ,X                  ; set string length to zero
 FD38 | 86 20                     ldaa      #SPACE              ; string will be padded with spaces
 FD3A | 08              LFD3A     inx                           ; advance character pointer
 FD3B | A7 00                     staa      ,X                  ; set character to a space
 FD3D | 8C 42 5F                  cpx       #CFNSTR+8           ; end of string buffer?
 FD40 | 26 F8                     bne       LFD3A               ; loop until string fully padded
      | 
 FD42 | BD 00 F3                  jsr       >CHRGOT             ; get current parse character
 FD45 | 27 E1                     beq       LFD28               ; RTS if no filename provided
 FD47 | BD E9 1A                  jsr       LE91A               ; evaluate an expression
 FD4A | BD EE 53                  jsr       LEE53               ; pop string expression (ptr -> X, length -> ACCB)
 FD4D | F7 42 56                  stab      CFNLEN              ; store filename string length
 FD50 | 27 D6                     beq       LFD28               ; RTS if null string
 FD52 | 37                        pshb                          ; push string length onto stack
 FD53 | CC 42 57                  ldd       #CFNSTR             ; point ACCD to first char of string buffer
 FD56 | DD BF                     std       DSTPTR              ; set destination address for block move
 FD58 | 33                        pulb                          ; pull string length into ACCB (BUG: not clipped)
 FD59 | 7E F7 B2                  jmp       LF7B2               ; copy to filename string buffer and return
      | 
      | 
      |                 ***
      |                 *** CLOAD [*] [fileName]
      |                 ***
 FD5C | 81 A9           CLOAD     cmpa      #$A9                ; is current parse token a '*' ?
 FD5E | 26 03                     bne       LFD63               ; branch if not loading array data
>FD60 | 7E FD B1                  jmp       LFDB1               ; go load data for an array variable
 FD63 | 81 4D           LFD63     cmpa      #'M                 ; is current parse character an 'M' ?
 FD65 | 26 03                     bne       LFD6A               ; branch if not CLOADM
 FD67 | 7E FE 06                  jmp       LFE06               ; go load a machine language file
      | 
      |                 * Load a crunched Basic program file from cassette
 FD6A | 4F              LFD6A     clra                          ; ACCA = Basic Program file type ($00)
 FD6B | 8D 22                     bsr       LFD8F               ; parse name argument and locate the file
 FD6D | BD E3 CF                  jsr       LE3CF               ; erase current program (NEW)
 FD70 | 73 42 6E                  com       CLDFLG              ; set flag to force a NEW upon error
 FD73 | FC 42 6C                  ldd       LDSIZE              ; get size of the cassette file
 FD76 | D3 93                     addd      TXTTAB              ; add start address for Basic programs
 FD78 | BD E2 1E                  jsr       LE21E               ; issue an ?OM ERROR if file won't fit
 FD7B | DE 93                     ldx       TXTTAB              ; point X to start address for Basic program
 FD7D | FF 42 78        LFD7D     stx       BLKPTR              ; set load address for next cassette block
 FD80 | 8D 4E                     bsr       LFDD0               ; read a block of data from cassette
 FD82 | 2A F9                     bpl       LFD7D               ; keep reading blocks until End-Of-File
 FD84 | DF 95                     stx       VARTAB              ; store end of program / start of variables
 FD86 | CE E1 BB                  ldx       #PROMPT-2           ; point X to carriage return and "OK" prompt (-1)
 FD89 | BD E7 A8                  jsr       STROUT              ; output string to the screen
 FD8C | 7E E2 EB                  jmp       LE2EB               ; rebuild program line links and return
      | 
      |                 * Parse optional file name argument, search for file and check file type.
      |                 * Pass the expected file type in ACCA.
 FD8F | 36              LFD8F     psha                          ; push expected file type onto the stack
 FD90 | 8D 10                     bsr       LFDA2               ; parse name argument, find the file and sync
 FD92 | 32                        pula                          ; pull expected file type
 FD93 | 7D 42 74                  tst       MYSTRY              ; MYSTERY: this byte at $4274 is..
 FD96 | 26 37                     bne       LFDCF               ; ..not touched by any other code
 FD98 | B1 42 67                  cmpa      CFTYPE              ; is file the type we expected?
 FD9B | 27 32                     beq       LFDCF               ; RTS if correct file type
 FD9D | C6 24                     ldab      #FM_ERR             ; code for ?FM ERROR
 FD9F | 7E E2 38                  jmp       ERRGEN              ; issue the error
      | 
      |                 * Parse optional file name argument, search for the file and sync for reading first data block.
 FDA2 | 8D 8F           LFDA2     bsr       LFD33               ; parse filename argument if provided
 FDA4 | BD FE 37                  jsr       LFE37               ; scan cassette looking for the file
 FDA7 | 26 03                     bne       LFDAC               ; if error occured then issue an ?IO ERROR
 FDA9 | 7E FF 4E                  jmp       SYNLDR              ; read leader preceding data blocks and return
      | 
      |                 * Issue an ?IO ERROR
 FDAC | C6 22           LFDAC     ldab      #IO_ERR             ; code for ?IO ERROR
 FDAE | 7E E2 38                  jmp       ERRGEN              ; issue the error
      | 
      |                 * Load Array data file from cassette
 FDB1 | 8D 28           LFDB1     bsr       LFDDB               ; parse array name and find start/end addresses
 FDB3 | 86 04                     ldaa      #$04                ; ACCA = Array Data file type ($04)
 FDB5 | 8D D8                     bsr       LFD8F               ; parse filename argument and locate the file
 FDB7 | FC 42 71                  ldd       CASEND              ; get the array's end address
 FDBA | B3 42 6F                  subd      CASBEG              ; calculate total size of array (end-beginning)
 FDBD | B3 42 6C                  subd      LDSIZE              ; subtract size of the cassette file
 FDC0 | 24 03                     bcc       LFDC5               ; branch if array size >= file size
 FDC2 | 7E E2 36                  jmp       LE236               ; array is too small so issue an ?OM ERROR
 FDC5 | FE 42 6F        LFDC5     ldx       CASBEG              ; point X to start of array data
      | 
      |                 * Load cassette file blocks into memory until an End-Of-File block is encountered
 FDC8 | FF 42 78        LFDC8     stx       BLKPTR              ; set block load address
 FDCB | 8D 03                     bsr       LFDD0               ; load a block
 FDCD | 2A F9                     bpl       LFDC8               ; loop if not End-Of-File
 FDCF | 39              LFDCF     rts                           ; return
      | 
      |                 * Load a Data block or End-Of-File block from cassette
 FDD0 | BD FE B6        LFDD0     jsr       LFEB6               ; load a block into memory
 FDD3 | 26 D7           LFDD3     bne       LFDAC               ; branch if IO Error
 FDD5 | B6 42 75                  ldaa      BLKTYP              ; check the block type
 FDD8 | 27 D2                     beq       LFDAC               ; issue ?IO ERROR if unexpected block type
 FDDA | 39                        rts                           ; return
      | 
      |                 * Calculate starting and ending addresses of the array data for CSAVE*
 FDDB | BD 00 EB        LFDDB     jsr       >CHRGET             ; parse next character
 FDDE | C6 01                     ldab      #$01                ; set arry mode flag to..
 FDE0 | D7 86                     stab      ARYMOD              ; ..force lookup of an array
 FDE2 | BD EB 1B                  jsr       LEB1B               ; lookup the array (return ptr in X)
 FDE5 | 7F 00 86                  clr       ARYMOD              ; reset array mode flag
 FDE8 | BD E9 0E                  jsr       LE90E               ; issue a ?TM ERROR if string array
 FDEB | EC 02                     ldd       2,X                 ; ACCD = size of array 
 FDED | BD E2 2D                  jsr       LE22D               ; calculate end address of array (X=X+ACCD)
 FDF0 | FF 42 71                  stx       CASEND              ; set end address for cassette output
 FDF3 | DE 89                     ldx       TMPTR1              ; point X to start of array
 FDF5 | E6 04                     ldab      4,X                 ; ACCB = number of dimensions in array
 FDF7 | 58                        aslb                          ; multiply by 2 to get dimension table size
 FDF8 | CB 05                     addb      #5                  ; add size of array header
 FDFA | 3A                        abx                           ; point X to first array element
 FDFB | FF 42 6F                  stx       CASBEG              ; set start address for cassette output
 FDFE | BD 00 F3                  jsr       >CHRGOT             ; get current parse character
 FE01 | 27 CC                     beq       LFDCF               ; RTS if end of statement
 FE03 | 7E EA 2F                  jmp       SYNCOM              ; syntax check for comma ',' and return
      | 
      |                 * Load machine language (binary) file from cassette
 FE06 | BD 00 EB        LFE06     jsr       >CHRGET             ; consume the 'M' which follows CLOAD
 FE09 | 86 02                     ldaa      #$02                ; ACCA = Machine Language file type ($02)
 FE0B | 8D 82                     bsr       LFD8F               ; parse name argument and locate the file
 FE0D | CE 00 00                  ldx       #0                  ; default load offset = 0
 FE10 | BD 00 F3                  jsr       >CHRGOT             ; get current parse character
 FE13 | 27 06                     beq       LFE1B               ; branch if no offset parameter provided
 FE15 | BD EA 2F                  jsr       SYNCOM              ; syntax check for comma ','
 FE18 | BD EF 4C                  jsr       LEF4C               ; evaluate expression (0..65535) into X
 FE1B | DF 89           LFE1B     stx       TMPTR1              ; save load offset in temp location
 FE1D | FC 42 6A                  ldd       CFEXEC              ; get the file's EXEC address
 FE20 | D3 89                     addd      TMPTR1              ; add the load offset
 FE22 | FD 42 1F                  std       EXECJP              ; set default address for EXEC command
 FE25 | FC 42 6C                  ldd       LDSIZE              ; get the file's LOAD address
 FE28 | D3 89                     addd      TMPTR1              ; add the load offset
 FE2A | 37                        pshb                          ; transfer actual..
 FE2B | 36                        psha                          ; ..load address..
 FE2C | 38                        pulx                          ; ..from ACCD to X
 FE2D | 20 99                     bra       LFDC8               ; go load the file blocks into memory
      | 
      |                 ***
      |                 *** SKIPF [fileName]
      |                 ***
 FE2F | BD FD A2        SKIPF     jsr       LFDA2               ; parse name argument and locate the file
 FE32 | 8D 56                     bsr       LFE8A               ; scan data blocks until End-Of-File
 FE34 | 26 9D                     bne       LFDD3               ; if an error occured then issue ?IO ERROR
 FE36 | 39                        rts                           ; return
      | 
      |                 * Search the cassette for a file with the name specified in CFNSTR.
 FE37 | 96 E2           LFE37     ldaa      CURLIN              ; get MSB of current line number
 FE39 | 4C                        inca                          ; increment line number MSB
 FE3A | 26 0A                     bne       LFE46               ; branch if not in immediate mode
 FE3C | BD FB D4                  jsr       LFBD4               ; clear the screen
 FE3F | 86 53                     ldaa      #'S                 ; print an 'S' (meaning Search)..
 FE41 | 8D 3E                     bsr       LFE81               ; ..at top left corner of screen..
 FE43 | BD E7 B9                  jsr       OUTSPC              ; ..followed by a space
      | 
 FE46 | 8D 62           LFE46     bsr       LFEAA               ; read a cassette leader and Name block
 FE48 | BA 42 75                  oraa      BLKTYP              ; OR block type with error status
 FE4B | 26 33                     bne       LFE80               ; RTS on error or if not a Name block
 FE4D | 5F                        clrb                          ; name character offset = 0
 FE4E | 37                        pshb                          ; push name comparison result (0=match)
 FE4F | CE 42 5F        LFE4F     ldx       #NAMBLK             ; point X to the cassette file's name
 FE52 | 3A                        abx                           ; add name character offset
 FE53 | A6 00                     ldaa      ,X                  ; get file name character
 FE55 | DE E2                     ldx       CURLIN              ; get current line number
 FE57 | 08                        inx                           ; if not in immediate mode..
 FE58 | 26 02                     bne       LFE5C               ; ..then skip next instruction
 FE5A | 8D 25                     bsr       LFE81               ; output name character to the screen
 FE5C | CE 42 57        LFE5C     ldx       #CFNSTR             ; point X to filename argument string
 FE5F | 3A                        abx                           ; add name character offset
 FE60 | A0 00                     suba      ,X                  ; compare with actual filename char
 FE62 | 30                        tsx                           ; point X to name comparison result
 FE63 | AA 00                     oraa      ,X                  ; set name comparison result to..
 FE65 | A7 00                     staa      ,X                  ; ..non-zero value if not a match
 FE67 | 5C                        incb                          ; increment name character offset
 FE68 | C1 08                     cmpb      #8                  ; loop until all 8 characters..
 FE6A | 26 E3                     bne       LFE4F               ; ..of the name have been compared
 FE6C | 32                        pula                          ; pull name comparison result into ACCA
 FE6D | 4D                        tsta                          ; test for name match
 FE6E | 27 0B                     beq       LFE7B               ; branch if names match
 FE70 | 7D 42 56                  tst       CFNLEN              ; test length of filename argument
 FE73 | 27 06                     beq       LFE7B               ; branch if no filename specified
 FE75 | 8D 10                     bsr       LFE87               ; scan blocks until end-of-file
 FE77 | 26 07                     bne       LFE80               ; branch if an error occured
 FE79 | 20 BC                     bra       LFE37               ; search for another Name block
      | 
 FE7B | 86 46           LFE7B     ldaa      #'F                 ; change character in top-left corner..
 FE7D | 8D 22                     bsr       LFEA1               ; ..of the screen to 'F' (meaning Found)
 FE7F | 4F                        clra                          ; set return status to 'no error'
 FE80 | 39              LFE80     rts                           ; return
      | 
      | 
      |                 * Output character in ACCA to the screen
 FE81 | 7F 00 E8        LFE81     clr       DEVNUM              ; set screen as current output device
 FE84 | 7E F9 C6                  jmp       PUTCHR              ; output character in ACCA and return
      | 
      | 
      |                 * Skip through cassette file blocks until an End-Of-File or bad block is encountered
 FE87 | BD FF 4E        LFE87     jsr       SYNLDR              ; synchronize with cassette leader
 FE8A | 86 FF           LFE8A     ldaa      #255                ; allow maximum block size (255 bytes)
 FE8C | 16                        tab                           ; do not load the block (ACCB = $FF)
 FE8D | 8D 2A                     bsr       GETBLK              ; read (but do not load) cassette block
 FE8F | 26 07                     bne       LFE98               ; branch if an error occured
 FE91 | B6 42 75                  ldaa      BLKTYP              ; get the block type
 FE94 | 40                        nega                          ; negate block type
 FE95 | 2B F3                     bmi       LFE8A               ; loop if it's a Data block
 FE97 | 4A                        deca                          ; ACCA = 0 if it's an End-Of-File block
 FE98 | B7 42 7B        LFE98     staa      CCTERR              ; store status result
 FE9B | 39                        rts                           ; return
      | 
      |                 * Invert the character at the top-left corner of the screen (only when in Immediate mode)
 FE9C | B6 40 00        LFE9C     ldaa      VIDRAM              ; get character from Video RAM
 FE9F | 88 40                     eora      #$40                ; toggle the inverse video bit
 FEA1 | D6 E2           LFEA1     ldab      CURLIN              ; get MSB of current line number
 FEA3 | 5C                        incb                          ; ACCB = 0 if in immediate mode
 FEA4 | 26 03                     bne       LFEA9               ; branch in not immediate mode
 FEA6 | B7 40 00                  staa      VIDRAM              ; store inverted character to Video RAM
 FEA9 | 39              LFEA9     rts                           ; return
      | 
      |                 * Scan cassette for a string of leader bytes and then read a Name Block
 FEAA | BD FF 4E        LFEAA     jsr       SYNLDR              ; find cassette leader
 FEAD | CE 42 5F                  ldx       #NAMBLK             ; point X to the Name Block buffer
 FEB0 | FF 42 78                  stx       BLKPTR              ; set block load address
 FEB3 | 86 0F                     ldaa      #15                 ; block size limit = size of Name block
 FEB5 | 8C                        fcb       SKP2                ; skip next instruction
      | 
      |                 * Load any block from cassette into RAM
 FEB6 | 86 FF           LFEB6     ldaa      #255                ; allow block size up to 255 bytes
 FEB8 | 5F                        clrb                          ; allow block data to be stored in RAM
      | 
      |                 * Read a block from cassette.
      |                 * Enter with block size limit in ACCA.
      |                 * Enter with 'No Load' option in ACCB.
 FEB9 | 36              GETBLK    psha                          ; push block size limit onto stack
 FEBA | F7 42 73                  stab      NOLOAD              ; store the No Load flag
 FEBD | 01                        nop                           ; ?
 FEBE | 0F                        sei                           ; mask IRQs
 FEBF | 8D DB                     bsr       LFE9C               ; invert top-left character on screen
 FEC1 | FE 42 78                  ldx       BLKPTR              ; point X to block load address
      | 
      |                 * Scan for the Sync byte
 FEC4 | 4F                        clra                          ; clear data shift register
 FEC5 | 8D 5B           LFEC5     bsr       LFF22               ; read one bit from cassette into..
 FEC7 | 46                        rora                          ; ..the data shift register (ACCA)
 FEC8 | 81 3C                     cmpa      #%00111100          ; check for sync pattern
 FECA | 26 F9                     bne       LFEC5               ; loop until sync pattern detected
      | 
      |                 * Read the block header bytes and calculate initial checksum
 FECC | 8D 46                     bsr       LFF14               ; read the block type..
 FECE | B7 42 75                  staa      BLKTYP              ; ..byte from cassette
 FED1 | 8D 41                     bsr       LFF14               ; read the block length..
 FED3 | B7 42 76                  staa      BLKLEN              ; ..byte from cassette
 FED6 | 33                        pulb                          ; pull block size limit from stack
 FED7 | 11                        cba                           ; compare block length to size limit
 FED8 | 22 31                     bhi       LFF0B               ; branch if block length exceeds limit
 FEDA | BB 42 75                  adda      BLKTYP              ; add block type to block length
 FEDD | B7 42 7A                  staa      BLKSUM              ; store initial checksum
 FEE0 | B6 42 76                  ldaa      BLKLEN              ; get block length
 FEE3 | B7 42 7B                  staa      CCTERR              ; set block I/O counter
 FEE6 | 27 19                     beq       LFF01               ; branch if it's an End-of-File block
      | 
      |                 * Read the block data bytes and calculate checksum
 FEE8 | 8D 2A           LFEE8     bsr       LFF14               ; read one byte from cassette
 FEEA | 7D 42 73                  tst       NOLOAD              ; test the No Load flag
 FEED | 26 07                     bne       LFEF6               ; branch if not loading this file
 FEEF | A7 00                     staa      ,X                  ; store loaded byte in memory
 FEF1 | A1 00                     cmpa      ,X                  ; was storage successful?
 FEF3 | 26 19                     bne       LFF0E               ; branch if not RAM
 FEF5 | 08                        inx                           ; advance X to next storage address
 FEF6 | BB 42 7A        LFEF6     adda      BLKSUM              ; add byte value to checksum
 FEF9 | B7 42 7A                  staa      BLKSUM              ; store updated checksum
 FEFC | 7A 42 7B                  dec       CCTERR              ; decrement block I/O counter
 FEFF | 26 E7                     bne       LFEE8               ; loop if more bytes to read
      | 
      |                 * Read checksum byte and compare with calculated sum
 FF01 | 8D 11           LFF01     bsr       LFF14               ; read checksum byte from cassette
 FF03 | B0 42 7A                  suba      BLKSUM              ; compare with calculated checksum
 FF06 | 27 08                     beq       LFF10               ; branch if checksums match (ACCA=0)
 FF08 | 86 01                     ldaa      #1                  ; set status code for bad checksum
 FF0A | 8C                        fcb       SKP2                ; skip next instruction
 FF0B | 86 03           LFF0B     ldaa      #3                  ; set status code for bad block size
 FF0D | 8C                        fcb       SKP2                ; skip next instruction
 FF0E | 86 02           LFF0E     ldaa      #2                  ; set status code for bad RAM
 FF10 | B7 42 7B        LFF10     staa      CCTERR              ; store status return value
 FF13 | 39                        rts                           ; return
      | 

lees een byte vanuit ander memoryblock 

      |                 * Read one byte from cassette and return it in ACCA
 FF14 | 86 08           LFF14     ldaa      #8                  ; Set loop counter for..
 FF16 | B7 42 7C                  staa      CBITCT              ; ..reading eight bits
 FF19 | 8D 07           LFF19     bsr       LFF22               ; read one bit into carry
 FF1B | 46                        rora                          ; move bit into ACCA
 FF1C | 7A 42 7C                  dec       CBITCT              ; decrement loop counter
 FF1F | 26 F8                     bne       LFF19               ; loop until byte is complete
 FF21 | 39                        rts                           ; return
      | 
      |                 * Read one bit from cassette and return it in the Carry flag
 FF22 | 8D 08           LFF22     bsr       LFF2C               ; read a transition cycle from cassette
 FF24 | F6 42 7D                  ldab      CASTIM              ; get the cycle duration
 FF27 | 5A                        decb                          ; subtract 1
 FF28 | F1 42 2C                  cmpb      CYCPAR              ; compare to 1200/2400 Hz cycle partition
 FF2B | 39                        rts                           ; return
      | 
      |                 * Read a full cycle from cassette and return timing in CASTIM
 FF2C | 7F 42 7D        LFF2C     clr       CASTIM              ; clear the cycle timing counter
 FF2F | 7D 42 7E                  tst       CASPOL              ; check polarity flag and fork to read..
 FF32 | 26 11                     bne       LFF45               ; ..the corresponding transition sequence
      | 
      |                 * Wait for a HI -> LO -> HI cycle and return total time in CASTIM
 FF34 | 8D 07           LFF34     bsr       LFF3D               ; increment CASTIM and check input level
 FF36 | 26 FC                     bne       LFF34               ; loop until input level goes LO
 FF38 | 8D 03           LFF38     bsr       LFF3D               ; increment CASTIM and check input level
 FF3A | 27 FC                     beq       LFF38               ; loop until input level goes HI
 FF3C | 39                        rts                           ; return
      | 
      |                 * Increment CASTIM and return current cassette input level in the Z flag
 FF3D | 7C 42 7D        LFF3D     inc       CASTIM              ; increment timing counter
 FF40 | D6 03                     ldab      P2DATA              ; read CPU port 2
 FF42 | C4 10                     andb      #$10                ; set Z flag according to input level
 FF44 | 39                        rts                           ; return
      | 
      |                 * Wait for a LO -> HI -> LO cycle and return total time in CASTIM
 FF45 | 8D F6           LFF45     bsr       LFF3D               ; increment CASTIM and check input level
 FF47 | 27 FC                     beq       LFF45               ; loop until input level goes HI
 FF49 | 8D F2           LFF49     bsr       LFF3D               ; increment CASTIM and check input level
 FF4B | 26 FC                     bne       LFF49               ; loop until input level goes LO
 FF4D | 39                        rts                           ; return
      | 
      |                 * Syncronize with a cassette leader and determine the signal polarity
 FF4E | 01              SYNLDR    nop                           ; what for ??
 FF4F | 0F                        sei                           ; mask IRQs
 FF50 | 7F 42 7C                  clr       CBITCT              ; clear polarity flag / phase counter
      | 
 FF53 | 8D DF           LFF53     bsr       LFF34               ; wait for HI->LO->HI transitions
 FF55 | 8D 2D           LFF55     bsr       LFF84               ; wait for HI->LO transition
 FF57 | 22 12                     bhi       LFF6B               ; branch if 1200 Hz
 FF59 | 8D 22           LFF59     bsr       LFF7D               ; wait for LO->HI transition
 FF5B | 25 12                     blo       LFF6F               ; branch if 2400 Hz
      | 
      |                 * 2400 Hz HI->LO followed by 1200 Hz LO->HI is negative polarity
 FF5D | 7A 42 7C                  dec       CBITCT              ; bump phase counter (negative polarity)
 FF60 | B6 42 7C                  ldaa      CBITCT              ; have we seen 96 negative..
 FF63 | 81 A0                     cmpa      #-96                ; ..polarity transitions?
 FF65 | 26 EC           LFF65     bne       LFF53               ; keep going if fewer than 96
 FF67 | B7 42 7E                  staa      CASPOL              ; store polarity flag
 FF6A | 39                        rts                           ; return
      | 
 FF6B | 8D 10           LFF6B     bsr       LFF7D               ; wait for LO->HI transition
 FF6D | 22 E6                     bhi       LFF55               ; branch if 1200 Hz
 FF6F | 8D 13           LFF6F     bsr       LFF84               ; wait for HI->LO transition
 FF71 | 25 E6                     blo       LFF59               ; branch if 2400 Hz
      | 
      |                 * 2400 Hz LO->HI followed by 1200 Hz HI->LO is positive polarity
 FF73 | 7C 42 7C                  inc       CBITCT              ; bump phase counter (positive polarity)
 FF76 | B6 42 7C                  ldaa      CBITCT              ; have we seen 96 positive..
 FF79 | 80 60                     suba      #96                 ; ..polarity transitions?
 FF7B | 20 E8                     bra       LFF65               ; go continue or return
      | 
      |                 * Wait for a LO->HI transition and track how long we waited
 FF7D | 7F 42 7D        LFF7D     clr       CASTIM              ; clear timing counter
 FF80 | 8D B6                     bsr       LFF38               ; increment timing count until level is HI
 FF82 | 20 05                     bra       LFF89               ; go check the timing
      | 
      |                 * Wait for a HI->LO transition and track how long we waited
 FF84 | 7F 42 7D        LFF84     clr       CASTIM              ; clear timing counter
 FF87 | 8D C0                     bsr       LFF49               ; increment timing count until level is LO
      | 
      |                 * Validate transition time. Return with carry clear for 1200 Hz, carry set 2400 Hz 
 FF89 | F6 42 7D        LFF89     ldab      CASTIM              ; get transition wait time
 FF8C | F1 42 2D                  cmpb      CMAXTR              ; compare to maximum valid time
 FF8F | 22 04                     bhi       LFF95               ; branch if exceeded maximum timing
 FF91 | F1 42 2E                  cmpb      TRNPAR              ; compare to 1200/2400 Hz transition partition
 FF94 | 39                        rts                           ; return
      | 
      |                 * Transition wait time exceeded the maximum.  Restart leader synchronization.
 FF95 | 7F 42 7C        LFF95     clr       CBITCT              ; clear the phase counter / polarity flag
 FF98 | 39                        rts                           ; return
      | 
      |                 *
      |                 * Argument evaluator for the SOUND command
 FF99 | BD EA 2F        LFF99     jsr       SYNCOM              ; syntax check for comma ','
 FF9C | BD EF 0D        LFF9C     jsr       LEF0D               ; evaulate expression (0..255) into ACCB
 FF9F | 5D                        tstb                          ; if argument value is..
 FFA0 | 26 2F                     bne       LFFD1               ; ..not zero then RTS
 FFA2 | 7E EC 2E                  jmp       ILLFNC              ; issue an ?FC ERROR for argument of 0
      | 
      |                 ***
      |                 *** SOUND  pitch , duration
      |                 ***
 FFA5 | 8D F5           SOUND     bsr       LFF9C               ; evaluate pitch argument into ACCB
 FFA7 | 37                        pshb                          ; push pitch onto stack
 FFA8 | 8D EF                     bsr       LFF99               ; evaluate duration argument into ACCB
 FFAA | 32                        pula                          ; pull pitch into ACCA
      | 
      |                 * Play a sound through the TV speaker.
      |                 * Enter with pitch in ACCA and duration in ACCB.
 FFAB | 36              SNDGEN    psha                          ; push pitch..
 FFAC | 37                        pshb                          ; ..and duration onto stack
 FFAD | 4F                        clra                          ; sound output state = 0
 FFAE | DE 09           LFFAE     ldx       TIMER               ; get current CPU timer value
 FFB0 | D6 08                     ldab      TCSR                ; clear the Output Compare Flag
 FFB2 | DF 0B                     stx       TOCR                ; store new Output Compare value
 FFB4 | 88 80           LFFB4     eora      #$80                ; toggle sound output state
 FFB6 | B7 BF FF                  staa      KVSPRT              ; update hardware
      | 
      |                 * Pitch delay loop.  Delay = (256 - pitch) * 11 cycles
 FFB9 | 30                        tsx                           ; point X to stacked parameters
 FFBA | E6 01                     ldab      1,X                 ; ACCB = pitch counter
 FFBC | 08              LFFBC     inx                           ; (3) delay
 FFBD | 08                        inx                           ; (3) delay
 FFBE | 5C                        incb                          ; (2) increment pitch counter
 FFBF | 26 FB                     bne       LFFBC               ; (3) loop until pitch counter = 0
      | 
 FFC1 | D6 08                     ldab      TCSR                ; read timer status register
 FFC3 | C4 40                     andb      #$40                ; test the Output Compare flag
 FFC5 | 27 ED                     beq       LFFB4               ; loop if timer hasn't fully cycled
      | 
 FFC7 | 30                        tsx                           ; point X to stacked parameters
 FFC8 | 6A 00                     dec       ,X                  ; decrement duration counter
 FFCA | 26 E2                     bne       LFFAE               ; loop if duration hasn't expired
 FFCC | 4F                        clra                          ; sound output state = 0
 FFCD | B7 BF FF                  staa      KVSPRT              ; set sound hardware state
 FFD0 | 38                        pulx                          ; pop parameters off the stack
 FFD1 | 39              LFFD1     rts                           ; return
      | 
      | 
      |                 * Mark Chamberlin co-wrote the 6800 version of Microsoft Basic.
      |                 * Perhaps he also worked on the MC-10 version?
 FFD2 | 6E 69 6C 72 65            fcc       'nilrebmahC'        ; 'Chamberlin' spelled backwards
 FFD7 | 62 6D 61 68 43 
      | 
      | 
      |                 * Jump table for public subroutines
 FFDC | F8 83           POLCAT    fdb       KEYIN               ; read keyboard
 FFDE | F9 C6           CHROUT    fdb       PUTCHR              ; console out
 FFE0 | FF 4E           RDCLDR    fdb       SYNLDR              ; read a cassette leader
 FFE2 | FE B9           BLKIN     fdb       GETBLK              ; read a block from cassette
 FFE4 | FC C0           BLKOUT    fdb       PUTBLK              ; write a block to cassette 
 FFE6 | FF AB           SNDOUT    fdb       SNDGEN              ; generate sound through TV speaker
 FFE8 | FC B7           WRTLDR    fdb       LDROUT              ; write cassette leader
 FFEA | EC E3           IRETRN    fdb       GIVABF              ; convert integer in ACCD to FP in FPA0
 FFEC | EB C7           GETARG    fdb       INTCNV              ; convert FPA0 to an integer in ACCD
 FFEE | 00 C9                     fdb       FP0EXP              ; address of FPA0
      | 
      |                 *
      |                 * HD6303 NOTE:
      |                 *  The HD6303 has 1 additional vector at $FFEE which is used for
      |                 *  Illegal Instruction and Illegal Address trapping.  The MC-10 ROM
      |                 *  stores the address of FPA0 ($00C9) in this location, but never
      |                 *  references it.
      |                 *
      | 
      |                 * CPU Vectors
 FFF0 | 42 00                     fdb       SCIVEC              ; serial comm interrupt    (maskable)
 FFF2 | 42 03                     fdb       TOFVEC              ; timer overflow interrupt (maskable)
 FFF4 | 42 06                     fdb       OCFVEC              ; output compare interrupt (maskable)
 FFF6 | 42 09                     fdb       ICFVEC              ; input capture interrupt  (maskable)
 FFF8 | 42 0C                     fdb       IRQVEC              ; external IRQ             (maskable)
 FFFA | 42 0F                     fdb       SWIVEC              ; software interrupt
 FFFC | 42 12                     fdb       NMIVEC              ; non-maskable interrupt
 FFFE | F7 2E                     fdb       CPURES              ; CPU reset
      | 
      |                           end
      | 
